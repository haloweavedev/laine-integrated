This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: README.md, app/practice-config/page.tsx, app/practice-config/AppointmentTypesConfig.tsx, app/practice-config/ProvidersConfig.tsx, app/practice-config/QuickReview.tsx, app/practice-config/CheckAppointmentSlotsTool.tsx, app/api/practice-config/appointment-types/route.ts, app/api/practice-config/appointment-types/[appointmentTypeId]/route.ts, app/api/practice-config/basic/route.ts, app/api/practice-config/check-slots/route.ts, app/api/practice-config/provider-settings/[savedProviderId]/route.ts, app/api/practice-config/quick-review/route.ts, app/api/practice-config/webhook-status/route.ts, app/api/practice-config/webhook-sync/route.ts, app/api/practice-config/data/route.ts, app/api/nexhealth-webhook/route.ts, app/api/sync-nexhealth/route.ts, app/api/laine-config/update/route.ts, prisma/schema.prisma, lib/nexhealth.ts, lib/prisma.ts, lib/tools/bookAppointment.ts, lib/tools/checkAvailableSlots.ts, lib/tools/types.ts, lib/tools/index.ts, middleware.ts, app/layout.tsx, app/globals.css
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    laine-config/
      update/
        route.ts
    nexhealth-webhook/
      route.ts
    practice-config/
      appointment-types/
        [appointmentTypeId]/
          route.ts
        route.ts
      basic/
        route.ts
      check-slots/
        route.ts
      data/
        route.ts
      provider-settings/
        [savedProviderId]/
          route.ts
      quick-review/
        route.ts
      webhook-status/
        route.ts
      webhook-sync/
        route.ts
    sync-nexhealth/
      route.ts
  practice-config/
    AppointmentTypesConfig.tsx
    CheckAppointmentSlotsTool.tsx
    page.tsx
    ProvidersConfig.tsx
    QuickReview.tsx
  globals.css
  layout.tsx
lib/
  tools/
    bookAppointment.ts
    checkAvailableSlots.ts
    index.ts
    types.ts
  nexhealth.ts
  prisma.ts
prisma/
  schema.prisma
middleware.ts
README.md

================================================================
Files
================================================================

================
File: app/api/practice-config/provider-settings/[savedProviderId]/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

interface RouteParams {
  savedProviderId: string;
}

const updateProviderSettingsSchema = z.object({
  acceptedAppointmentTypeIds: z.array(z.string()).optional(),
  defaultAppointmentTypeId: z.string().nullable().optional(),
  defaultOperatoryId: z.string().nullable().optional()
});

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { savedProviderId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Fetch the saved provider with all related data
    const savedProvider = await prisma.savedProvider.findFirst({
      where: {
        id: savedProviderId,
        practiceId: practice.id
      },
      include: {
        provider: {
          select: {
            id: true,
            nexhealthProviderId: true,
            firstName: true,
            lastName: true
          }
        },
        defaultAppointmentType: {
          select: {
            id: true,
            name: true,
            nexhealthAppointmentTypeId: true,
            duration: true,
            groupCode: true
          }
        },
        defaultOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        },
        acceptedAppointmentTypes: {
          include: {
            appointmentType: {
              select: {
                id: true,
                name: true,
                nexhealthAppointmentTypeId: true,
                duration: true,
                groupCode: true
              }
            }
          }
        }
      }
    });

    if (!savedProvider) {
      return NextResponse.json({ 
        error: "Provider not found or doesn't belong to this practice" 
      }, { status: 404 });
    }

    // Format the response
    const response = {
      id: savedProvider.id,
      provider: savedProvider.provider,
      isActive: savedProvider.isActive,
      defaultAppointmentType: savedProvider.defaultAppointmentType,
      defaultOperatory: savedProvider.defaultOperatory,
      acceptedAppointmentTypes: savedProvider.acceptedAppointmentTypes.map(relation => relation.appointmentType),
      createdAt: savedProvider.createdAt,
      updatedAt: savedProvider.updatedAt
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error("Error fetching provider settings:", error);
    return NextResponse.json(
      { error: "Failed to fetch provider settings" },
      { status: 500 }
    );
  }
}

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { savedProviderId } = await params;
    const body = await req.json();

    // Validate input
    const validationResult = updateProviderSettingsSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { acceptedAppointmentTypeIds, defaultAppointmentTypeId, defaultOperatoryId } = validationResult.data;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Verify the saved provider belongs to this practice
    const savedProvider = await prisma.savedProvider.findFirst({
      where: {
        id: savedProviderId,
        practiceId: practice.id
      }
    });

    if (!savedProvider) {
      return NextResponse.json({ 
        error: "Provider not found or doesn't belong to this practice" 
      }, { status: 404 });
    }

    // Validate appointment type IDs belong to practice if provided
    if (acceptedAppointmentTypeIds && acceptedAppointmentTypeIds.length > 0) {
      const validAppointmentTypes = await prisma.appointmentType.findMany({
        where: {
          id: { in: acceptedAppointmentTypeIds },
          practiceId: practice.id
        }
      });

      if (validAppointmentTypes.length !== acceptedAppointmentTypeIds.length) {
        return NextResponse.json({
          error: "Some appointment types don't belong to this practice"
        }, { status: 400 });
      }
    }

    // Validate default appointment type belongs to practice if provided
    if (defaultAppointmentTypeId) {
      const defaultAppointmentType = await prisma.appointmentType.findFirst({
        where: {
          id: defaultAppointmentTypeId,
          practiceId: practice.id
        }
      });

      if (!defaultAppointmentType) {
        return NextResponse.json({
          error: "Default appointment type doesn't belong to this practice"
        }, { status: 400 });
      }
    }

    // Validate default operatory belongs to practice if provided
    if (defaultOperatoryId) {
      const defaultOperatory = await prisma.savedOperatory.findFirst({
        where: {
          id: defaultOperatoryId,
          practiceId: practice.id,
          isActive: true
        }
      });

      if (!defaultOperatory) {
        return NextResponse.json({
          error: "Default operatory doesn't belong to this practice or is not active"
        }, { status: 400 });
      }
    }

    // Use transaction to ensure atomicity
    await prisma.$transaction(async (tx) => {
      // Update the SavedProvider record with defaults
      const updated = await tx.savedProvider.update({
        where: { id: savedProviderId },
        data: {
          defaultAppointmentTypeId: defaultAppointmentTypeId !== undefined ? defaultAppointmentTypeId : undefined,
          defaultOperatoryId: defaultOperatoryId !== undefined ? defaultOperatoryId : undefined
        }
      });

      // Manage accepted appointment types if provided
      if (acceptedAppointmentTypeIds !== undefined) {
        // Delete existing associations
        await tx.providerAcceptedAppointmentType.deleteMany({
          where: { savedProviderId }
        });

        // Create new associations if any provided
        if (acceptedAppointmentTypeIds.length > 0) {
          await tx.providerAcceptedAppointmentType.createMany({
            data: acceptedAppointmentTypeIds.map(appointmentTypeId => ({
              savedProviderId,
              appointmentTypeId
            }))
          });
        }
      }

      return updated;
    });

    // Fetch the updated provider with all related data for response
    const responseData = await prisma.savedProvider.findUnique({
      where: { id: savedProviderId },
      include: {
        provider: {
          select: {
            id: true,
            nexhealthProviderId: true,
            firstName: true,
            lastName: true
          }
        },
        defaultAppointmentType: {
          select: {
            id: true,
            name: true,
            nexhealthAppointmentTypeId: true,
            duration: true,
            groupCode: true
          }
        },
        defaultOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        },
        acceptedAppointmentTypes: {
          include: {
            appointmentType: {
              select: {
                id: true,
                name: true,
                nexhealthAppointmentTypeId: true,
                duration: true,
                groupCode: true
              }
            }
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      provider: {
        ...responseData,
        acceptedAppointmentTypes: responseData?.acceptedAppointmentTypes.map(relation => relation.appointmentType)
      }
    });

  } catch (error) {
    console.error("Error updating provider settings:", error);
    return NextResponse.json(
      { error: "Failed to update provider settings" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/quick-review/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Execute all queries in parallel for better performance
    const [appointmentsBookedByLaine, activeProvidersCount, appointmentTypesCount] = await Promise.all([
      // Count appointments booked via Laine
      prisma.callLog.count({
        where: {
          practiceId: practice.id,
          bookedAppointmentNexhealthId: {
            not: null
          }
        }
      }),

      // Count active providers
      prisma.savedProvider.count({
        where: {
          practiceId: practice.id,
          isActive: true
        }
      }),

      // Count appointment types created
      prisma.appointmentType.count({
        where: {
          practiceId: practice.id
        }
      })
    ]);

    return NextResponse.json({
      appointmentsBookedByLaine,
      activeProvidersCount,
      appointmentTypesCount
    });

  } catch (error) {
    console.error("Error fetching quick review data:", error);
    return NextResponse.json(
      { error: "Failed to fetch quick review data" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/webhook-status/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      select: {
        id: true,
        name: true,
        webhookLastSyncAt: true,
        nexhealthSubdomain: true,
        nexhealthLocationId: true,
        nexhealthWebhookSubscriptions: {
          where: { isActive: true },
          select: {
            resourceType: true,
            eventName: true,
            nexhealthSubscriptionId: true,
            createdAt: true
          }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Determine sync status based on available information
    let lastSyncStatus: string;
    let lastSyncSuccessAt: Date | null = null;
    const lastSyncErrorMessage: string | null = null;

    if (!practice.webhookLastSyncAt) {
      lastSyncStatus = "NEVER_SYNCED";
    } else {
      // For now, assume sync was successful if we have a timestamp
      // In the future, we could add a webhookSyncErrorMsg field to track failures
      lastSyncStatus = "SYNCED_ATTEMPTED";
      lastSyncSuccessAt = practice.webhookLastSyncAt;
    }

    // Check if practice has basic configuration
    const hasBasicConfig = !!(practice.nexhealthSubdomain && practice.nexhealthLocationId);

    return NextResponse.json({
      lastSyncAttemptAt: practice.webhookLastSyncAt,
      lastSyncSuccessAt,
      lastSyncStatus,
      lastSyncErrorMessage,
      hasBasicConfig,
      activeSubscriptionsCount: practice.nexhealthWebhookSubscriptions.length,
      subscriptions: practice.nexhealthWebhookSubscriptions.map(sub => ({
        resourceType: sub.resourceType,
        eventName: sub.eventName,
        subscribedAt: sub.createdAt
      }))
    });

  } catch (error) {
    console.error("Error fetching webhook status:", error);
    return NextResponse.json(
      { error: "Failed to fetch webhook status" },
      { status: 500 }
    );
  }
}

================
File: app/practice-config/AppointmentTypesConfig.tsx
================
"use client";

import { useState } from "react";
import { toast } from "sonner";

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  bookableOnline: boolean | null;
  groupCode: string | null;
  createdAt: string;
  updatedAt: string;
}

interface AppointmentTypesConfigProps {
  initialAppointmentTypes: AppointmentType[];
  onUpdate: () => void;
}

export function AppointmentTypesConfig({ 
  initialAppointmentTypes, 
  onUpdate 
}: AppointmentTypesConfigProps) {
  const [appointmentTypes] = useState<AppointmentType[]>(initialAppointmentTypes);
  const [syncLoading, setSyncLoading] = useState(false);

  const handleSyncWithNexHealth = async () => {
    setSyncLoading(true);
    try {
      const response = await fetch('/api/sync-nexhealth', {
        method: 'POST'
      });

      if (response.ok) {
        toast.success('Appointment types synced with NexHealth successfully!');
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Sync failed: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error syncing with NexHealth:', error);
      toast.error('Failed to sync with NexHealth');
    } finally {
      setSyncLoading(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-semibold">Appointment Types Configuration</h2>
        <button
          onClick={handleSyncWithNexHealth}
          disabled={syncLoading}
          className="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {syncLoading ? 'Syncing...' : 'Sync with NexHealth'}
        </button>
      </div>

      {/* Appointment Types Table */}
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Duration
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Group Code
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Bookable Online
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {appointmentTypes.map((type) => (
              <tr key={type.id}>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  {type.name}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {type.duration} minutes
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {type.groupCode || '-'}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                    type.bookableOnline 
                      ? 'bg-green-100 text-green-800' 
                      : 'bg-red-100 text-red-800'
                  }`}>
                    {type.bookableOnline ? 'Yes' : 'No'}
                  </span>
                </td>
              </tr>
            ))}
          </tbody>
        </table>

        {appointmentTypes.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            No appointment types configured. Sync with NexHealth to import them.
          </div>
        )}
      </div>
    </div>
  );
}

================
File: app/practice-config/CheckAppointmentSlotsTool.tsx
================
"use client";

import { useState } from "react";
import { toast } from "sonner";

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  bookableOnline: boolean | null;
  groupCode: string | null;
}

interface Provider {
  id: string;
  nexhealthProviderId: string;
  firstName: string | null;
  lastName: string;
}

interface SavedProvider {
  id: string;
  providerId: string;
  isActive: boolean;
  provider: Provider;
}

interface SavedOperatory {
  id: string;
  nexhealthOperatoryId: string;
  name: string;
  isActive: boolean;
}

interface AppointmentSlot {
  slot_id: string;
  time: string;
  end_time: string;
  display_time: string;
  display_end_time: string;
  display_range: string;
  operatory_id?: number;
  provider_id: number;
  location_id: number;
  provider_info: {
    id: string;
    name: string;
    nexhealthProviderId: string;
  };
  operatory_info: {
    id: string;
    name: string;
    nexhealthOperatoryId: string;
  } | null;
}

interface CheckSlotsResponse {
  success: boolean;
  data: {
    requested_date: string;
    appointment_type: {
      id: string;
      name: string;
      duration: number;
    };
    available_slots: AppointmentSlot[];
    has_availability: boolean;
    total_slots_found: number;
    debug_info: {
      providers_checked: number;
      operatories_checked: number;
      providers_used: Array<{
        id: string;
        name: string;
        nexhealthProviderId: string;
      }>;
      operatories_used: Array<{
        id: string;
        name: string;
        nexhealthOperatoryId: string;
      }>;
    };
  };
}

interface CheckAppointmentSlotsToolProps {
  appointmentTypes: AppointmentType[];
  savedProviders: SavedProvider[];
  savedOperatories: SavedOperatory[];
}

export function CheckAppointmentSlotsTool({
  appointmentTypes,
  savedProviders,
  savedOperatories
}: CheckAppointmentSlotsToolProps) {
  const [selectedAppointmentTypeId, setSelectedAppointmentTypeId] = useState<string>("");
  const [selectedDate, setSelectedDate] = useState<string>("");
  const [selectedProviderIds, setSelectedProviderIds] = useState<string[]>([]);
  const [selectedOperatoryIds, setSelectedOperatoryIds] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [slotsData, setSlotsData] = useState<CheckSlotsResponse["data"] | null>(null);

  // Get today's date in YYYY-MM-DD format
  const today = new Date().toISOString().split('T')[0];

  // Filter active providers and operatories
  const activeProviders = savedProviders.filter(sp => sp.isActive);
  const activeOperatories = savedOperatories.filter(so => so.isActive);

  const handleProviderChange = (savedProviderId: string, checked: boolean) => {
    if (checked) {
      setSelectedProviderIds(prev => [...prev, savedProviderId]);
    } else {
      setSelectedProviderIds(prev => prev.filter(id => id !== savedProviderId));
    }
  };

  const handleOperatoryChange = (operatoryId: string, checked: boolean) => {
    if (checked) {
      setSelectedOperatoryIds(prev => [...prev, operatoryId]);
    } else {
      setSelectedOperatoryIds(prev => prev.filter(id => id !== operatoryId));
    }
  };

  const handleCheckSlots = async () => {
    if (!selectedAppointmentTypeId) {
      toast.error("Please select an appointment type");
      return;
    }

    if (!selectedDate) {
      toast.error("Please select a date");
      return;
    }

    // Validate date is not in the past
    if (selectedDate < today) {
      toast.error("Please select a current or future date");
      return;
    }

    setLoading(true);
    try {
      const requestBody: { 
        appointmentTypeId: string; 
        requestedDate: string; 
        providerIds?: string[]; 
        operatoryIds?: string[] 
      } = {
        appointmentTypeId: selectedAppointmentTypeId,
        requestedDate: selectedDate
      };

      // Only include provider/operatory filters if specifically selected
      if (selectedProviderIds.length > 0) {
        requestBody.providerIds = selectedProviderIds;
      }
      if (selectedOperatoryIds.length > 0) {
        requestBody.operatoryIds = selectedOperatoryIds;
      }

      const response = await fetch('/api/practice-config/check-slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to check appointment slots');
      }

      const result: CheckSlotsResponse = await response.json();
      setSlotsData(result.data);

      if (result.data.has_availability) {
        toast.success(`Found ${result.data.total_slots_found} available slot(s)!`);
      } else {
        toast.info("No available slots found for the selected date and appointment type");
      }

    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to check appointment slots');
      console.error(error);
      setSlotsData(null);
    } finally {
      setLoading(false);
    }
  };

  const formatDate = (dateString: string): string => {
    try {
      const date = new Date(dateString + 'T00:00:00');
      return date.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    } catch {
      return dateString;
    }
  };

  const getProviderName = (provider: Provider) => {
    return `${provider.firstName || ''} ${provider.lastName}`.trim() || 'Unnamed Provider';
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="mb-6">
        <h2 className="text-xl font-semibold mb-2">Check Appointment Slots</h2>
        <p className="text-gray-600">
          Check availability for specific appointment types and dates. Optional filters for providers and operatories.
        </p>
      </div>

      {/* Form */}
      <form onSubmit={(e) => { e.preventDefault(); handleCheckSlots(); }} className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Appointment Type Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Appointment Type *
            </label>
            <select
              value={selectedAppointmentTypeId}
              onChange={(e) => setSelectedAppointmentTypeId(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            >
              <option value="">Select appointment type</option>
              {appointmentTypes.map((type) => (
                <option key={type.id} value={type.id}>
                  {type.name} ({type.duration} min)
                </option>
              ))}
            </select>
          </div>

          {/* Date Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Date *
            </label>
            <input
              type="date"
              value={selectedDate}
              onChange={(e) => setSelectedDate(e.target.value)}
              min={today}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
        </div>

        {/* Optional Filters */}
        <div className="border-t pt-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">Optional Filters</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Provider Filter */}
            <div>
              <h4 className="font-medium text-gray-700 mb-3">Filter by Providers</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {activeProviders.map((savedProvider) => (
                  <label key={savedProvider.id} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={selectedProviderIds.includes(savedProvider.id)}
                      onChange={(e) => handleProviderChange(savedProvider.id, e.target.checked)}
                      className="mr-2"
                    />
                    <span className="text-sm text-gray-700">
                      {getProviderName(savedProvider.provider)}
                    </span>
                  </label>
                ))}
              </div>
              {activeProviders.length === 0 && (
                <p className="text-sm text-gray-500">No active providers available</p>
              )}
            </div>

            {/* Operatory Filter */}
            <div>
              <h4 className="font-medium text-gray-700 mb-3">Filter by Operatories</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {activeOperatories.map((operatory) => (
                  <label key={operatory.id} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={selectedOperatoryIds.includes(operatory.id)}
                      onChange={(e) => handleOperatoryChange(operatory.id, e.target.checked)}
                      className="mr-2"
                    />
                    <span className="text-sm text-gray-700">
                      {operatory.name}
                    </span>
                  </label>
                ))}
              </div>
              {activeOperatories.length === 0 && (
                <p className="text-sm text-gray-500">No active operatories available</p>
              )}
            </div>
          </div>
        </div>

        {/* Submit Button */}
        <div className="flex justify-center pt-4">
          <button
            type="submit"
            disabled={loading}
            className="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {loading ? 'Checking...' : 'Check Available Slots'}
          </button>
        </div>
      </form>

      {/* Results */}
      {slotsData && (
        <div className="mt-8 border-t pt-6">
          <h3 className="text-lg font-semibold mb-4">
            Results for {formatDate(slotsData.requested_date)} - {slotsData.appointment_type.name}
          </h3>

          {slotsData.has_availability ? (
            <div className="space-y-4">
              <p className="text-green-600 font-medium">
                Found {slotsData.total_slots_found} available slot(s)
              </p>

              {/* Slots List */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {slotsData.available_slots.map((slot) => (
                  <div key={slot.slot_id} className="border border-gray-200 rounded-lg p-4">
                    <div className="font-medium text-blue-600">{slot.display_range}</div>
                    <div className="text-sm text-gray-600 mt-1">
                      Provider: {slot.provider_info.name}
                    </div>
                    {slot.operatory_info && (
                      <div className="text-sm text-gray-600">
                        Operatory: {slot.operatory_info.name}
                      </div>
                    )}
                  </div>
                ))}
              </div>

              {/* Debug Info */}
              <div className="bg-gray-50 rounded-lg p-4 mt-6">
                <h4 className="font-medium text-gray-900 mb-2">Search Summary</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <p>Providers checked: {slotsData.debug_info.providers_checked}</p>
                  <p>Operatories checked: {slotsData.debug_info.operatories_checked}</p>
                </div>
              </div>
            </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-500 mb-4">No available slots found</p>
              <div className="bg-gray-50 rounded-lg p-4">
                <h4 className="font-medium text-gray-900 mb-2">Search Summary</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <p>Providers checked: {slotsData.debug_info.providers_checked}</p>
                  <p>Operatories checked: {slotsData.debug_info.operatories_checked}</p>
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: app/practice-config/ProvidersConfig.tsx
================
"use client";

import { useState } from "react";
import { toast } from "sonner";

interface Provider {
  id: string;
  nexhealthProviderId: string;
  firstName: string | null;
  lastName: string;
}

interface SavedProvider {
  id: string;
  providerId: string;
  isActive: boolean;
  provider: Provider;
}

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  bookableOnline: boolean | null;
  groupCode: string | null;
}

interface SavedOperatory {
  id: string;
  nexhealthOperatoryId: string;
  name: string;
  isActive: boolean;
}

interface ProviderSettings {
  acceptedAppointmentTypeIds: string[];
  defaultAppointmentTypeId: string | null;
  defaultOperatoryId: string | null;
}

interface ProvidersConfigProps {
  savedProviders: SavedProvider[];
  allAppointmentTypes: AppointmentType[];
  allOperatories: SavedOperatory[];
  onUpdate: () => void;
}

export function ProvidersConfig({
  savedProviders,
  allAppointmentTypes,
  allOperatories,
  onUpdate
}: ProvidersConfigProps) {
  const [expandedProvider, setExpandedProvider] = useState<string | null>(null);
  const [providerSettings, setProviderSettings] = useState<{ [key: string]: ProviderSettings }>({});
  const [loading, setLoading] = useState<{ [key: string]: boolean }>({});
  const [fetchingSettings, setFetchingSettings] = useState<{ [key: string]: boolean }>({});

  const activeProviders = savedProviders.filter(sp => sp.isActive);

  const fetchProviderSettings = async (savedProviderId: string) => {
    setFetchingSettings(prev => ({ ...prev, [savedProviderId]: true }));
    try {
      const response = await fetch(`/api/practice-config/provider-settings/${savedProviderId}`);
      if (response.ok) {
        const settings = await response.json();
        setProviderSettings(prev => ({
          ...prev,
          [savedProviderId]: {
            acceptedAppointmentTypeIds: settings.acceptedAppointmentTypes?.map((at: { appointmentTypeId: string }) => at.appointmentTypeId) || [],
            defaultAppointmentTypeId: settings.defaultAppointmentTypeId,
            defaultOperatoryId: settings.defaultOperatoryId
          }
        }));
      } else {
        // Initialize with empty settings if none exist
        setProviderSettings(prev => ({
          ...prev,
          [savedProviderId]: {
            acceptedAppointmentTypeIds: [],
            defaultAppointmentTypeId: null,
            defaultOperatoryId: null
          }
        }));
      }
    } catch (error) {
      console.error('Error fetching provider settings:', error);
      toast.error('Failed to fetch provider settings');
    } finally {
      setFetchingSettings(prev => ({ ...prev, [savedProviderId]: false }));
    }
  };

  const handleProviderExpand = async (savedProviderId: string) => {
    if (expandedProvider === savedProviderId) {
      setExpandedProvider(null);
    } else {
      setExpandedProvider(savedProviderId);
      if (!providerSettings[savedProviderId]) {
        await fetchProviderSettings(savedProviderId);
      }
    }
  };

  const updateProviderSetting = (savedProviderId: string, field: keyof ProviderSettings, value: string | string[] | null) => {
    setProviderSettings(prev => ({
      ...prev,
      [savedProviderId]: {
        ...prev[savedProviderId],
        [field]: value
      }
    }));
  };

  const handleAcceptedTypesChange = (savedProviderId: string, appointmentTypeId: string, checked: boolean) => {
    const currentSettings = providerSettings[savedProviderId];
    let newAcceptedTypes: string[];
    
    if (checked) {
      newAcceptedTypes = [...(currentSettings?.acceptedAppointmentTypeIds || []), appointmentTypeId];
    } else {
      newAcceptedTypes = (currentSettings?.acceptedAppointmentTypeIds || []).filter(id => id !== appointmentTypeId);
      // If we're removing the default appointment type, clear it
      if (currentSettings?.defaultAppointmentTypeId === appointmentTypeId) {
        updateProviderSetting(savedProviderId, 'defaultAppointmentTypeId', null);
      }
    }
    
    updateProviderSetting(savedProviderId, 'acceptedAppointmentTypeIds', newAcceptedTypes);
  };

  const saveProviderSettings = async (savedProviderId: string) => {
    const settings = providerSettings[savedProviderId];
    if (!settings) return;

    setLoading(prev => ({ ...prev, [savedProviderId]: true }));
    try {
      const response = await fetch(`/api/practice-config/provider-settings/${savedProviderId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          acceptedAppointmentTypeIds: settings.acceptedAppointmentTypeIds,
          defaultAppointmentTypeId: settings.defaultAppointmentTypeId,
          defaultOperatoryId: settings.defaultOperatoryId
        })
      });

      if (response.ok) {
        toast.success('Provider settings saved successfully!');
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Failed to save: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error saving provider settings:', error);
      toast.error('Failed to save provider settings');
    } finally {
      setLoading(prev => ({ ...prev, [savedProviderId]: false }));
    }
  };

  const getProviderName = (provider: Provider) => {
    return `${provider.firstName || ''} ${provider.lastName}`.trim() || 'Unnamed Provider';
  };

  const getAcceptedAppointmentTypes = (savedProviderId: string) => {
    const settings = providerSettings[savedProviderId];
    if (!settings) return [];
    return allAppointmentTypes.filter(at => settings.acceptedAppointmentTypeIds.includes(at.id));
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-xl font-semibold mb-6">Providers Configuration</h2>
      
      {activeProviders.length === 0 ? (
        <div className="text-center py-8 text-gray-500">
          No active providers found. Please sync with NexHealth and activate providers first.
        </div>
      ) : (
        <div className="space-y-4">
          {activeProviders.map((savedProvider) => (
            <div key={savedProvider.id} className="border border-gray-200 rounded-lg">
              <div
                className="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50"
                onClick={() => handleProviderExpand(savedProvider.id)}
              >
                <div>
                  <h3 className="font-medium text-gray-900">
                    {getProviderName(savedProvider.provider)}
                  </h3>
                  <p className="text-sm text-gray-500">
                    Provider ID: {savedProvider.provider.nexhealthProviderId}
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-sm text-gray-500">
                    {expandedProvider === savedProvider.id ? 'Collapse' : 'Configure'}
                  </span>
                  <svg
                    className={`w-5 h-5 text-gray-500 transition-transform ${
                      expandedProvider === savedProvider.id ? 'rotate-180' : ''
                    }`}
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </div>
              </div>

              {expandedProvider === savedProvider.id && (
                <div className="border-t border-gray-200 p-4">
                  {fetchingSettings[savedProvider.id] ? (
                    <div className="text-center py-4 text-gray-500">Loading settings...</div>
                  ) : (
                    <div className="space-y-6">
                      {/* Accepted Appointment Types */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Accepted Appointment Types</h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                          {allAppointmentTypes.map((appointmentType) => (
                            <label key={appointmentType.id} className="flex items-center">
                              <input
                                type="checkbox"
                                checked={providerSettings[savedProvider.id]?.acceptedAppointmentTypeIds.includes(appointmentType.id) || false}
                                onChange={(e) => handleAcceptedTypesChange(savedProvider.id, appointmentType.id, e.target.checked)}
                                className="mr-2"
                              />
                              <span className="text-sm text-gray-700">
                                {appointmentType.name} ({appointmentType.duration} min)
                              </span>
                            </label>
                          ))}
                        </div>
                      </div>

                      {/* Default Appointment Type */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Default Appointment Type</h4>
                        <select
                          value={providerSettings[savedProvider.id]?.defaultAppointmentTypeId || ''}
                          onChange={(e) => updateProviderSetting(savedProvider.id, 'defaultAppointmentTypeId', e.target.value || null)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          <option value="">Select default appointment type</option>
                          {getAcceptedAppointmentTypes(savedProvider.id).map((appointmentType) => (
                            <option key={appointmentType.id} value={appointmentType.id}>
                              {appointmentType.name} ({appointmentType.duration} min)
                            </option>
                          ))}
                        </select>
                      </div>

                      {/* Default Operatory */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Default Operatory</h4>
                        <select
                          value={providerSettings[savedProvider.id]?.defaultOperatoryId || ''}
                          onChange={(e) => updateProviderSetting(savedProvider.id, 'defaultOperatoryId', e.target.value || null)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          <option value="">Select default operatory</option>
                          {allOperatories.filter(op => op.isActive).map((operatory) => (
                            <option key={operatory.id} value={operatory.id}>
                              {operatory.name}
                            </option>
                          ))}
                        </select>
                      </div>

                      {/* Save Button */}
                      <div className="flex justify-end pt-4">
                        <button
                          onClick={() => saveProviderSettings(savedProvider.id)}
                          disabled={loading[savedProvider.id]}
                          className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                          {loading[savedProvider.id] ? 'Saving...' : 'Save Settings'}
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

================
File: app/practice-config/QuickReview.tsx
================
"use client";

import { useState, useEffect } from "react";

interface QuickReviewData {
  appointmentsBookedByLaine: number;
  activeProvidersCount: number;
  appointmentTypesCount: number;
}

export function QuickReview() {
  const [data, setData] = useState<QuickReviewData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchQuickReviewData();
  }, []);

  const fetchQuickReviewData = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('/api/practice-config/quick-review');
      
      if (response.ok) {
        const result = await response.json();
        setData(result);
      } else {
        const errorData = await response.json();
        setError(errorData.error || 'Failed to fetch quick review data');
      }
    } catch (err) {
      setError('Failed to fetch quick review data');
      console.error('Error fetching quick review data:', err);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Quick Review</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {[1, 2, 3].map((i) => (
            <div key={i} className="text-center">
              <div className="h-8 bg-gray-200 rounded animate-pulse mb-2"></div>
              <div className="h-4 bg-gray-100 rounded animate-pulse"></div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Quick Review</h2>
        <div className="bg-red-50 border border-red-200 rounded-md p-4">
          <p className="text-red-800 text-sm">{error}</p>
          <button
            onClick={fetchQuickReviewData}
            className="mt-2 text-red-600 hover:text-red-700 text-sm underline"
          >
            Try again
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-xl font-semibold mb-6">Quick Review</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="text-center p-4 bg-blue-50 rounded-lg">
          <div className="text-3xl font-bold text-blue-600 mb-2">
            {data?.appointmentsBookedByLaine || 0}
          </div>
          <div className="text-sm text-blue-800 font-medium">
            Appointments Booked via Laine
          </div>
          <div className="text-xs text-blue-600 mt-1">
            Total appointments scheduled through Laine AI
          </div>
        </div>

        <div className="text-center p-4 bg-green-50 rounded-lg">
          <div className="text-3xl font-bold text-green-600 mb-2">
            {data?.activeProvidersCount || 0}
          </div>
          <div className="text-sm text-green-800 font-medium">
            Active Providers
          </div>
          <div className="text-xs text-green-600 mt-1">
            Providers available for scheduling
          </div>
        </div>

        <div className="text-center p-4 bg-purple-50 rounded-lg">
          <div className="text-3xl font-bold text-purple-600 mb-2">
            {data?.appointmentTypesCount || 0}
          </div>
          <div className="text-sm text-purple-800 font-medium">
            Appointment Types Created
          </div>
          <div className="text-xs text-purple-600 mt-1">
            Total appointment types configured
          </div>
        </div>
      </div>
      
      <div className="mt-4 flex justify-end">
        <button
          onClick={fetchQuickReviewData}
          disabled={loading}
          className="text-blue-600 hover:text-blue-700 disabled:opacity-50 text-sm"
        >
          {loading ? 'Refreshing...' : 'Refresh'}
        </button>
      </div>
    </div>
  );
}

================
File: app/api/laine-config/update/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { updateVapiAssistant } from "@/lib/vapi";
import { buildVapiTools } from "@/lib/tools";

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    const body = await request.json();
    const { voiceProvider, voiceId, systemPrompt, firstMessage } = body;

    if (!voiceProvider || !voiceId || !systemPrompt || !firstMessage) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    // Get the practice with assistant config
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: { assistantConfig: true }
    });

    if (!practice || !practice.assistantConfig?.vapiAssistantId) {
      return NextResponse.json({ error: "Practice or assistant not found" }, { status: 404 });
    }

    const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    const tools = buildVapiTools(appBaseUrl);
    
    // Update VAPI assistant with new configuration
    const updateConfig = {
      model: {
        provider: "openai" as const,
        model: "gpt-4.1-nano-2025-04-14",
        temperature: 0.7,
        messages: [
          {
            role: "system" as const,
            content: systemPrompt
          }
        ],
        tools
      },
      voice: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        provider: voiceProvider as any,
        voiceId: voiceId
      },
      firstMessage: firstMessage
    };

    console.log("Updating VAPI assistant:", practice.assistantConfig.vapiAssistantId);
    await updateVapiAssistant(practice.assistantConfig.vapiAssistantId, updateConfig);
    
    // Update our database
    await prisma.practiceAssistantConfig.update({
      where: { practiceId: practice.id },
      data: {
        voiceProvider,
        voiceId,
        systemPrompt,
        firstMessage,
        updatedAt: new Date()
      }
    });

    console.log(`Successfully updated VAPI assistant for practice ${practice.id}`);
    
    return NextResponse.json({ success: true, message: "Assistant configuration updated successfully" });
  } catch (error) {
    console.error("Error updating VAPI assistant:", error);
    return NextResponse.json(
      { error: `Failed to update assistant: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/appointment-types/[appointmentTypeId]/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { 
  updateNexhealthAppointmentType, 
  deleteNexhealthAppointmentType 
} from "@/lib/nexhealth";
import { z } from "zod";

interface RouteParams {
  appointmentTypeId: string;
}

const updateAppointmentTypeSchema = z.object({
  name: z.string().min(1, "Name must be a non-empty string").optional(),
  minutes: z.number().positive("Minutes must be a positive number").optional(),
  bookableOnline: z.boolean().optional(),
  groupCode: z.string().nullable().optional()
});

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { appointmentTypeId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to update appointment types"
      }, { status: 400 });
    }

    // Fetch the local appointment type record to get the NexHealth ID
    const localAppointmentType = await prisma.appointmentType.findFirst({
      where: {
        id: appointmentTypeId,
        practiceId: practice.id
      }
    });

    if (!localAppointmentType) {
      return NextResponse.json({
        error: "Appointment type not found"
      }, { status: 404 });
    }

    const body = await req.json();

    // Validate input using Zod
    const validationResult = updateAppointmentTypeSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { name, minutes, bookableOnline, groupCode } = validationResult.data;

    // Build update data object with only provided fields for NexHealth
    const nexhealthUpdateData: {
      name?: string;
      minutes?: number;
      bookable_online?: boolean;
    } = {};

    if (name !== undefined) {
      nexhealthUpdateData.name = name.trim();
    }

    if (minutes !== undefined) {
      nexhealthUpdateData.minutes = minutes;
    }

    if (bookableOnline !== undefined) {
      nexhealthUpdateData.bookable_online = bookableOnline;
    }

    try {
      // Build local update data (includes groupCode which is Laine-specific)
      const localUpdateData: {
        name?: string;
        duration?: number;
        bookableOnline?: boolean;
        groupCode?: string | null;
        parentType?: string;
        parentId?: string;
        lastSyncError?: null;
      } = {};

      // Update appointment type in NexHealth (only if there are NexHealth-relevant fields)
      if (Object.keys(nexhealthUpdateData).length > 0) {
        const nexhealthResponse = await updateNexhealthAppointmentType(
          practice.nexhealthSubdomain,
          localAppointmentType.nexhealthAppointmentTypeId,
          practice.nexhealthLocationId,
          nexhealthUpdateData
        );

        // Update local data with NexHealth response
        if (nexhealthResponse.name !== localAppointmentType.name) {
          localUpdateData.name = nexhealthResponse.name;
        }
        if (nexhealthResponse.minutes !== localAppointmentType.duration) {
          localUpdateData.duration = nexhealthResponse.minutes;
        }
        if (nexhealthResponse.bookable_online !== localAppointmentType.bookableOnline) {
          localUpdateData.bookableOnline = nexhealthResponse.bookable_online;
        }
        if (nexhealthResponse.parent_type !== localAppointmentType.parentType) {
          localUpdateData.parentType = nexhealthResponse.parent_type;
        }
        if (nexhealthResponse.parent_id.toString() !== localAppointmentType.parentId) {
          localUpdateData.parentId = nexhealthResponse.parent_id.toString();
        }
      }

      // Add groupCode update if provided (Laine-specific field)
      if (groupCode !== undefined) {
        localUpdateData.groupCode = groupCode;
      }

      // Clear any previous sync errors if we made changes
      if (Object.keys(localUpdateData).length > 0) {
        localUpdateData.lastSyncError = null;
      }

      // Update appointment type in local database
      const updatedLocalAppointmentType = await prisma.appointmentType.update({
        where: { id: appointmentTypeId },
        data: localUpdateData
      });

      return NextResponse.json({
        success: true,
        appointmentType: updatedLocalAppointmentType
      });

    } catch (nexhealthError) {
      console.error("Error updating appointment type in NexHealth:", nexhealthError);
      
      // If only groupCode was being updated and NexHealth call failed, still update locally
      if (Object.keys(nexhealthUpdateData).length === 0 && groupCode !== undefined) {
        const updatedLocalAppointmentType = await prisma.appointmentType.update({
          where: { id: appointmentTypeId },
          data: { groupCode }
        });

        return NextResponse.json({
          success: true,
          appointmentType: updatedLocalAppointmentType
        });
      }

      // Update local record with error for NexHealth-related fields
      await prisma.appointmentType.update({
        where: { id: appointmentTypeId },
        data: {
          lastSyncError: nexhealthError instanceof Error ? nexhealthError.message : 'Unknown NexHealth error'
        }
      });

      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to update appointment type in NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error updating appointment type:", error);
    return NextResponse.json(
      { error: "Failed to update appointment type" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { appointmentTypeId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to delete appointment types"
      }, { status: 400 });
    }

    // Fetch the local appointment type record to get the NexHealth ID
    const localAppointmentType = await prisma.appointmentType.findFirst({
      where: {
        id: appointmentTypeId,
        practiceId: practice.id
      }
    });

    if (!localAppointmentType) {
      return NextResponse.json({
        error: "Appointment type not found"
      }, { status: 404 });
    }

    try {
      // Delete appointment type from NexHealth
      await deleteNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        localAppointmentType.nexhealthAppointmentTypeId,
        practice.nexhealthLocationId
      );

      // Delete appointment type from local database
      await prisma.appointmentType.delete({
        where: { id: appointmentTypeId }
      });

      return NextResponse.json({
        success: true,
        message: "Appointment type deleted successfully"
      });

    } catch (nexhealthError) {
      console.error("Error deleting appointment type from NexHealth:", nexhealthError);
      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to delete appointment type from NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error deleting appointment type:", error);
    return NextResponse.json(
      { error: "Failed to delete appointment type" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/appointment-types/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { createNexhealthAppointmentType } from "@/lib/nexhealth";
import { z } from "zod";

const createAppointmentTypeSchema = z.object({
  name: z.string().min(1, "Name is required and must be a non-empty string"),
  minutes: z.number().positive("Minutes must be a positive number"),
  bookableOnline: z.boolean().optional().default(true),
  groupCode: z.string().nullable().optional()
});

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: {
          orderBy: { name: 'asc' }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Simply return existing appointment types without automatic sync
    return NextResponse.json({
      success: true,
      appointmentTypes: practice.appointmentTypes
    });

  } catch (error) {
    console.error("Error fetching appointment types:", error);
    return NextResponse.json(
      { error: "Failed to fetch appointment types" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to create appointment types"
      }, { status: 400 });
    }

    const body = await req.json();

    // Validate input using Zod
    const validationResult = createAppointmentTypeSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { name, minutes, bookableOnline, groupCode } = validationResult.data;

    try {
      // Create appointment type in NexHealth (groupCode is Laine-specific, not sent to NexHealth)
      const nexhealthResponse = await createNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        practice.nexhealthLocationId,
        {
          name: name.trim(),
          minutes,
          bookable_online: bookableOnline,
          parent_type: "Location",
          parent_id: practice.nexhealthLocationId
        }
      );

      // Create appointment type in local database with groupCode
      const localAppointmentType = await prisma.appointmentType.create({
        data: {
          practiceId: practice.id,
          nexhealthAppointmentTypeId: nexhealthResponse.id.toString(),
          name: nexhealthResponse.name,
          duration: nexhealthResponse.minutes,
          bookableOnline: nexhealthResponse.bookable_online,
          groupCode, // Store the Laine-specific group code
          parentType: nexhealthResponse.parent_type,
          parentId: nexhealthResponse.parent_id.toString()
        }
      });

      return NextResponse.json({
        success: true,
        appointmentType: localAppointmentType
      });

    } catch (nexhealthError) {
      console.error("Error creating appointment type in NexHealth:", nexhealthError);
      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to create appointment type in NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error creating appointment type:", error);
    return NextResponse.json(
      { error: "Failed to create appointment type" },
      { status: 500 }
    );
  }
}

================
File: lib/prisma.ts
================
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

================
File: app/api/practice-config/data/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({ 
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: true,
        providers: true,
        savedProviders: {
          include: {
            provider: true
          },
          where: { isActive: true }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });

    // Check if global webhook endpoint is configured
    const globalWebhookEndpoint = await prisma.globalNexhealthWebhookEndpoint.findUnique({
      where: { id: "singleton" }
    });

    return NextResponse.json({
      practice,
      globalWebhookEndpoint
    });

  } catch (error) {
    console.error("Error fetching practice data:", error);
    return NextResponse.json(
      { error: "Failed to fetch practice data" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/webhook-sync/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { subscribePracticeToWebhooks } from "@/lib/webhook-utils";

export async function POST(req: NextRequest) {
  console.log("=== Webhook Sync API ===");
  
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { subdomain } = await req.json();
    
    if (!subdomain) {
      return NextResponse.json({ error: "Subdomain is required" }, { status: 400 });
    }

    // Verify the practice belongs to this user
    const practice = await prisma.practice.findFirst({
      where: {
        clerkUserId: userId,
        nexhealthSubdomain: subdomain
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    console.log(`[WebhookSync] Syncing webhooks for practice: ${practice.id} (${subdomain})`);

    // Subscribe to webhooks using the new utility
    const result = await subscribePracticeToWebhooks(subdomain);

    // Update the webhook sync timestamp in the database
    await prisma.practice.update({
      where: { id: practice.id },
      data: {
        webhookLastSyncAt: new Date()
      }
    });

    // Fetch updated webhook subscriptions
    const updatedPractice = await prisma.practice.findUnique({
      where: { id: practice.id },
      include: {
        nexhealthWebhookSubscriptions: true
      }
    });

    return NextResponse.json({
      success: result.success,
      message: result.message,
      details: {
        successCount: result.successCount,
        skipCount: result.skipCount,
        failCount: result.failCount
      },
      webhookSubscriptions: updatedPractice?.nexhealthWebhookSubscriptions || [],
      lastSyncTime: new Date().toISOString()
    });

  } catch (error) {
    console.error("Error in webhook sync API:", error);
    return NextResponse.json({
      success: false,
      message: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 });
  }
}

================
File: middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isProtectedRoute = createRouteMatcher([
  '/practice-config(.*)',
  '/laine(.*)',
  '/test(.*)',
]);

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) {
    await auth.protect();
  }
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};

================
File: app/api/nexhealth-webhook/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import crypto from "crypto";
import { prisma } from "@/lib/prisma";

async function getRawBody(req: NextRequest): Promise<Buffer> {
  const reader = req.body?.getReader();
  if (!reader) return Buffer.from('');
  const chunks: Uint8Array[] = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (value) chunks.push(value);
  }
  return Buffer.concat(chunks);
}

export async function POST(req: NextRequest) {
  console.log("=== NexHealth Webhook Handler ===");
  
  try {
    const rawBody = await getRawBody(req);
    console.log("Raw body length:", rawBody.length);
    
    if (rawBody.length === 0) {
      console.error("Empty request body received");
      return NextResponse.json({ error: "Empty request body" }, { status: 400 });
    }
    
    const signature = req.headers.get("x-nexhealth-signature");
    console.log("Signature present:", !!signature);
    
    // Enhanced signature verification with better error messages
    const globalWebhookConfig = await prisma.globalNexhealthWebhookEndpoint.findUnique({
      where: { id: "singleton" }
    });
    
    if (!globalWebhookConfig?.secretKey) {
      console.error("CRITICAL: Webhook secret not found in database");
      return NextResponse.json({ error: "Webhook not configured" }, { status: 500 });
    }
    
    if (!signature) {
      console.error("Missing webhook signature - potential unauthorized request");
      return NextResponse.json({ error: "Missing signature" }, { status: 401 });
    }
    
    // Verify signature with enhanced security logging
    const expectedSignature = crypto
      .createHmac("sha256", globalWebhookConfig.secretKey)
      .update(rawBody)
      .digest("hex");
    
    // Use timing-safe comparison to prevent timing attacks
    const signatureMatches = crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'), 
      Buffer.from(expectedSignature, 'hex')
    );
    
    if (!signatureMatches) {
      console.error("Signature verification failed");
      // Log truncated signatures for debugging without exposing full secrets
      console.error("Expected signature (first 8 chars):", expectedSignature.substring(0, 8));
      console.error("Received signature (first 8 chars):", signature.substring(0, 8));
      console.error("Request body hash (for debugging):", crypto.createHash('sha256').update(rawBody).digest('hex').substring(0, 16));
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }
    
    console.log(" Signature verification successful");
    
    // Parse and validate JSON
    let event;
    try {
      event = JSON.parse(rawBody.toString());
    } catch (parseError) {
      console.error("JSON parsing failed:", parseError);
      return NextResponse.json({ error: "Invalid JSON payload" }, { status: 400 });
    }
    
    console.log("Webhook event received:", {
      resource_type: event.resource_type,
      event_name: event.event_name,
      subdomain: event.subdomain,
      institution_id: event.institution_id,
      timestamp: new Date().toISOString()
    });
    
    const { resource_type, event_name, subdomain, institution_id, data } = event;

    // Validate required event fields
    if (!resource_type || !event_name || !subdomain) {
      console.error("Missing required event fields:", { resource_type, event_name, subdomain });
      return NextResponse.json({ error: "Invalid event structure" }, { status: 400 });
    }

    // Find the practice associated with this subdomain/institution_id
    const practice = await prisma.practice.findFirst({
      where: { nexhealthSubdomain: subdomain },
    });

    if (!practice) {
      console.warn(`NexHealth Webhook: Received event for unknown subdomain/institution: ${subdomain}/${institution_id}`);
      // Still return 200 to NexHealth to acknowledge receipt and prevent retries for unknown practices.
      return NextResponse.json({ message: "Event received but practice not found" }, { status: 200 });
    }

    console.log(`Processing event for practice: ${practice.id} (${practice.name || 'Unnamed'})`);

    // --- Handle specific events with enhanced logging ---
    
    if (resource_type === "Patient") {
      if (event_name === "patient_created") {
        console.log(` Practice ${practice.id} - Patient created in NexHealth. Patient ID: ${data?.patients?.[0]?.id}`);
        // TODO: Upsert patient data into local Patient table
      } else if (event_name === "patient_updated") {
        console.log(` Practice ${practice.id} - Patient updated in NexHealth. Patient ID: ${data?.patients?.[0]?.id}`);
        // TODO: Update local patient data
      } else {
        console.log(` Practice ${practice.id} - Unhandled Patient event: ${event_name}`);
      }
    } else if (resource_type === "Appointment") {
      if (event_name === "appointment_created") {
        console.log(` Practice ${practice.id} - Appointment created in EHR. Appointment ID: ${data?.appointment?.id}`);
        // TODO: Sync new appointment to local database
      } else if (event_name === "appointment_updated") {
        console.log(` Practice ${practice.id} - Appointment updated in EHR. Appointment ID: ${data?.appointment?.id}`);
        // TODO: Update local appointment data
      } else if (event_name === "appointment_insertion.complete") {
        console.log(` Practice ${practice.id} - Appointment insertion complete (Laine booking succeeded). Appointment ID: ${data?.appointment?.id}`);
        // TODO: Mark appointment as confirmed in local DB
      } else if (event_name === "appointment_insertion.failed") {
        console.error(` Practice ${practice.id} - Appointment insertion failed (Laine booking failed). Error: ${data?.error}`);
        // TODO: Handle booking failure, notify practice or retry
      } else {
        console.log(` Practice ${practice.id} - Unhandled Appointment event: ${event_name}`);
      }
    } else if (resource_type === "SyncStatus") {
      if (event_name === "sync_status_read_change") {
        console.log(` Practice ${practice.id} - EHR read functionality status change. Status: ${data?.read_status}`);
        // TODO: Update system monitoring, resume read operations if needed
      } else if (event_name === "sync_status_write_change") {
        console.log(` Practice ${practice.id} - EHR write functionality status change. Status: ${data?.write_status}`);
        // TODO: Update system monitoring, resume write operations if needed
      } else {
        console.log(` Practice ${practice.id} - Unhandled SyncStatus event: ${event_name}`);
      }
    } else {
      console.log(` Practice ${practice.id} - Received unhandled event: ${resource_type}.${event_name}`);
    }

    // Update webhook last sync timestamp
    await prisma.practice.update({
      where: { id: practice.id },
      data: { webhookLastSyncAt: new Date() }
    });

    return NextResponse.json({ success: true, message: "Event processed successfully" });
    
  } catch (error) {
    console.error(" Webhook processing error:", error);
    console.error("Error stack:", error instanceof Error ? error.stack : 'No stack trace');
    
    return NextResponse.json({ 
      error: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error",
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

================
File: app/api/sync-nexhealth/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getAppointmentTypes, getProviders, getOperatories } from "@/lib/nexhealth";

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number;
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

export async function POST() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get the practice for this user
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json(
        { error: "NexHealth configuration missing. Please configure your subdomain and location ID first." },
        { status: 400 }
      );
    }

    // Fetch data from NexHealth (including operatories)
    const [appointmentTypes, providers, operatories] = await Promise.all([
      getAppointmentTypes(practice.nexhealthSubdomain, practice.nexhealthLocationId),
      getProviders(practice.nexhealthSubdomain, practice.nexhealthLocationId),
      getOperatories(practice.nexhealthSubdomain, practice.nexhealthLocationId),
    ]);

    // Sync appointment types - use 'minutes' from NexHealth API
    const appointmentTypePromises = appointmentTypes.map((type: NexHealthAppointmentType) =>
      prisma.appointmentType.upsert({
        where: {
          practiceId_nexhealthAppointmentTypeId: {
            practiceId: practice.id,
            nexhealthAppointmentTypeId: type.id.toString(),
          },
        },
        update: {
          name: type.name,
          duration: type.minutes || 0, // Use 'minutes' from NexHealth API
        },
        create: {
          practiceId: practice.id,
          nexhealthAppointmentTypeId: type.id.toString(),
          name: type.name,
          duration: type.minutes || 0, // Use 'minutes' from NexHealth API
        },
      })
    );

    // Sync providers
    const providerPromises = providers.map((provider: NexHealthProvider) =>
      prisma.provider.upsert({
        where: {
          practiceId_nexhealthProviderId: {
            practiceId: practice.id,
            nexhealthProviderId: provider.id.toString(),
          },
        },
        update: {
          firstName: provider.first_name || null,
          lastName: provider.last_name || provider.name || "Unknown",
        },
        create: {
          practiceId: practice.id,
          nexhealthProviderId: provider.id.toString(),
          firstName: provider.first_name || null,
          lastName: provider.last_name || provider.name || "Unknown",
        },
      })
    );

    // Execute all upserts
    await Promise.all([...appointmentTypePromises, ...providerPromises]);

    return NextResponse.json({
      success: true,
      message: `Successfully synced ${appointmentTypes.length} appointment types, ${providers.length} providers, and found ${operatories.length} operatories.`,
      data: {
        appointmentTypesCount: appointmentTypes.length,
        providersCount: providers.length,
        operatoriesCount: operatories.length,
      },
    });
  } catch (error) {
    console.error("Error syncing NexHealth data:", error);
    return NextResponse.json(
      { error: "Failed to sync NexHealth data. Please check your configuration and try again." },
      { status: 500 }
    );
  }
}

================
File: lib/tools/types.ts
================
// lib/tools/types.ts
import { z } from "zod";
import { Practice, AppointmentType, SavedProvider, SavedOperatory } from "@prisma/client";

// Enhanced practice context with scheduling data
export interface PracticeWithSchedulingData extends Practice {
  appointmentTypes: AppointmentType[];
  savedProviders: (SavedProvider & { 
    provider: { 
      id: string; 
      firstName: string | null; 
      lastName: string; 
      nexhealthProviderId: string; 
    };
    acceptedAppointmentTypes?: Array<{
      appointmentType: AppointmentType;
    }>;
    defaultOperatoryId?: string | null;
  })[];
  savedOperatories: SavedOperatory[];
}

// Tool execution context
export interface ToolExecutionContext {
  practice: PracticeWithSchedulingData;
  vapiCallId: string;
  toolCallId: string;
  assistantId: string;
  callSummaryForNote?: string; // ADD THIS LINE for bookAppointment tool
}

// Standardized tool result format
export interface ToolResult {
  success: boolean;
  message_to_patient: string;
  data?: Record<string, unknown>;
  error_code?: string;
  details?: string;
}

// VAPI tool definition interface
export interface VapiToolFunction {
  name: string;
  description: string;
  parameters: Record<string, unknown>; // JSON schema object
}

export interface VapiToolSchema {
  type: "function";
  async?: boolean;
  function: VapiToolFunction;
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

// Internal tool definition
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface ToolDefinition<T extends z.ZodType<any, any>> {
  name: string;
  description: string;
  schema: T;
  run: (params: { 
    args: z.infer<T>; 
    context: ToolExecutionContext 
  }) => Promise<ToolResult>;
  messages?: {
    start?: string;
    delay?: string;
    success?: string;
    fail?: string;
  };
  async?: boolean;
}

// VAPI webhook payload types
export interface VapiToolCall {
  toolCallId: string;
  name: string;
  arguments: string; // JSON string
}

export interface VapiToolCallsMessage {
  type: "tool-calls";
  timestamp: number;
  call: {
    id: string;
    assistantId: string;
    orgId?: string;
  };
  assistant: {
    id: string;
  };
  toolCallList: VapiToolCall[];
}

export interface VapiServerMessage {
  message: VapiToolCallsMessage;
}

================
File: app/api/practice-config/basic/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { subscribePracticeToWebhooks } from "@/lib/webhook-utils";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const formData = await req.formData();
    const name = formData.get("practiceName") as string | null;
    const subdomain = formData.get("nexhealthSubdomain") as string;
    const locationId = formData.get("nexhealthLocationId") as string;
    const address = formData.get("practiceAddress") as string | null;
    const acceptedInsurances = formData.get("acceptedInsurances") as string | null;
    const serviceCostEstimates = formData.get("serviceCostEstimates") as string | null;

    if (!subdomain || !locationId) {
      return NextResponse.json(
        { error: "Subdomain and Location ID are required" },
        { status: 400 }
      );
    }

    // Update webhook last sync timestamp to reflect sync attempt time
    const syncAttemptTime = new Date();

    // Save the practice configuration
    const practice = await prisma.practice.upsert({
      where: { clerkUserId: userId },
      update: { 
        name, 
        nexhealthSubdomain: subdomain, 
        nexhealthLocationId: locationId,
        address,
        acceptedInsurances,
        serviceCostEstimates,
        webhookLastSyncAt: syncAttemptTime // Update sync timestamp when attempt is made
      },
      create: { 
        clerkUserId: userId, 
        name, 
        nexhealthSubdomain: subdomain, 
        nexhealthLocationId: locationId,
        address,
        acceptedInsurances,
        serviceCostEstimates,
        webhookLastSyncAt: syncAttemptTime // Set initial sync timestamp
      },
    });

    // Automatically sync webhooks after saving configuration
    let webhookSyncResult = { 
      success: false, 
      message: "Webhook sync not attempted",
      successCount: 0,
      skipCount: 0,
      failCount: 0
    };
    
    try {
      console.log(`[AutoWebhookSync] Auto-syncing webhooks for practice ${practice.id}...`);
      webhookSyncResult = await subscribePracticeToWebhooks(subdomain);
      
      if (webhookSyncResult.success) {
        console.log(`[AutoWebhookSync]  Successfully synced webhooks for ${subdomain}`);
      } else {
        console.warn(`[AutoWebhookSync]  Webhook sync completed with issues: ${webhookSyncResult.message}`);
      }
    } catch (webhookError) {
      console.error(`[AutoWebhookSync]  Failed to sync webhooks:`, webhookError);
      webhookSyncResult = {
        success: false,
        message: webhookError instanceof Error ? webhookError.message : "Configuration saved, but webhook sync failed",
        successCount: 0,
        skipCount: 0,
        failCount: 0
      };
    }

    // Return minimal response suitable for non-reloading save
    return NextResponse.json({ 
      success: true,
      practice: {
        id: practice.id,
        name: practice.name,
        nexhealthSubdomain: practice.nexhealthSubdomain,
        nexhealthLocationId: practice.nexhealthLocationId,
        webhookLastSyncAt: practice.webhookLastSyncAt
      },
      webhookSync: webhookSyncResult
    });

  } catch (error) {
    console.error("Error saving practice config:", error);
    return NextResponse.json(
      { error: "Failed to save configuration" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/check-slots/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import { z } from "zod";

interface NexhealthSlot {
  time: string;
  end_time: string;
  operatory_id?: number;
  [key: string]: unknown;
}

const checkSlotsSchema = z.object({
  requestedDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "requestedDate must be in YYYY-MM-DD format"),
  appointmentTypeId: z.string().min(1, "appointmentTypeId is required"),
  providerIds: z.array(z.string()).optional().default([]),
  operatoryIds: z.array(z.string()).optional().default([]),
  daysToSearch: z.number().min(1).max(30).optional().default(1)
});

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: true,
        savedProviders: {
          include: {
            provider: true,
            defaultOperatory: true,
            acceptedAppointmentTypes: {
              include: {
                appointmentType: true
              }
            }
          },
          where: { isActive: true }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({ 
        error: "NexHealth configuration incomplete. Please configure subdomain and location ID." 
      }, { status: 400 });
    }

    const body = await req.json();

    // Validate input using Zod
    const validationResult = checkSlotsSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { requestedDate, appointmentTypeId, providerIds, operatoryIds, daysToSearch } = validationResult.data;

    // Validate appointment type belongs to practice
    const appointmentType = practice.appointmentTypes.find(
      at => at.nexhealthAppointmentTypeId === appointmentTypeId
    );

    if (!appointmentType) {
      return NextResponse.json({ 
        error: "Appointment type not found or doesn't belong to practice" 
      }, { status: 400 });
    }

    // NEW LOGIC: Determine providers based on accepted appointment types
    let eligibleProviders = practice.savedProviders.filter(sp => sp.isActive);

    // First, filter providers who accept this appointment type
    const providersWhoAcceptType = eligibleProviders.filter(sp => {
      // If provider has no accepted appointment types configured, include them (backward compatibility)
      if (sp.acceptedAppointmentTypes.length === 0) {
        return true;
      }
      // Otherwise, check if they accept this specific appointment type
      return sp.acceptedAppointmentTypes.some(
        relation => relation.appointmentType.id === appointmentType.id
      );
    });

    // Apply provider filter if specific providers were requested
    if (providerIds.length > 0) {
      eligibleProviders = providersWhoAcceptType.filter(sp => 
        providerIds.includes(sp.provider.id)
      );
    } else {
      eligibleProviders = providersWhoAcceptType;
    }

    if (eligibleProviders.length === 0) {
      return NextResponse.json({ 
        error: "No providers are configured to accept this appointment type" 
      }, { status: 400 });
    }

    // NEW LOGIC: Determine operatories for each provider
    const providerOperatoryPairs: Array<{
      provider: { id: string; nexhealthProviderId: string; firstName: string | null; lastName: string; };
      operatoryId: string | null;
    }> = [];

    for (const savedProvider of eligibleProviders) {
      if (operatoryIds.length > 0) {
        // If specific operatories were requested, check if provider's default operatory is in the list
        if (savedProvider.defaultOperatoryId && operatoryIds.includes(savedProvider.defaultOperatoryId)) {
          providerOperatoryPairs.push({
            provider: savedProvider.provider,
            operatoryId: savedProvider.defaultOperatoryId
          });
        } else {
          // If provider's default operatory is not in the requested list, 
          // we could either skip this provider or use the first requested operatory
          // For now, we'll use the first requested operatory if available
          const firstRequestedOperatory = practice.savedOperatories.find(so => 
            operatoryIds.includes(so.id) && so.isActive
          );
          if (firstRequestedOperatory) {
            providerOperatoryPairs.push({
              provider: savedProvider.provider,
              operatoryId: firstRequestedOperatory.id
            });
          }
        }
      } else {
        // No specific operatories requested, use provider's default operatory if available
        providerOperatoryPairs.push({
          provider: savedProvider.provider,
          operatoryId: savedProvider.defaultOperatoryId
        });
      }
    }

    // Prepare NexHealth API call parameters
    const nexhealthProviderIds = providerOperatoryPairs.map(pair => pair.provider.nexhealthProviderId);
    
    // Get unique operatory IDs and convert to NexHealth operatory IDs
    const uniqueOperatoryIds = [...new Set(
      providerOperatoryPairs
        .map(pair => pair.operatoryId)
        .filter((id): id is string => id !== null)
    )];

    const nexhealthOperatoryIds = uniqueOperatoryIds.length > 0 
      ? practice.savedOperatories
          .filter(so => uniqueOperatoryIds.includes(so.id))
          .map(so => so.nexhealthOperatoryId)
      : [];

    // Build NexHealth API parameters
    const params: Record<string, string | number | string[]> = {
      start_date: requestedDate,
      days: daysToSearch,
      'lids[]': [practice.nexhealthLocationId],
      'pids[]': nexhealthProviderIds,
      appointment_type_id: appointmentTypeId
    };

    // Add operatory IDs if we have any
    if (nexhealthOperatoryIds.length > 0) {
      params['operatory_ids[]'] = nexhealthOperatoryIds;
    }

    console.log("Checking appointment slots with new provider logic:", {
      eligibleProvidersCount: eligibleProviders.length,
      providersWhoAcceptType: providersWhoAcceptType.length,
      providerOperatoryPairs: providerOperatoryPairs.length,
      params
    });

    // Call NexHealth API
    const slotsResponse = await fetchNexhealthAPI(
      '/appointment_slots',
      practice.nexhealthSubdomain,
      params
    );

    // Parse response and extract slots
    const availableSlots: Array<NexhealthSlot & { provider_id: number; location_id: number }> = [];
    
    if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
      // Extract all slots from all providers
      for (const providerData of slotsResponse.data) {
        if (providerData.slots && Array.isArray(providerData.slots)) {
          availableSlots.push(...providerData.slots.map((slot: NexhealthSlot) => ({
            ...slot,
            provider_id: providerData.pid,
            location_id: providerData.lid
          })));
        }
      }
    }

    // Create provider lookup map
    const providerLookup = new Map();
    eligibleProviders.forEach(sp => {
      providerLookup.set(sp.provider.nexhealthProviderId, {
        id: sp.provider.id,
        nexhealthProviderId: sp.provider.nexhealthProviderId,
        name: `${sp.provider.firstName || ''} ${sp.provider.lastName}`.trim(),
        defaultOperatory: sp.defaultOperatory ? {
          id: sp.defaultOperatory.id,
          name: sp.defaultOperatory.name,
          nexhealthOperatoryId: sp.defaultOperatory.nexhealthOperatoryId
        } : null
      });
    });

    // Create operatory lookup map
    const operatoryLookup = new Map();
    practice.savedOperatories.forEach(so => {
      operatoryLookup.set(so.nexhealthOperatoryId, {
        id: so.id,
        nexhealthOperatoryId: so.nexhealthOperatoryId,
        name: so.name
      });
    });

    // Format slots for display with enhanced information
    const formattedSlots = availableSlots.map((slot, index) => {
      // Parse the time string correctly to preserve the timezone
      const startTime = new Date(slot.time);
      const endTime = new Date(slot.end_time);
      
      // Use the timezone from the original date string for formatting
      const timeString = startTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
      });

      const endTimeString = endTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Chicago'
      });

      // Get provider and operatory details
      const providerInfo = providerLookup.get(slot.provider_id.toString()) || { 
        name: `Provider ${slot.provider_id}`, 
        nexhealthProviderId: slot.provider_id 
      };
      
      const operatoryInfo = slot.operatory_id ? 
        operatoryLookup.get(slot.operatory_id.toString()) || { 
          name: `Operatory ${slot.operatory_id}`, 
          nexhealthOperatoryId: slot.operatory_id 
        } : null;
      
      return {
        slot_id: `slot_${index}`,
        time: slot.time,
        end_time: slot.end_time,
        display_time: timeString,
        display_end_time: endTimeString,
        display_range: `${timeString} - ${endTimeString}`,
        operatory_id: slot.operatory_id,
        provider_id: slot.provider_id,
        location_id: slot.location_id,
        provider_info: providerInfo,
        operatory_info: operatoryInfo
      };
    });

    // Sort slots by time
    formattedSlots.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());

    return NextResponse.json({
      success: true,
      params: params,
      response: slotsResponse,
      data: {
        requested_date: requestedDate,
        appointment_type: {
          id: appointmentType.nexhealthAppointmentTypeId,
          name: appointmentType.name,
          duration: appointmentType.duration,
          groupCode: appointmentType.groupCode
        },
        available_slots: formattedSlots,
        has_availability: formattedSlots.length > 0,
        total_slots_found: formattedSlots.length,
        debug_info: {
          total_active_providers: practice.savedProviders.length,
          providers_who_accept_type: providersWhoAcceptType.length,
          eligible_providers_after_filter: eligibleProviders.length,
          provider_operatory_pairs: providerOperatoryPairs.length,
          providers_used: eligibleProviders.map(sp => ({
            id: sp.provider.id,
            name: `${sp.provider.firstName || ''} ${sp.provider.lastName}`.trim(),
            nexhealthProviderId: sp.provider.nexhealthProviderId,
            defaultOperatory: sp.defaultOperatory ? sp.defaultOperatory.name : null,
            acceptedAppointmentTypesCount: sp.acceptedAppointmentTypes.length
          })),
          operatories_used: uniqueOperatoryIds.map(id => {
            const operatory = practice.savedOperatories.find(so => so.id === id);
            return operatory ? {
              id: operatory.id,
              name: operatory.name,
              nexhealthOperatoryId: operatory.nexhealthOperatoryId
            } : null;
          }).filter(Boolean)
        }
      }
    });

  } catch (error) {
    console.error("Error checking appointment slots:", error);
    return NextResponse.json(
      { 
        error: "Failed to check appointment slots", 
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}

================
File: app/globals.css
================
@import "tailwindcss";

@custom-variant dark (&:is(.dark *));

:root {
  --background: #ffffff;
  --foreground: #0f172a;
}

.dark {
  --background: #0f172a;
  --foreground: #f8fafc;
}

@layer base {
  * {
    @apply border-gray-300;
  }
  body {
    @apply bg-white text-gray-900;
  }
}

================
File: README.md
================
# Laine AI Voice Assistant

AI-powered voice assistant for healthcare practices, integrating NexHealth EHR with VAPI voice AI technology.

## Features

-  **VAPI Voice Integration**: AI-powered voice calls with customizable assistants
-  **NexHealth EHR Integration**: Patient lookup, appointment management, and data synchronization
-  **Webhook Management**: Automated event handling for appointments and patient updates
-  **Practice Management**: Multi-tenant SaaS platform with practice-specific configurations
-  **Secure Authentication**: Clerk-based user authentication and practice isolation

## Quick Start

1. **Environment Setup**:
   ```bash
   cp .env.example .env
   # Configure your API keys and database URL
   ```

2. **Database Setup**:
   ```bash
   pnpm install
   pnpm db:push
   ```

3. **Development Server**:
   ```bash
   pnpm dev
   ```

4. **Webhook Configuration** (Production):
   ```bash
   # Setup global webhook endpoint
   pnpm webhook:setup
   
   # Subscribe practices to events
   pnpm webhook:subscribe your-practice-subdomain
   ```

## Documentation

-  [Webhook Management Guide](docs/webhook-management.md) - Complete guide to NexHealth webhook setup
-  [API Documentation](docs/api.md) - API endpoints and integration details

## Technology Stack

- **Frontend**: Next.js 15, React 19, Tailwind CSS
- **Backend**: Next.js API Routes, Prisma ORM
- **Database**: PostgreSQL (Supabase)
- **Authentication**: Clerk
- **Voice AI**: VAPI
- **EHR Integration**: NexHealth API
- **Deployment**: Vercel

## Key Components

### VAPI Assistant Integration
- AI voice assistants with customizable voices and prompts
- Tool calling system for EHR operations
- Call logging and transcript management

### NexHealth Integration  
- Patient search and data retrieval
- Appointment scheduling and management
- Real-time webhook event processing

### Practice Management
- Multi-tenant architecture with practice isolation
- Configurable assistant settings per practice
- Automated practice onboarding workflow

# LAINE Project Context

## **Project Overview**
**LAINE** is an AI voice receptionist SaaS platform for dental practices. It enables dental offices to automate patient interactions, appointment scheduling, and EHR integration through AI voice assistants.

## **Core Functionality**
- **AI Voice Reception**: Patients call and speak with an AI assistant (powered by VAPI)
- **Patient Lookup**: Find existing patients in the practice's EHR system
- **Appointment Scheduling**: Check availability and book appointments
- **EHR Integration**: Connect with NexHealth to access patient records and scheduling
- **Multi-Tenant SaaS**: Each dental practice gets isolated data and configuration

## **Technology Stack**

### **Frontend**
- **Next.js 15+** (App Router)
- **React 19** with TypeScript
- **Tailwind CSS** for styling
- **Clerk** for authentication

### **Backend**
- **Next.js API Routes** 
- **Prisma ORM** with PostgreSQL
- **Supabase** for database hosting

### **External Integrations**
- **VAPI**: AI voice calling platform
- **NexHealth**: Dental practice EHR/scheduling system  
- **Clerk**: User authentication and management

### **Key Dependencies**
- `@clerk/nextjs` - Authentication
- `@prisma/client` - Database ORM
- `zod` - Schema validation
- `sonner` - Toast notifications

## **Architecture Patterns**

### **Multi-Tenant SaaS Design**
- Each dental practice is isolated by `practiceId`
- Users authenticate via Clerk (`clerkUserId`)
- All data operations are practice-scoped

### **Tool-Based AI Framework**
- AI assistant uses "tools" to perform actions
- Tools are TypeScript functions with Zod schemas
- Centralized tool execution via webhook handler

### **API Integration Layer**
- NexHealth API for EHR operations
- VAPI API for voice assistant management
- Token-based authentication with caching

## **Database Schema (Key Models)**

### **Core Models**
```prisma
Practice {
  id: String (Primary Key)
  clerkUserId: String (Unique - links to Clerk user)
  name: String? (Optional practice name)
  nexhealthSubdomain: String? (NexHealth subdomain)
  nexhealthLocationId: String? (NexHealth location ID)
}

PracticeAssistantConfig {
  practiceId: String (FK to Practice)
  vapiAssistantId: String? (VAPI assistant ID)
  voiceProvider: String (voice provider)
  systemPrompt: String (AI instructions)
  firstMessage: String (greeting message)
}
```

### **Scheduling Models**
```prisma
AppointmentType {
  practiceId: String (FK to Practice)
  nexhealthAppointmentTypeId: String (NexHealth ID)
  name: String (e.g., "General Cleanup")
  duration: Int (minutes)
}

Provider {
  practiceId: String (FK to Practice) 
  nexhealthProviderId: String (NexHealth ID)
  firstName: String?
  lastName: String
}

SavedProvider {
  practiceId: String (FK to Practice)
  providerId: String (FK to Provider)
  isDefault: Boolean
  isActive: Boolean
}
```

### **Logging Models**
```prisma
CallLog {
  vapiCallId: String (Unique - from VAPI)
  practiceId: String (FK to Practice)
  callStatus: String (e.g., "IN_PROGRESS", "ENDED")
  transcriptText: String?
  nexhealthPatientId: String? (if patient found)
}

ToolLog {
  practiceId: String (FK to Practice)
  vapiCallId: String? (FK to CallLog)
  toolName: String (e.g., "find_patient_in_ehr")
  toolCallId: String (VAPI tool call ID)
  arguments: String (JSON)
  result: String (JSON)
  success: Boolean
}
```

## **Key API Endpoints**

### **VAPI Integration**
- `POST /api/vapi/tool-calls` - Centralized tool execution webhook
- `POST /api/vapi/webhook` - General VAPI webhooks (call status, transcripts)

### **Practice Configuration**
- `POST /api/practice-config/providers` - Save provider preferences
- `POST /api/practice-config/operatories` - Save operatory preferences
- `POST /api/sync-nexhealth` - Sync data from NexHealth API

### **NexHealth Integration**
- `POST /api/nexhealth-webhook` - Receive NexHealth events
- `POST /api/webhook-subscribe` - Subscribe to NexHealth events

## **AI Tools Framework**

### **Tool Structure**
Each tool is defined with:
```typescript
interface ToolDefinition<T extends z.ZodType> {
  name: string                    // Tool identifier
  description: string             // What the tool does
  schema: T                      // Zod validation schema
  run: (params) => Promise<ToolResult>  // Tool execution logic
  messages?: ToolMessages        // VAPI voice prompts
}
```

### **Current Tools**
1. **`find_patient_in_ehr`** - Search for patients by name and DOB
2. **`find_appointment_type`** - Match patient requests to appointment types
3. **`check_available_slots`** - Find available appointment times

### **Tool Execution Flow**
1. VAPI calls `/api/vapi/tool-calls` webhook
2. Practice identified by assistant ID
3. Tool arguments validated with Zod
4. Tool executes with practice context
5. Results logged to database
6. Response sent back to VAPI

## **Typical User Journey**

### **Practice Setup**
1. Practice owner signs up via Clerk
2. Configure NexHealth subdomain and location ID
3. Sync appointment types and providers from NexHealth
4. Select preferred providers and operatories for scheduling
5. Create and configure VAPI voice assistant

### **Patient Interaction**
1. Patient calls dental office phone number
2. VAPI voice assistant answers
3. Assistant asks for patient name and date of birth
4. `find_patient_in_ehr` tool searches NexHealth EHR
5. If patient found, assistant asks about appointment purpose
6. `find_appointment_type` tool matches request to available types
7. `check_available_slots` tool finds available times
8. Assistant presents options to patient

## **Environment Variables**
```bash
# Database
DATABASE_URL=postgresql://...

# Authentication  
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_...
CLERK_SECRET_KEY=sk_...

# VAPI Integration
VAPI_API_KEY=vapi_...
NEXT_PUBLIC_APP_URL=https://your-domain.com

# NexHealth Integration
NEXHEALTH_API_KEY=nexhealth_...
NEXHEALTH_API_BASE_URL=https://nexhealth.info
```

## **Key File Structure**
```
app/
 api/
    vapi/
       tool-calls/route.ts     # Centralized tool handler
       webhook/route.ts        # VAPI general webhooks
    practice-config/            # Practice management APIs
    nexhealth-webhook/route.ts  # NexHealth event handler
 practice-config/                # Practice configuration UI
 laine/                         # Assistant configuration UI

lib/
 tools/
    types.ts                   # Tool framework types
    index.ts                   # Tool registry
    findPatient.ts            # Patient lookup tool
    findAppointmentType.ts    # Appointment type matching
    checkAvailableSlots.ts    # Availability checking
 nexhealth.ts                  # NexHealth API client
 vapi.ts                       # VAPI API client
 prisma.ts                     # Database client

prisma/
 schema.prisma                  # Database schema
```

## **Development Commands**
```bash
# Development
pnpm dev                          # Start development server
pnpm build                        # Build for production
pnpm lint                         # Run ESLint

# Database
pnpm db:push                      # Push schema changes
pnpm db:list                      # List database contents
pnpm db:clean                     # Clean test data

# Webhooks
pnpm webhook:setup                # Setup NexHealth webhook endpoint
pnpm webhook:subscribe <subdomain> # Subscribe practice to events
pnpm webhook:list                 # List webhook subscriptions
```

## **Common Patterns**

### **Practice Context Injection**
All operations include practice context:
```typescript
const practice = await findPracticeByAssistantId(assistantId);
// All subsequent operations are practice-scoped
```

### **Error Handling**
User-friendly error messages for patients:
```typescript
return {
  success: false,
  error_code: "PATIENT_NOT_FOUND",
  message_to_patient: "I couldn't find that patient. Would you like to try different information?"
};
```

### **Tool Result Format**
Standardized response format:
```typescript
interface ToolResult {
  success: boolean
  message_to_patient: string  // What the AI says to the patient
  data?: Record<string, unknown>  // Structured data
  error_code?: string  // Error classification
}
```

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ClerkProvider, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Laine AI Voice Assistant",
  description: "Advanced voice assistant for healthcare practices with seamless NexHealth integration",
};

async function Header() {
  const { userId } = await auth();
  
  return (
    <header className="fixed top-0 left-0 right-0 bg-white/10 backdrop-blur-md border-b border-slate-200/30 z-50">
      <div className="flex items-center justify-between max-w-6xl mx-auto px-6 py-4">
        <div className="flex items-center">
          <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center mr-3">
            <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
          <h1 className="text-xl font-bold text-slate-900">Laine AI</h1>
        </div>
        <div className="flex items-center gap-4">
          {userId ? (
            <div className="flex items-center gap-4">
              <a 
                href="/practice-config" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Practice Config
              </a>
              <a 
                href="/laine" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Laine Assistant
              </a>
              <a 
                href="/test" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Test
              </a>
              <a 
                href="/tool-calls" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Tool Calls
              </a>
              <UserButton afterSignOutUrl="/" />
            </div>
          ) : (
            <>
              <SignInButton mode="modal">
                <button className="px-4 py-2 text-sm font-medium text-slate-600 hover:text-slate-900 transition-colors">
                  Sign In
                </button>
              </SignInButton>
              <SignUpButton mode="modal">
                <button className="px-4 py-2 text-sm font-semibold bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                  Sign Up
                </button>
              </SignUpButton>
            </>
          )}
        </div>
      </div>
    </header>
  );
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body
          className={`${geistSans.variable} ${geistMono.variable} antialiased bg-slate-50`}
        >
          <Header />
          <main className="pt-20">
            {children}
          </main>
        </body>
      </html>
    </ClerkProvider>
  );
}

================
File: lib/tools/index.ts
================
import { ToolDefinition, VapiToolSchema, VapiToolFunction } from "./types";
import { zodToJsonSchema } from "zod-to-json-schema";

// Import all tools
import findPatientTool from "./findPatient";
import findAppointmentTypeTool from "./findAppointmentType";
import checkAvailableSlotsTool from "./checkAvailableSlots";
import bookAppointmentTool from "./bookAppointment";
import createNewPatientTool from "./createNewPatient";
import getPracticeDetailsTool from "./getPracticeDetails";
import checkInsuranceParticipationTool from "./checkInsuranceParticipation";
import getServiceCostEstimateTool from "./getServiceCostEstimate";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const tools: ToolDefinition<any>[] = [
  findPatientTool,
  findAppointmentTypeTool,
  checkAvailableSlotsTool,
  bookAppointmentTool,
  createNewPatientTool,
  getPracticeDetailsTool,
  checkInsuranceParticipationTool,
  getServiceCostEstimateTool
];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function getToolByName(name: string): ToolDefinition<any> | undefined {
  return tools.find(t => t.name === name);
}

// This function builds the array for VAPI's `model.tools[]`
export function buildVapiTools(appBaseUrl: string): VapiToolSchema[] {
  console.log(`Building VAPI tools for ${tools.length} registered tools`);
  
  return tools.map(tool => {
    // Generate JSON schema without $schema property
    const schema = zodToJsonSchema(tool.schema, { 
      target: "jsonSchema7", 
      $refStrategy: "none" 
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $schema, ...parameters } = schema;
    
    const vapiToolFunction: VapiToolFunction = {
      name: tool.name,
      description: tool.description,
      parameters
    };
    
    const vapiTool: VapiToolSchema = {
      type: "function",
      async: tool.async ?? false,
      function: vapiToolFunction,
      server: { 
        url: `${appBaseUrl}/api/vapi/tool-calls`
      }
    };

    // Add only the start message - success/fail messages will be dynamic from tool execution
    if (tool.messages?.start) {
      vapiTool.messages = [
        { type: "request-start", content: tool.messages.start }
      ];
    }
    
    console.log(`Built VAPI tool: ${tool.name} -> ${vapiTool.server.url}`);
    return vapiTool;
  });
}

// Export individual tool schemas for validation
export { findPatientSchema } from "./findPatient";
export { findAppointmentTypeSchema } from "./findAppointmentType";
export { checkAvailableSlotsSchema } from "./checkAvailableSlots";
export { bookAppointmentSchema } from "./bookAppointment";
export { createNewPatientSchema } from "./createNewPatient";
export { getPracticeDetailsSchema } from "./getPracticeDetails";
export { checkInsuranceParticipationSchema } from "./checkInsuranceParticipation";
export { getServiceCostEstimateSchema } from "./getServiceCostEstimate";

================
File: lib/nexhealth.ts
================
import { prisma } from "@/lib/prisma";
import { addSeconds } from 'date-fns';

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number; // NexHealth uses 'minutes' not 'duration'
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

interface NexHealthOperatory {
  id: number;
  name: string;
  location_id: number;
  active: boolean;
}

const NEXHEALTH_API_BASE_URL = process.env.NEXHEALTH_API_BASE_URL!;
const MASTER_NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY!; // The master key

const TOKEN_CACHE_ID = "singleton"; // Fixed ID for the single token entry
const TOKEN_EXPIRY_BUFFER_SECONDS = 300; // 5 minutes buffer
const DEFAULT_TOKEN_LIFETIME_SECONDS = 55 * 60; // 55 minutes (safe for 1-hour tokens)

async function fetchNewBearerToken(): Promise<{ accessToken: string; expiresAt: Date }> {
  if (!MASTER_NEXHEALTH_API_KEY) {
    throw new Error("NEXHEALTH_API_KEY is not configured in environment variables.");
  }

  const authUrl = `${NEXHEALTH_API_BASE_URL}/authenticates`;
  console.log("Fetching new NexHealth bearer token...");

  try {
    const response = await fetch(authUrl, {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.Nexhealth+json;version=2',
        // NexHealth expects the raw master key for /authenticates endpoint
        'Authorization': MASTER_NEXHEALTH_API_KEY,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("Failed to fetch NexHealth bearer token:", response.status, errorBody);
      throw new Error(`NexHealth Authentication failed: ${response.status} - ${errorBody}`);
    }

    const result = await response.json();
    
    if (!result.data || !result.data.token) {
      console.error("NexHealth /authenticates response missing token:", result);
      throw new Error("Invalid token response from NexHealth /authenticates");
    }

    const accessToken = result.data.token;
    const now = new Date();
    
    // If NexHealth provides expiry in response, use it. Otherwise, use default lifetime.
    // Most JWT tokens have 1-hour validity, we use 55 minutes to be safe
    let expiresAt: Date;
    
    if (result.data.exp) {
      // If exp is provided as UNIX timestamp (seconds)
      expiresAt = new Date(result.data.exp * 1000);
    } else {
      // Default to 55 minutes from now
      expiresAt = addSeconds(now, DEFAULT_TOKEN_LIFETIME_SECONDS);
    }

    console.log(`New NexHealth token expires at: ${expiresAt.toISOString()}`);

    // Cache the token in database
    await prisma.nexhealthTokenCache.upsert({
      where: { id: TOKEN_CACHE_ID },
      update: { accessToken, expiresAt },
      create: { id: TOKEN_CACHE_ID, accessToken, expiresAt },
    });

    return { accessToken, expiresAt };
  } catch (error) {
    console.error('Error fetching NexHealth bearer token:', error);
    throw error;
  }
}

export async function getNexhealthBearerToken(): Promise<string> {
  try {
    // Check for cached token
    const cachedToken = await prisma.nexhealthTokenCache.findUnique({
      where: { id: TOKEN_CACHE_ID },
    });

    if (cachedToken) {
      const now = new Date();
      const tokenStillValidUntil = addSeconds(now, TOKEN_EXPIRY_BUFFER_SECONDS);
      
      if (cachedToken.expiresAt > tokenStillValidUntil) {
        console.log("Using cached NexHealth bearer token.");
        return cachedToken.accessToken;
      }
      console.log("Cached NexHealth token expired or nearing expiry.");
    } else {
      console.log("No cached NexHealth token found.");
    }

    // Fetch new token if none cached or expired
    const { accessToken } = await fetchNewBearerToken();
    return accessToken;
  } catch (error) {
    console.error('Error getting NexHealth bearer token:', error);
    throw error;
  }
}

// Export the generic API function for use in tools and other modules
export async function fetchNexhealthAPI(
  path: string, // e.g., "/appointment_types"
  subdomain: string, // Practice-specific subdomain
  params?: Record<string, string | number | string[]>,
  method: string = 'GET',
  body?: unknown
) {
  // Get valid bearer token
  const bearerToken = await getNexhealthBearerToken();
  
  const url = new URL(`${NEXHEALTH_API_BASE_URL}${path}`);
  
  // Add subdomain for data API calls (not for /authenticates)
  if (path !== '/authenticates' && !params?.subdomain) {
    url.searchParams.append('subdomain', subdomain);
  }
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v.toString()));
      } else {
        url.searchParams.append(key, value.toString());
      }
    });
  }

  const options: RequestInit = {
    method,
    headers: {
      'Accept': 'application/vnd.Nexhealth+json;version=2',
      'Authorization': `Bearer ${bearerToken}`, // Use bearer token for data APIs
      'Content-Type': 'application/json',
    },
  };

  if (body && method !== 'GET') {
    options.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(url.toString(), options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`NexHealth API error (${response.status}):`, errorText);
      
      // If we get 401, the token might be invalid - clear cache and retry once
      if (response.status === 401) {
        console.log("Got 401, clearing token cache and retrying...");
        await prisma.nexhealthTokenCache.deleteMany({
          where: { id: TOKEN_CACHE_ID }
        });
        
        // Retry with fresh token (recursive call - but only once due to cache clear)
        return fetchNexhealthAPI(path, subdomain, params, method, body);
      }
      
      throw new Error(`NexHealth API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('NexHealth API error:', error);
    throw error;
  }
}

export async function getAppointmentTypes(subdomain: string, locationId: string): Promise<NexHealthAppointmentType[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    { location_id: locationId }
  );
  
  // Handle different possible response structures
  let appointmentTypes = null;
  
  if (Array.isArray(data)) {
    appointmentTypes = data;
  } else if (data?.data?.appointment_types && Array.isArray(data.data.appointment_types)) {
    appointmentTypes = data.data.appointment_types;
  } else if (data?.appointment_types && Array.isArray(data.appointment_types)) {
    appointmentTypes = data.appointment_types;
  } else if (data?.data && Array.isArray(data.data)) {
    appointmentTypes = data.data;
  } else {
    console.warn("Unexpected appointment_types response structure:", data);
    appointmentTypes = [];
  }
  return appointmentTypes;
}

export async function getProviders(subdomain: string, locationId: string): Promise<NexHealthProvider[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/providers',
    subdomain,
    { location_id: locationId, inactive: 'false', page: '1', per_page: '300' }
  );
  
  // Handle different possible response structures
  let providers = null;
  
  if (Array.isArray(data)) {
    providers = data;
  } else if (data?.data?.providers && Array.isArray(data.data.providers)) {
    providers = data.data.providers;
  } else if (data?.providers && Array.isArray(data.providers)) {
    providers = data.providers;
  } else if (data?.data && Array.isArray(data.data)) {
    providers = data.data;
  } else {
    console.warn("Unexpected providers response structure:", data);
    providers = [];
  }
  return providers;
}

export async function getOperatories(subdomain: string, locationId: string): Promise<NexHealthOperatory[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/operatories',
    subdomain,
    { location_id: locationId, page: '1', per_page: '300' }
  );
  
  console.log("Raw NexHealth operatories response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let operatories = null;
  
  if (Array.isArray(data)) {
    operatories = data;
  } else if (data?.data?.operatories && Array.isArray(data.data.operatories)) {
    operatories = data.data.operatories;
  } else if (data?.operatories && Array.isArray(data.operatories)) {
    operatories = data.operatories;
  } else if (data?.data && Array.isArray(data.data)) {
    operatories = data.data;
  } else {
    console.warn("Unexpected operatories response structure:", data);
    operatories = [];
  }
  
  console.log(`Parsed ${operatories.length} operatories`);
  return operatories.filter((op: NexHealthOperatory) => op.active !== false);
}

// Availability-related interfaces and functions
interface NexHealthAvailability {
  id: number;
  provider_id: number;
  location_id: number;
  operatory_id?: number;
  begin_time: string;
  end_time: string;
  days: string[];
  specific_date?: string;
  custom_recurrence?: {
    num: number;
    unit: string;
    ref: string;
  };
  tz_offset: string;
  active: boolean;
  synced: boolean;
  appointment_types: Array<{
    id: number;
    name: string;
    parent_type: string;
    parent_id: number;
    minutes: number;
    bookable_online: boolean;
  }>;
}

interface CreateAvailabilityData {
  provider_id: number;
  operatory_id?: number;
  days: string[];
  begin_time: string;
  end_time: string;
  appointment_type_ids: number[];
  active?: boolean;
}

interface UpdateAvailabilityData {
  provider_id?: number;
  operatory_id?: number;
  days?: string[];
  begin_time?: string;
  end_time?: string;
  appointment_type_ids?: number[];
  active?: boolean;
}

export async function createNexhealthAvailability(
  subdomain: string, 
  locationId: string, 
  availabilityData: CreateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !locationId) {
    throw new Error("Subdomain and Location ID are required.");
  }

  const data = await fetchNexhealthAPI(
    '/availabilities',
    subdomain,
    { location_id: locationId },
    'POST',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth create availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected create availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth create availability");
  }

  console.log(`Created availability with ID: ${availability.id}`);
  return availability;
}

export async function updateNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string,
  availabilityData: UpdateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !nexhealthAvailabilityId) {
    throw new Error("Subdomain and availability ID are required.");
  }

  const data = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    {},
    'PATCH',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth update availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected update availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth update availability");
  }

  console.log(`Updated availability with ID: ${availability.id}`);
  return availability;
}

export async function deleteNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string
): Promise<void> {
  const response = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    undefined,
    'DELETE'
  );
  
  // For DELETE operations, expect a 204 or successful response with no data
  console.log(`Deleted NexHealth availability ${nexhealthAvailabilityId}:`, response);
}

// Appointment Type CRUD Functions

interface CreateAppointmentTypeData {
  name: string;
  minutes: number;
  bookable_online?: boolean;
  parent_type: "Location" | "Institution";
  parent_id: string | number;
  emr_appt_descriptor_ids?: number[];
}

interface UpdateAppointmentTypeData {
  name?: string;
  minutes?: number;
  bookable_online?: boolean;
  parent_type?: "Location" | "Institution";
  parent_id?: string | number;
  emr_appt_descriptor_ids?: number[];
}

export async function createNexhealthAppointmentType(
  subdomain: string,
  locationId: string,
  apptTypeData: CreateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      name: apptTypeData.name,
      minutes: apptTypeData.minutes,
      bookable_online: apptTypeData.bookable_online ?? true,
      parent_type: apptTypeData.parent_type,
      parent_id: apptTypeData.parent_id,
      ...(apptTypeData.emr_appt_descriptor_ids && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    undefined,
    'POST',
    requestBody
  );

  console.log('Created NexHealth appointment type:', response);
  return response.data;
}

export async function updateNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId: string,
  apptTypeData: UpdateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      ...(apptTypeData.name !== undefined && { name: apptTypeData.name }),
      ...(apptTypeData.minutes !== undefined && { minutes: apptTypeData.minutes }),
      ...(apptTypeData.bookable_online !== undefined && { bookable_online: apptTypeData.bookable_online }),
      ...(apptTypeData.parent_type !== undefined && { parent_type: apptTypeData.parent_type }),
      ...(apptTypeData.parent_id !== undefined && { parent_id: apptTypeData.parent_id }),
      ...(apptTypeData.emr_appt_descriptor_ids !== undefined && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    undefined,
    'PATCH',
    requestBody
  );

  console.log(`Updated NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
  return response.data;
}

export async function deleteNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId?: string
): Promise<void> {
  const params = locationId ? { location_id: locationId } : undefined;

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    params,
    'DELETE'
  );

  console.log(`Deleted NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
}

// Sync function for appointment types
export async function syncPracticeAppointmentTypes(
  practiceId: string,
  subdomain: string,
  locationId: string
): Promise<void> {
  try {
    console.log(`Syncing appointment types for practice ${practiceId}...`);
    
    // Fetch appointment types from NexHealth
    const nexhealthAppointmentTypes = await getAppointmentTypes(subdomain, locationId);
    
    console.log(`Found ${nexhealthAppointmentTypes.length} appointment types from NexHealth`);

    // Sync each appointment type with local database
    for (const nexhealthType of nexhealthAppointmentTypes) {
      try {
        await prisma.appointmentType.upsert({
          where: {
            practiceId_nexhealthAppointmentTypeId: {
              practiceId,
              nexhealthAppointmentTypeId: nexhealthType.id.toString()
            }
          },
          update: {
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString(),
            lastSyncError: null, // Clear any previous errors on successful sync
            updatedAt: new Date()
          },
          create: {
            practiceId,
            nexhealthAppointmentTypeId: nexhealthType.id.toString(),
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString()
          }
        });

        console.log(`Synced appointment type: ${nexhealthType.name} (ID: ${nexhealthType.id})`);
      } catch (error) {
        console.error(`Error syncing appointment type ${nexhealthType.id}:`, error);
        
        // Try to update just the error field if the record exists
        try {
          await prisma.appointmentType.update({
            where: {
              practiceId_nexhealthAppointmentTypeId: {
                practiceId,
                nexhealthAppointmentTypeId: nexhealthType.id.toString()
              }
            },
            data: {
              lastSyncError: error instanceof Error ? error.message : 'Unknown sync error',
              updatedAt: new Date()
            }
          });
        } catch (updateError) {
          console.error(`Failed to update sync error for appointment type ${nexhealthType.id}:`, updateError);
        }
      }
    }

    console.log(`Completed syncing appointment types for practice ${practiceId}`);
  } catch (error) {
    console.error(`Error syncing appointment types for practice ${practiceId}:`, error);
    throw error;
  }
}

================
File: app/practice-config/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@clerk/nextjs";
import { redirect } from "next/navigation";
import { Toaster, toast } from "sonner";
import { QuickReview } from "./QuickReview";
import { AppointmentTypesConfig } from "./AppointmentTypesConfig";
import { ProvidersConfig } from "./ProvidersConfig";
import { CheckAppointmentSlotsTool } from "./CheckAppointmentSlotsTool";

// Types for the simplified structure
interface Practice {
  id: string;
  name: string | null;
  nexhealthSubdomain: string | null;
  nexhealthLocationId: string | null;
  webhookLastSyncAt: string | null;
  address: string | null;
  acceptedInsurances: string | null;
  serviceCostEstimates: string | null;
  appointmentTypes: Array<{
    id: string;
    nexhealthAppointmentTypeId: string;
    name: string;
    duration: number;
    bookableOnline: boolean | null;
    groupCode: string | null;
    createdAt: string;
    updatedAt: string;
  }>;
  providers: Array<{
    id: string;
    nexhealthProviderId: string;
    firstName: string | null;
    lastName: string;
  }>;
  savedProviders: Array<{
    id: string;
    providerId: string;
    isActive: boolean;
    provider: {
      id: string;
      nexhealthProviderId: string;
      firstName: string | null;
      lastName: string;
    };
  }>;
  savedOperatories: Array<{
    id: string;
    nexhealthOperatoryId: string;
    name: string;
    isActive: boolean;
  }>;
}

interface WebhookStatus {
  lastSyncStatus: 'NEVER_SYNCED' | 'SYNCED_ATTEMPTED' | 'ERROR';
  lastSyncAttemptAt: string | null;
  lastSyncErrorMessage: string | null;
  subscriptionCounts: {
    appointment: number;
    availability: number;
    patient: number;
    provider: number;
    location: number;
  };
}

export default function PracticeConfigPage() {
  const { userId, isLoaded } = useAuth();
  const [practice, setPractice] = useState<Practice | null>(null);
  const [webhookStatus, setWebhookStatus] = useState<WebhookStatus | null>(null);
  const [loading, setLoading] = useState(true);
  const [basicInfoLoading, setBasicInfoLoading] = useState(false);
  const [webhookLoading, setWebhookLoading] = useState(false);

  useEffect(() => {
    if (isLoaded && !userId) {
      redirect("/sign-in");
    }
  }, [isLoaded, userId]);

  useEffect(() => {
    if (isLoaded && userId) {
      fetchPracticeData();
      fetchWebhookStatus();
    }
  }, [isLoaded, userId]);

  const fetchPracticeData = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/practice-config/data');
      if (response.ok) {
        const data = await response.json();
        setPractice(data.practice);
      } else {
        console.error('Failed to fetch practice data');
      }
    } catch (error) {
      console.error('Error fetching practice data:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchWebhookStatus = async () => {
    try {
      setWebhookLoading(true);
      const response = await fetch('/api/practice-config/webhook-status');
      if (response.ok) {
        const data = await response.json();
        setWebhookStatus(data);
      } else {
        console.error('Failed to fetch webhook status');
      }
    } catch (error) {
      console.error('Error fetching webhook status:', error);
    } finally {
      setWebhookLoading(false);
    }
  };

  const handleBasicInfoSave = async (formData: FormData) => {
    setBasicInfoLoading(true);
    try {
      const response = await fetch('/api/practice-config/basic', {
        method: 'POST',
        body: formData
      });

      if (response.ok) {
        toast.success('Basic information saved successfully!');
        
        // Refresh data after save
        await fetchPracticeData();
        await fetchWebhookStatus();
      } else {
        const error = await response.json();
        toast.error(`Failed to save: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error saving config:', error);
      toast.error('Failed to save configuration');
    } finally {
      setBasicInfoLoading(false);
    }
  };

  const refreshWebhookStatus = async () => {
    await fetchWebhookStatus();
  };

  const refreshPracticeData = async () => {
    await fetchPracticeData();
  };

  const getWebhookStatusIcon = (status: WebhookStatus['lastSyncStatus']) => {
    switch (status) {
      case 'SYNCED_ATTEMPTED':
        return <div className="w-3 h-3 bg-green-500 rounded-full"></div>;
      case 'ERROR':
        return <div className="w-3 h-3 bg-red-500 rounded-full"></div>;
      case 'NEVER_SYNCED':
        return <div className="w-3 h-3 bg-yellow-500 rounded-full"></div>;
      default:
        return <div className="w-3 h-3 bg-gray-400 rounded-full animate-pulse"></div>;
    }
  };

  const getWebhookStatusText = (status: WebhookStatus['lastSyncStatus']) => {
    switch (status) {
      case 'SYNCED_ATTEMPTED':
        return 'Webhooks Synced';
      case 'ERROR':
        return 'Webhook Error';
      case 'NEVER_SYNCED':
        return 'Never Synced';
      default:
        return 'Unknown Status';
    }
  };

  if (!isLoaded || loading) {
    return (
      <div className="max-w-6xl mx-auto p-6">
        <div className="text-center">Loading...</div>
      </div>
    );
  }

  if (!userId) {
    return null; // Will redirect
  }

  return (
    <>
      <Toaster position="top-right" />
      <div className="max-w-6xl mx-auto p-6">
        <h1 className="text-3xl font-bold mb-8">Practice Configuration</h1>
        
        {/* Basic Information Section */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <h2 className="text-xl font-semibold mb-4">Basic Information</h2>
          <form onSubmit={async (e) => {
            e.preventDefault();
            const formData = new FormData(e.currentTarget);
            await handleBasicInfoSave(formData);
          }} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label htmlFor="practiceName" className="block text-sm font-medium text-gray-700 mb-1">
                  Practice Name (Optional)
                </label>
                <input
                  type="text"
                  id="practiceName"
                  name="practiceName"
                  defaultValue={practice?.name || ""}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Enter your practice name"
                />
              </div>
              
              <div>
                <label htmlFor="nexhealthSubdomain" className="block text-sm font-medium text-gray-700 mb-1">
                  NexHealth Subdomain *
                </label>
                <input
                  type="text"
                  id="nexhealthSubdomain"
                  name="nexhealthSubdomain"
                  defaultValue={practice?.nexhealthSubdomain || ""}
                  required
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., testdental"
                />
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label htmlFor="nexhealthLocationId" className="block text-sm font-medium text-gray-700 mb-1">
                  NexHealth Location ID *
                </label>
                <input
                  type="text"
                  id="nexhealthLocationId"
                  name="nexhealthLocationId"
                  defaultValue={practice?.nexhealthLocationId || ""}
                  required
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., 123"
                />
              </div>

              <div>
                <label htmlFor="practiceAddress" className="block text-sm font-medium text-gray-700 mb-1">
                  Practice Address
                </label>
                <input
                  type="text"
                  id="practiceAddress"
                  name="practiceAddress"
                  defaultValue={practice?.address || ""}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., 123 Dental St, Smileytown, CA 98765"
                />
              </div>
            </div>

            <div>
              <label htmlFor="acceptedInsurances" className="block text-sm font-medium text-gray-700 mb-1">
                Accepted Insurances (comma-separated)
              </label>
              <input
                type="text"
                id="acceptedInsurances"
                name="acceptedInsurances"
                defaultValue={practice?.acceptedInsurances || ""}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., Cigna, Delta Dental, MetLife"
              />
            </div>

            <div>
              <label htmlFor="serviceCostEstimates" className="block text-sm font-medium text-gray-700 mb-1">
                Service Cost Estimates (comma-separated &apos;Service: $Cost&apos;)
              </label>
              <input
                type="text"
                id="serviceCostEstimates"
                name="serviceCostEstimates"
                defaultValue={practice?.serviceCostEstimates || ""}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., Cleaning: $120, Exam: $80, X-Ray: $50"
              />
            </div>
            
            <div className="flex justify-between items-center">
              <button
                type="submit"
                disabled={basicInfoLoading}
                className="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {basicInfoLoading ? 'Saving...' : 'Save Basic Information'}
              </button>
            </div>
          </form>
        </div>

        {/* Webhook Status Section */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold">Webhook Status</h2>
            <button
              onClick={refreshWebhookStatus}
              disabled={webhookLoading}
              className="text-blue-600 hover:text-blue-700 disabled:opacity-50 text-sm"
            >
              {webhookLoading ? 'Refreshing...' : 'Refresh'}
            </button>
          </div>
          
          {webhookStatus ? (
            <div className="space-y-4">
              <div className="flex items-center gap-3">
                {getWebhookStatusIcon(webhookStatus.lastSyncStatus)}
                <span className="font-medium">{getWebhookStatusText(webhookStatus.lastSyncStatus)}</span>
                {webhookStatus.lastSyncAttemptAt && (
                  <span className="text-sm text-gray-500">
                    Last sync: {new Date(webhookStatus.lastSyncAttemptAt).toLocaleString()}
                  </span>
                )}
              </div>
              
              {webhookStatus.lastSyncErrorMessage && (
                <div className="bg-red-50 border border-red-200 rounded-md p-3">
                  <p className="text-red-800 text-sm">{webhookStatus.lastSyncErrorMessage}</p>
                </div>
              )}
              
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-sm">
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.appointment}</div>
                  <div className="text-gray-600">Appointments</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.availability}</div>
                  <div className="text-gray-600">Availability</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.patient}</div>
                  <div className="text-gray-600">Patients</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.provider}</div>
                  <div className="text-gray-600">Providers</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.location}</div>
                  <div className="text-gray-600">Locations</div>
                </div>
              </div>
            </div>
          ) : (
            <div className="text-gray-500">Loading webhook status...</div>
          )}
        </div>

        {practice?.nexhealthSubdomain && practice?.nexhealthLocationId && (
          <>
            {/* Quick Review Section */}
            <div className="mb-6">
              <QuickReview />
            </div>

            {/* Appointment Types Configuration Section */}
            <div className="mb-6">
              <AppointmentTypesConfig
                initialAppointmentTypes={practice.appointmentTypes}
                onUpdate={refreshPracticeData}
              />
            </div>

            {/* Providers Configuration Section */}
            <div className="mb-6">
              <ProvidersConfig
                savedProviders={practice.savedProviders}
                allAppointmentTypes={practice.appointmentTypes}
                allOperatories={practice.savedOperatories}
                onUpdate={refreshPracticeData}
              />
            </div>

            {/* Check Appointment Slots Section */}
            <div className="mb-6">
              <CheckAppointmentSlotsTool
                appointmentTypes={practice.appointmentTypes}
                savedProviders={practice.savedProviders}
                savedOperatories={practice.savedOperatories}
              />
            </div>
          </>
        )}

        {(!practice?.nexhealthSubdomain || !practice?.nexhealthLocationId) && (
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
            <h3 className="text-lg font-semibold text-yellow-800 mb-2">Setup Required</h3>
            <p className="text-yellow-700">
              Please complete the basic information above (NexHealth Subdomain and Location ID) to access the full configuration options.
            </p>
          </div>
        )}
      </div>
    </>
  );
}

================
File: lib/tools/bookAppointment.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import { DateTime } from "luxon";

export const bookAppointmentSchema = z.object({
  selectedTime: z.string()
    .min(1)
    .describe(`Time patient selected from available options. Include AM/PM. Examples: "I'll take 8 AM"  "8:00 AM", "The 2:30 slot"  "2:30 PM"`),
  patientId: z.string()
    .min(1)
    .describe(`CRITICAL: Numeric patient ID (e.g., "381872342") from previous find_patient_in_ehr or create_new_patient tool call. NOT patient name. Required for EHR linking.`),
  appointmentTypeId: z.string()
    .min(1)
    .describe("Appointment type ID from successful find_appointment_type tool call data.appointment_type_id field"),
  requestedDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe("Appointment date in YYYY-MM-DD format from check_available_slots or user input"),
  durationMinutes: z.number()
    .min(1)
    .describe("Appointment duration in minutes from find_appointment_type tool call data.duration_minutes field")
});

const bookAppointmentTool: ToolDefinition<typeof bookAppointmentSchema> = {
  name: "book_appointment",
  description: "Books the actual appointment after patient selects a specific time from available slots. Use after showing available slots and getting patient's time preference.",
  schema: bookAppointmentSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId, callSummaryForNote } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't book appointments right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "I need to assign a provider but none are configured. Please contact the office to complete your booking."
      };
    }

    try {
      console.log(`[bookAppointment] Booking appointment for patient ${args.patientId} on ${args.requestedDate} at ${args.selectedTime}`);

      // Validate patient ID before proceeding
      if (!args.patientId || args.patientId === 'null' || args.patientId === 'undefined' || args.patientId === 'new_patient') {
        return {
          success: false,
          error_code: "INVALID_PATIENT_ID",
          message_to_patient: "I need to verify your patient information before booking. Let me help you with that first.",
          details: `Invalid patient ID provided: ${args.patientId}`
        };
      }

      // Validate that patient ID is numeric (NexHealth requirement)
      if (isNaN(parseInt(args.patientId))) {
        return {
          success: false,
          error_code: "INVALID_PATIENT_ID_FORMAT",
          message_to_patient: "There's an issue with your patient record. Please contact the office to complete your booking.",
          details: `Patient ID must be numeric, received: ${args.patientId}`
        };
      }

      // Validate selected time format
      const timePattern = /^(1[0-2]|[1-9]):([0-5][0-9])\s?(AM|PM)$/i;
      if (!timePattern.test(args.selectedTime.trim())) {
      return {
         success: false,
         error_code: "INVALID_TIME_FORMAT",
         message_to_patient: `I didn't quite catch that time. Could you please choose from the available times I mentioned?`
       };
     }

     // Get practice configuration
     const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
     const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

     if (activeProviders.length === 0) {
       return {
         success: false,
         error_code: "NO_ACTIVE_PROVIDERS",
         message_to_patient: "I need to assign a provider but none are available. Please contact the office to complete your booking."
       };
     }

     // Find the appointment type to help with provider selection
     const appointmentType = practice.appointmentTypes?.find(
       at => at.nexhealthAppointmentTypeId === args.appointmentTypeId
     );

     // IMPROVED LOGIC: Select provider based on accepted appointment types
     let selectedProvider = activeProviders[0]; // Fallback to first
     
     if (appointmentType) {
       // Try to find a provider that accepts this appointment type
       const providersForType = activeProviders.filter(sp => {
         // If no accepted types configured, provider accepts all (backward compatibility)
         if (!sp.acceptedAppointmentTypes || sp.acceptedAppointmentTypes.length === 0) {
           return true;
         }
         // Check if provider accepts this appointment type
         return sp.acceptedAppointmentTypes.some(
           relation => relation.appointmentType.id === appointmentType.id
         );
       });

       if (providersForType.length > 0) {
         selectedProvider = providersForType[0];
       }
     }

     // IMPROVED LOGIC: Select operatory based on provider's default or first available
     let selectedOperatory = activeOperatories[0]; // Fallback

     if (selectedProvider.defaultOperatoryId) {
       const defaultOperatory = activeOperatories.find(
         op => op.id === selectedProvider.defaultOperatoryId
       );
       if (defaultOperatory) {
         selectedOperatory = defaultOperatory;
       }
     }

     if (!selectedOperatory) {
       return {
         success: false,
         error_code: "NO_ACTIVE_OPERATORIES",
         message_to_patient: "I need to assign a room but none are available. Please contact the office to complete your booking."
       };
     }

     // Convert selected time to proper start_time format
     const { startTime } = parseSelectedTimeToNexHealthFormat(
       args.selectedTime,
       args.requestedDate,
       'America/Chicago' // Default practice timezone
     );

     // Get appointment type name for notes
     const appointmentTypeNameForNote = appointmentType?.name || "Appointment";

     let finalNote = `${appointmentTypeNameForNote} - Scheduled via LAINE AI.`;
     if (callSummaryForNote && callSummaryForNote.trim() !== "" && !callSummaryForNote.toLowerCase().includes("failed") && !callSummaryForNote.toLowerCase().includes("not available")) {
       finalNote = `${callSummaryForNote} (Booked via LAINE AI)`;
     } else if (callSummaryForNote) {
       // If summary generation failed or was unavailable, append that info.
       finalNote = `${appointmentTypeNameForNote} - Scheduled via LAINE AI. (${callSummaryForNote})`;
     }
     
     // Ensure note is not excessively long for EHR systems
     if (finalNote.length > 250) { // Example limit, adjust as needed
       finalNote = finalNote.substring(0, 247) + "...";
     }

     // Prepare booking data
     const bookingData = {
       patient_id: parseInt(args.patientId),
       provider_id: parseInt(selectedProvider.provider.nexhealthProviderId),
       appointment_type_id: parseInt(args.appointmentTypeId),
       operatory_id: parseInt(selectedOperatory.nexhealthOperatoryId),
       start_time: startTime,
       note: finalNote
     };

     console.log(`[bookAppointment] Booking data with note:`, JSON.stringify(bookingData, null, 2));

     // Make the booking API call
     const bookingResponse = await fetchNexhealthAPI(
       '/appointments',
       practice.nexhealthSubdomain,
       bookingData,
       'POST'
     );

     if (!bookingResponse?.id) {
       console.error('[bookAppointment] Booking failed: Invalid response format');
       return {
         success: false,
         error_code: "BOOKING_FAILED",
         message_to_patient: "I'm having trouble booking your appointment. Please contact the office to complete your booking."
       };
     }

     // Update call log with booking information
     const appointmentId = bookingResponse.data?.id || bookingResponse.data?.appointment?.id;
     if (appointmentId) {
       await updateCallLogWithBooking(vapiCallId, String(appointmentId), args.requestedDate, args.selectedTime);
     }

     // Format appointment details for confirmation
     const formattedDate = formatDate(args.requestedDate);
     const formattedTime = args.selectedTime;
     const providerName = selectedProvider.provider.firstName ? 
       `${selectedProvider.provider.firstName} ${selectedProvider.provider.lastName || ''}`.trim() : 
       selectedProvider.provider.lastName || 'your provider';
     const appointmentTypeName = appointmentType?.name || "your appointment";

     return {
       success: true,
       message_to_patient: `Excellent! I've successfully booked your ${appointmentTypeName} for ${formattedDate} at ${formattedTime} with ${providerName}. You should receive a confirmation shortly. Is there anything else I can help you with today?`,
       data: {
         appointment_id: String(appointmentId),
         patient_id: args.patientId,
         appointment_type: appointmentTypeName,
         date: args.requestedDate,
         time: args.selectedTime,
         provider_name: providerName,
         booked: true
       }
     };

    } catch (error) {
      console.error(`[bookAppointment] Error:`, error);
      
      return {
        success: false,
        error_code: "BOOKING_ERROR",
        message_to_patient: "I'm having trouble completing your booking right now. Please contact the office directly to schedule your appointment.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me book that appointment for you...",
    success: "Okay, booking processed.",
    fail: "There was an issue with the booking."
  }
};

/**
* Convert patient's selected time to NexHealth API format with proper timezone handling
*/
function parseSelectedTimeToNexHealthFormat(
 selectedTime: string,
 requestedDate: string,
 practiceTimezone: string = 'America/Chicago'
): { startTime: string } {
 // Parse the selected time and date in the practice's timezone
 const localDateTime = DateTime.fromFormat(
   `${requestedDate} ${selectedTime}`,
   'yyyy-MM-dd h:mm a',
   { zone: practiceTimezone }
 );

 if (!localDateTime.isValid) {
   throw new Error(`Invalid date/time format: ${requestedDate} ${selectedTime}. Error: ${localDateTime.invalidReason}`);
 }

 // Convert to UTC and format for NexHealth API
 const startTime = localDateTime.toUTC().toISO({ suppressMilliseconds: true });

 if (!startTime) {
   throw new Error(`Failed to convert to UTC: ${requestedDate} ${selectedTime}`);
 }

 console.log(`[timezone] Converting ${selectedTime} on ${requestedDate} in ${practiceTimezone} to UTC: ${startTime}`);

 return { startTime };
}

/**
* Format date for patient-friendly display
*/
function formatDate(dateString: string): string {
 try {
   const date = new Date(dateString + 'T00:00:00');
   return date.toLocaleDateString('en-US', {
     weekday: 'long',
     month: 'long',
     day: 'numeric'
   });
 } catch {
   return dateString;
 }
}

/**
* Update call log with booking information
*/
async function updateCallLogWithBooking(
 vapiCallId: string,
 appointmentId: string,
 appointmentDate: string,
 appointmentTime: string
) {
 try {
   const { prisma } = await import("@/lib/prisma");
   await prisma.callLog.update({
     where: { vapiCallId },
     data: {
       callStatus: "APPOINTMENT_BOOKED",
       bookedAppointmentNexhealthId: appointmentId,
       summary: `Appointment booked for ${appointmentDate} at ${appointmentTime}`,
       updatedAt: new Date()
     }
   });
 } catch (error) {
   console.error("[bookAppointment] Error updating call log:", error);
 }
}

export default bookAppointmentTool;

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Practice {
  id          String  @id @default(cuid())
  clerkUserId String  @unique // Links to Clerk User ID
  name        String? // Optional practice name entered by user

  // NexHealth specific identifiers for this practice instance
  nexhealthSubdomain  String? // User-provided NexHealth subdomain
  nexhealthLocationId String? // User-provided NexHealth Location ID

  // Webhook synchronization tracking
  webhookLastSyncAt DateTime? // Last time webhooks were synchronized

  // New fields for additional practice information
  address              String? // Practice physical address
  acceptedInsurances   String? // Comma-separated list of accepted insurances
  serviceCostEstimates String? // Service cost estimates string

  // VAPI Assistant relationship - moved to separate config table for better modularity
  assistantConfig               PracticeAssistantConfig? // One-to-one relation
  nexhealthWebhookSubscriptions NexhealthWebhookSubscription[] // One-to-many

  appointmentTypes AppointmentType[]
  providers        Provider[]
  callLogs         CallLog[] // For VAPI call logging
  toolLogs         ToolLog[] // For tool execution logging

  // Add new relationships for scheduling preferences
  savedProviders   SavedProvider[]
  savedOperatories SavedOperatory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A practice is uniquely identified by its Clerk user for our app's purposes.
  // Subdomain + LocationID identify it for NexHealth API calls.
  // If a user could manage multiple NexHealth locations, this model would need adjustment.
  // For now, one Clerk user maps to one set of NexHealth subdomain/locationId.
}

model SavedProvider {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  providerId String // References Provider.id from our synced data
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  isActive Boolean @default(true) // Allow enabling/disabling

  // New fields for provider configuration
  defaultAppointmentTypeId String? // Optional default appointment type for this provider
  defaultAppointmentType   AppointmentType? @relation("DefaultProviderAppointmentType", fields: [defaultAppointmentTypeId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  defaultOperatoryId String? // Optional default operatory for this provider
  defaultOperatory   SavedOperatory? @relation("DefaultProviderOperatory", fields: [defaultOperatoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Relationship to accepted appointment types
  acceptedAppointmentTypes ProviderAcceptedAppointmentType[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, providerId]) // Prevent duplicate saves
  @@map("saved_providers")
}

// Join model for many-to-many relationship between SavedProvider and AppointmentType
model ProviderAcceptedAppointmentType {
  id              String        @id @default(cuid())
  savedProviderId String
  savedProvider   SavedProvider @relation(fields: [savedProviderId], references: [id], onDelete: Cascade)

  appointmentTypeId String // References AppointmentType.id
  appointmentType   AppointmentType @relation("ProviderAcceptedTypes", fields: [appointmentTypeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([savedProviderId, appointmentTypeId]) // Prevent duplicate associations
  @@map("provider_accepted_appointment_types")
}

model SavedOperatory {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthOperatoryId String // NexHealth operatory ID
  name                 String // Display name for operatory
  isActive             Boolean @default(true) // Allow enabling/disabling

  // Reverse relation for default operatory feature
  defaultForProviders SavedProvider[] @relation("DefaultProviderOperatory")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthOperatoryId]) // Prevent duplicate saves
  @@map("saved_operatories")
}

model PracticeAssistantConfig {
  id         String   @id @default(cuid())
  practiceId String   @unique
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  vapiAssistantId String? @unique // The ID of the assistant on VAPI's platform

  // Customizable fields by practice
  voiceProvider String @default("11labs") // e.g., "11labs", "openai", "playht"
  voiceId       String @default("burt") // e.g., "burt" for 11labs, "alloy" for openai
  // voiceModel is often tied to provider/voiceId, can be added if needed

  systemPrompt String @default("You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.")
  firstMessage String @default("Hello! This is Laine from your dental office. How can I help you today?")

  // Potentially store other VAPI settings if customization is expanded
  // serverUrl for tool calls will be derived from NEXT_PUBLIC_APP_URL

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// For storing details about the global NexHealth webhook endpoint managed by the SaaS
model GlobalNexhealthWebhookEndpoint {
  id                  String   @id @default("singleton") // Ensures only one record
  nexhealthEndpointId String   @unique // The ID from NexHealth API after creating the endpoint
  secretKey           String // The secret key provided by NexHealth for this endpoint
  targetUrl           String // The URL registered with NexHealth (e.g., https://laine-integrated.vercel.app/api/nexhealth-webhook)
  isEnabled           Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

// For tracking which practices are subscribed to which NexHealth events
model NexhealthWebhookSubscription {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthWebhookEndpointId String // Foreign key to the global endpoint ID from NexHealth
  nexhealthSubscriptionId    String  @unique // The ID of this specific subscription from NexHealth API
  resourceType               String // e.g., "Appointment", "Patient"
  eventName                  String // e.g., "appointment_insertion.complete", "patient_created"
  isActive                   Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, resourceType, eventName]) // A practice should only have one active sub for a specific event
}

// For VAPI call logging, as per blueprint
model CallLog {
  id         String   @id @default(cuid()) // Or use vapi_call_id as PK if always present early
  vapiCallId String   @unique // From VAPI
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  callTimestampStart DateTime?
  callStatus         String? // e.g., INITIATED, IN_PROGRESS, FORWARDING, ENDED
  transcriptText     String?   @db.Text
  summary            String?   @db.Text // End of call report summary
  vapiTranscriptUrl  String? // URL to audio recording

  // Fields for tracking tool usage and outcomes within a call
  detectedIntent               String?
  nexhealthPatientId           String? // If patient identified/created
  bookedAppointmentNexhealthId String? // If appointment booked

  // Enhanced fields as per refactoring plan
  assistantId         String? // VAPI assistant ID
  endedReason         String? // From end-of-call-report
  callDurationSeconds Int? // Duration in seconds
  cost                Decimal? // Call cost if available

  toolLogs ToolLog[] // One-to-many relationship

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// New model for tracking individual tool executions
model ToolLog {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  vapiCallId String? // Optional - tools might be called outside of calls
  callLog    CallLog? @relation(fields: [vapiCallId], references: [vapiCallId], onDelete: Cascade)

  toolName        String // Name of the tool executed
  toolCallId      String // VAPI tool call ID
  arguments       String? @db.Text // JSON string of (redacted) arguments
  result          String? @db.Text // JSON string of result
  success         Boolean // Whether execution succeeded
  error           String? // Error message if failed
  executionTimeMs Int? // Execution time in milliseconds

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([practiceId, toolName])
  @@index([vapiCallId])
}

model AppointmentType {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthAppointmentTypeId String // ID from NexHealth
  name                       String
  duration                   Int // Duration in minutes (maps to NexHealth 'minutes')
  bookableOnline             Boolean? // Added field for online booking status
  groupCode                  String? // Optional group code for categorizing appointment types

  // Optional: Enhanced tracking fields
  parentType    String? // "Institution" or "Location"
  parentId      String? // ID of the parent
  lastSyncError String? // Error tracking for sync operations

  // Reverse relations for provider configuration
  defaultForProviders SavedProvider[]                   @relation("DefaultProviderAppointmentType")
  acceptedByProviders ProviderAcceptedAppointmentType[] @relation("ProviderAcceptedTypes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthAppointmentTypeId])
}

model Provider {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthProviderId String // ID from NexHealth
  firstName           String?
  lastName            String

  // Add new relationship
  savedByPractices SavedProvider[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthProviderId])
}

model NexhealthTokenCache {
  id          String   @id @default("singleton") // Fixed ID for single token entry
  accessToken String   @db.Text // The bearer token can be long
  expiresAt   DateTime // Timestamp when the token expires
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

================
File: lib/tools/checkAvailableSlots.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Generate current date dynamically for LLM context
function getCurrentDate(): string {
  const today = new Date();
  return today.toISOString().split('T')[0]; // Returns YYYY-MM-DD
}

export const checkAvailableSlotsSchema = z.object({
  requestedDate: z.string()
    .min(1)
    .refine((date) => {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
        return false;
      }
      // Validate it's a real date
      const parsedDate = new Date(date);
      return !isNaN(parsedDate.getTime()) && date === parsedDate.toISOString().split('T')[0];
    }, "Date must be in YYYY-MM-DD format and be a valid date")
    .describe(`Patient's requested date in YYYY-MM-DD format. Today: ${getCurrentDate()}. Examples: "December 23rd"  "2025-12-23", "next Friday"  calculate from ${getCurrentDate()}, "tomorrow"  calculate from ${getCurrentDate()}`),
  appointmentTypeId: z.string().min(1).describe("Appointment type ID from previous find_appointment_type tool call"),
  days: z.number().min(1).max(7).default(1).describe("Number of days to check (default 1)")
});

const checkAvailableSlotsTool: ToolDefinition<typeof checkAvailableSlotsSchema> = {
  name: "check_available_slots",
  description: "Checks available appointment slots for a specific date and appointment type. Use after confirming patient identity and appointment type when patient requests a specific date.",
  schema: checkAvailableSlotsSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't check availability right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "The practice hasn't configured any providers for online scheduling. Please contact the office directly."
      };
    }

    try {
      // Get provider and operatory IDs from practice preferences
      const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
      const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

      if (activeProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "No providers are currently available for online scheduling. Please contact the office."
        };
      }

      // NEW LOGIC: Filter providers who accept this appointment type
      const appointmentType = practice.appointmentTypes?.find(
        at => at.nexhealthAppointmentTypeId === args.appointmentTypeId
      );

      if (!appointmentType) {
        return {
          success: false,
          error_code: "INVALID_APPOINTMENT_TYPE",
          message_to_patient: "I couldn't find that appointment type. Please contact the office for assistance."
        };
      }

      // Filter providers who accept this appointment type
      const eligibleProviders = activeProviders.filter(sp => {
        // If provider has no accepted appointment types configured, include them (backward compatibility)
        if (!sp.acceptedAppointmentTypes || sp.acceptedAppointmentTypes.length === 0) {
          return true;
        }
        // Otherwise, check if they accept this specific appointment type
        return sp.acceptedAppointmentTypes.some(
          relation => relation.appointmentType.id === appointmentType.id
        );
      });

      if (eligibleProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_PROVIDERS_FOR_TYPE",
          message_to_patient: `I don't see any providers available for ${appointmentType.name} appointments. Please contact the office for assistance.`
        };
      }

      // Get provider and operatory arrays from eligible providers
      const providers = eligibleProviders.map(sp => sp.provider.nexhealthProviderId);
      const operatories = activeOperatories.map(so => so.nexhealthOperatoryId);

      // Build search params object for NexHealth API
      const searchParams: Record<string, string | string[]> = {
        subdomain: practice.nexhealthSubdomain,
        start_date: args.requestedDate,
        days: args.days.toString(),
        appointment_type_id: args.appointmentTypeId,
        'lids[]': [practice.nexhealthLocationId],
        'pids[]': providers
      };

      // Add operatory IDs if configured
      if (operatories.length > 0) {
        searchParams['operatory_ids[]'] = operatories;
      }

      const slotsResponse = await fetchNexhealthAPI(
        '/appointment_slots',
        practice.nexhealthSubdomain,
        searchParams
      );

      // Parse response
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const availableSlots: any[] = [];
      
      if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
        // Extract all slots from all providers
        for (const providerData of slotsResponse.data) {
          if (providerData.slots && Array.isArray(providerData.slots)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            availableSlots.push(...providerData.slots.map((slot: any) => ({
              ...slot,
              provider_id: providerData.pid,
              location_id: providerData.lid
            })));
          }
        }
      }

      if (availableSlots.length === 0) {
        // No slots found - let's provide more helpful information
        const appointmentTypeName = practice.appointmentTypes?.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || "that appointment type";
        const friendlyDate = formatDate(args.requestedDate);
        
        let messageToPatient = `I'm sorry, I don't see any available slots for a ${appointmentTypeName} on ${friendlyDate}.`;

        const otherAppointmentTypesExist = (practice.appointmentTypes?.length || 0) > 1;

        if (otherAppointmentTypesExist) {
          messageToPatient += ` Would you like me to check a different date for the ${appointmentTypeName}, or perhaps look at other appointment types for that day?`;
        } else {
          messageToPatient += ` Would you like me to check for ${appointmentTypeName} on a different date?`;
        }

        return {
          success: true,
          message_to_patient: messageToPatient,
          data: {
            requested_date: args.requestedDate,
            requested_appointment_type_id: args.appointmentTypeId,
            appointment_type_name: appointmentTypeName, // Add for context
            available_slots: [],
            has_availability: false,
            debug_info: {
              providers_checked: providers.length,
              operatories_checked: operatories.length,
              appointment_type_name: appointmentTypeName
            }
          }
        };
      }

      // Format slots for patient-friendly display
      const formattedSlots = availableSlots.slice(0, 8).map((slot, index) => {
        // Parse the time string correctly to preserve the timezone
        const startTime = new Date(slot.time);
        
        // Use the timezone from the original date string for formatting
        const timeString = startTime.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
          timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
        });
        
        return {
          slot_id: `slot_${index}`,
          time: slot.time,
          end_time: slot.end_time,
          display_time: timeString,
          operatory_id: slot.operatory_id,
          provider_id: slot.provider_id,
          location_id: slot.location_id
        };
      });

      // Create more conversational message with appointment type and limited initial options
      const appointmentTypeName = practice.appointmentTypes?.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || "your appointment";
      const friendlyDate = formatDate(args.requestedDate);

      // Offer a limited number of slots initially for voice, e.g., 3 or 4
      const slotsToOfferCount = Math.min(formattedSlots.length, 3); // Offer up to 3 slots
      const offeredTimeList = formattedSlots.slice(0, slotsToOfferCount).map(slot => slot.display_time);
      
      let timeOptionsMessage = "";
      if (offeredTimeList.length === 1) {
        timeOptionsMessage = offeredTimeList[0];
      } else if (offeredTimeList.length > 1) {
        timeOptionsMessage = offeredTimeList.slice(0, -1).join(', ') + (offeredTimeList.length > 1 ? ', or ' : '') + offeredTimeList[offeredTimeList.length - 1];
      }

      let finalMessageToPatient = `Great! For a ${appointmentTypeName} on ${friendlyDate}, I have ${timeOptionsMessage} available.`;

      if (formattedSlots.length > slotsToOfferCount) {
        finalMessageToPatient += " Do any of those work, or would you like to hear more options?";
      } else {
        finalMessageToPatient += " Do any of those times work for you?";
      }

      return {
        success: true,
        message_to_patient: finalMessageToPatient,
        data: {
          requested_date: args.requestedDate,
          requested_appointment_type_id: args.appointmentTypeId,
          appointment_type_name: appointmentTypeName,
          available_slots: formattedSlots,
          has_availability: true,
          total_slots_found: availableSlots.length,
          slots_offered: slotsToOfferCount
        }
      };

    } catch (error) {
      console.error(`[checkAvailableSlots] Error:`, error);
      
      return {
        success: false,
        error_code: "SLOT_CHECK_ERROR",
        message_to_patient: "I'm having trouble checking availability right now. Please contact the office for scheduling assistance.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check what's available...",
    success: "Okay, availability check processed.",
    fail: "There was an issue checking availability."
  }
};

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  });
}

export default checkAvailableSlotsTool;




================================================================
End of Codebase
================================================================
