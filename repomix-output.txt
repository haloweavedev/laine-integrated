This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/api/vapi, app/api/vapi-webhook, app/laine, app/tool-call-log, app/tool-calls, lib/ai, lib/system-prompt, lib/tool-handlers, prisma/schema.prisma, types, app/test, lib/tools
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    vapi/
      webhook/
        route.ts
    vapi-webhook/
      route.ts
  laine/
    laine-practice-client.tsx
    page.tsx
  test/
    actions.ts
    page.tsx
    test-client.tsx
  tool-call-log/
    page.tsx
  tool-calls/
    page.tsx
lib/
  ai/
    acknowledgmentGenerator.ts
    appointmentMatcher.ts
    insuranceResponseGenerator.ts
    slotHelper.ts
    slotMatcher.ts
    summaryHelper.ts
  system-prompt/
    laine_system_prompt.md
  tool-handlers/
    checkAvailableSlotsHandler.ts
    findAppointmentTypeHandler.ts
    identifyPatientHandler.ts
    insuranceInfoHandler.ts
    selectAndBookSlotHandler.ts
  tools/
    definitions/
      checkAvailableSlotsTool.ts
      findAppointmentTypeTool.ts
      identifyPatientTool.ts
      insuranceInfoTool.ts
      selectAndBookSlotTool.ts
    index.ts
prisma/
  schema.prisma
types/
  laine.ts
  vapi.ts

================================================================
Files
================================================================

================
File: app/laine/laine-practice-client.tsx
================
"use client";

import { useState, useEffect } from "react";
import { toast } from "sonner";

interface Practice {
  id: string;
  name: string | null;
  assistantConfig: {
    id: string;
    vapiAssistantId: string | null;
    voiceProvider: string;
    voiceId: string;
    systemPrompt: string;
    firstMessage: string;
  } | null;
}

interface ToolResult {
  message_to_patient?: string;
  error_code?: string;
  details?: string;
  success?: boolean;
  data?: Record<string, unknown>;
  [key: string]: unknown;
}

interface ToolLog {
  id: string;
  toolName: string;
  arguments: Record<string, unknown> | null;
  result: ToolResult | null;
  success: boolean;
  error: string | null;
  executionTimeMs: number | null;
  createdAt: string;
  toolCallId: string;
}

interface LainePracticeClientProps {
  practice: Practice;
  hasAssistant: boolean;
  createPracticeAssistant: () => Promise<void>;
}

export function LainePracticeClient({ practice, hasAssistant, createPracticeAssistant }: LainePracticeClientProps) {
  const [voiceProvider, setVoiceProvider] = useState(practice.assistantConfig?.voiceProvider || "vapi");
  const [voiceId, setVoiceId] = useState(practice.assistantConfig?.voiceId || "Elliot");
  const [systemPrompt, setSystemPrompt] = useState(practice.assistantConfig?.systemPrompt || "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.");
  const [firstMessage, setFirstMessage] = useState(practice.assistantConfig?.firstMessage || "Hello! This is Laine from your dental office. How can I help you today?");
  const [isUpdating, setIsUpdating] = useState(false);
  const [toolLogs, setToolLogs] = useState<ToolLog[]>([]);
  const [isLoadingLogs, setIsLoadingLogs] = useState(true);
  const [callId, setCallId] = useState<string | null>(null);

  useEffect(() => {
    const fetchLogs = async () => {
      setIsLoadingLogs(true);
      try {
        const response = await fetch('/api/laine-config/recent-tool-logs');
        if (response.ok) {
          const data = await response.json();
          setToolLogs(data.logs || []);
          setCallId(data.callId || null);
        } else {
          toast.error("Failed to fetch recent tool logs.");
        }
      } catch (error) {
        console.error("Error fetching tool logs:", error);
        toast.error("Error fetching tool logs.");
      } finally {
        setIsLoadingLogs(false);
      }
    };
    fetchLogs();
  }, []);

  const handleUpdateConfig = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsUpdating(true);

    try {
      const response = await fetch('/api/laine-config/update', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          voiceProvider,
          voiceId,
          systemPrompt,
          firstMessage,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update assistant configuration');
      }

      toast.success("Assistant configuration updated successfully!");
    } catch (error) {
      console.error('Error updating assistant configuration:', error);
      toast.error(`Failed to update assistant configuration. ${error instanceof Error ? error.message : 'Please try again.'}`);
    } finally {
      setIsUpdating(false);
    }
  };

  if (!hasAssistant) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">Create Your AI Assistant</h2>
        <p className="text-gray-600 mb-6">
          Create a personalized AI assistant for your practice. Laine will help patients with basic inquiries,
          patient lookups, and appointment scheduling.
        </p>
        
        <form action={createPracticeAssistant}>
          <button
            type="submit"
            className="bg-blue-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-blue-700 transition-colors"
          >
            Create Laine Assistant
          </button>
        </form>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-6">Configure Your AI Assistant</h2>
      
      <form onSubmit={handleUpdateConfig} className="space-y-6">
        <div>
          <label htmlFor="voiceProvider" className="block text-sm font-medium text-gray-700 mb-2">
            Voice Provider
          </label>
          <select
            id="voiceProvider"
            name="voiceProvider"
            value={voiceProvider}
            onChange={(e) => setVoiceProvider(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="vapi">VAPI (Recommended)</option>
            <option value="11labs">ElevenLabs</option>
            <option value="openai">OpenAI</option>
            <option value="playht">PlayHT</option>
          </select>
        </div>

        <div>
          <label htmlFor="voiceId" className="block text-sm font-medium text-gray-700 mb-2">
            Voice ID
          </label>
          <input
            type="text"
            id="voiceId"
            name="voiceId"
            value={voiceId}
            onChange={(e) => setVoiceId(e.target.value)}
            placeholder="e.g., Elliot, Kylie (VAPI), burt (ElevenLabs), alloy (OpenAI)"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <p className="text-sm text-gray-500 mt-1">
            <strong>VAPI:</strong> Elliot, Kylie &nbsp;|&nbsp; 
            <strong>ElevenLabs:</strong> burt &nbsp;|&nbsp; 
            <strong>OpenAI:</strong> alloy, echo, fable, onyx, nova, shimmer
          </p>
        </div>

        <div>
          <label htmlFor="systemPrompt" className="block text-sm font-medium text-gray-700 mb-2">
            System Prompt
          </label>
          <textarea
            id="systemPrompt"
            name="systemPrompt"
            rows={4}
            value={systemPrompt}
            onChange={(e) => setSystemPrompt(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Instructions that define how the AI should behave..."
          />
          <p className="text-sm text-gray-500 mt-1">
            Define how Laine should behave and what it should know about your practice
          </p>
        </div>

        <div>
          <label htmlFor="firstMessage" className="block text-sm font-medium text-gray-700 mb-2">
            First Message
          </label>
          <input
            type="text"
            id="firstMessage"
            name="firstMessage"
            value={firstMessage}
            onChange={(e) => setFirstMessage(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Hello! This is Laine from your dental office..."
          />
          <p className="text-sm text-gray-500 mt-1">
            The first thing Laine says when answering a call
          </p>
        </div>

        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-500">
            Assistant ID: {practice.assistantConfig?.vapiAssistantId}
          </div>
          <button
            type="submit"
            disabled={isUpdating}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isUpdating ? 'Updating...' : 'Update Configuration'}
          </button>
        </div>
      </form>

      <div className="mt-8 p-4 bg-gray-50 rounded-lg">
        <h3 className="font-medium text-gray-900 mb-2">Available Tools (8)</h3>
        <ul className="text-sm text-gray-600 space-y-1 list-disc list-inside">
          <li>find_patient_in_ehr - Searches for existing patients.</li>
          <li>create_new_patient - Creates new patient records (now with optional insurance name).</li>
          <li>find_appointment_type - Matches patient requests to appointment types.</li>
          <li>check_available_slots - Finds available appointment times.</li>
          <li>book_appointment - Books the selected appointment.</li>
          <li>check_insurance_participation - Checks if practice accepts patient&apos;s insurance.</li>
          <li>get_service_cost_estimate - Provides estimated service costs.</li>
          <li>get_practice_details - Retrieves practice address and other details.</li>
        </ul>
      </div>

      {/* Recent Tool Call Activity Section */}
      <div className="mt-8 p-4 bg-blue-50 rounded-lg">
        <h3 className="font-medium text-gray-900 mb-4">Recent Tool Call Activity</h3>
        {isLoadingLogs && (
          <p className="text-sm text-gray-600">Loading recent activity...</p>
        )}
        {!isLoadingLogs && toolLogs.length === 0 && (
          <p className="text-sm text-gray-600">No recent tool call activity found.</p>
        )}
        {!isLoadingLogs && toolLogs.length > 0 && (
          <div className="space-y-4">
            {callId && (
              <p className="text-xs text-gray-500 mb-3">
                Call ID: {callId} • {toolLogs.length} tool{toolLogs.length !== 1 ? 's' : ''} executed
              </p>
            )}
            {toolLogs.map((log) => (
              <div key={log.id} className="p-3 bg-white rounded border border-gray-200">
                <div className="flex justify-between items-start mb-2">
                  <h4 className="font-semibold text-sm text-gray-900">{log.toolName}</h4>
                  <div className="flex items-center space-x-2 text-xs text-gray-500">
                    <span className={`px-2 py-1 rounded ${log.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                      {log.success ? 'Success' : 'Failed'}
                    </span>
                    <span>{new Date(log.createdAt).toLocaleTimeString()}</span>
                    {log.executionTimeMs && <span>{log.executionTimeMs}ms</span>}
                  </div>
                </div>
                
                {/* Arguments */}
                {log.arguments && (
                  <div className="mb-2">
                    <p className="text-xs font-medium text-gray-700 mb-1">Arguments:</p>
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(log.arguments, null, 2)}
                    </pre>
                  </div>
                )}

                {/* Result */}
                {log.result && (
                  <div className="mb-2">
                    <p className="text-xs font-medium text-gray-700 mb-1">Result:</p>
                    {log.result?.message_to_patient && (
                      <p className="text-sm italic text-blue-600 mb-1">
                        To Patient: &quot;{log.result.message_to_patient}&quot;
                      </p>
                    )}
                    {log.result?.error_code && (
                      <p className="text-sm text-red-600 mb-1">
                        Error: {log.result.error_code} - {log.result.details || 'No details'}
                      </p>
                    )}
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(log.result, null, 2)}
                    </pre>
                  </div>
                )}

                {/* Error (if failed) */}
                {log.error && (
                  <div className="text-xs text-red-600 bg-red-50 p-2 rounded">
                    <strong>Error:</strong> {log.error}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: app/test/actions.ts
================
"use server";

import { prisma } from "@/lib/prisma";
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export interface LatestCallLogData {
  vapiCallId: string;
  transcriptText: string | null;
  recordingUrl: string | null; // Ensure this field exists or is mapped correctly in CallLog
  endedReason: string | null;
  callStatus: string | null;
  summary: string | null;
  createdAt: Date;
}

export async function getAssistantPhoneNumber(assistantId: string): Promise<string | null> {
  if (!process.env.VAPI_API_KEY) {
    console.error("VAPI_API_KEY (private key) not set for fetching phone number.");
    return null;
  }
  
  const url = `https://api.vapi.ai/phone-number?assistantId=${encodeURIComponent(assistantId)}`;
  console.log(`[getAssistantPhoneNumber] Fetching URL: ${url}`);

  try {
    const response = await fetch(url, {
      method: 'GET', // Explicitly set GET, though it's default
      headers: { 
        'Authorization': `Bearer ${process.env.VAPI_API_KEY}`,
        // Don't include Content-Type for GET requests
      }
      // Ensure no 'body' property is present for a GET request
    });

    if (!response.ok) {
      const errorBodyText = await response.text();
      console.error(`[getAssistantPhoneNumber] Failed to fetch phone numbers from Vapi. Status: ${response.status}, Body: ${errorBodyText}`);
      
      // Log the specific error message from Vapi if it's JSON
      try {
        const errorJson = JSON.parse(errorBodyText);
        console.error("[getAssistantPhoneNumber] Vapi error JSON:", errorJson);
      } catch {
        // Not JSON, already logged as text
      }
      
      // If the assistantId filter fails, try fetching all phone numbers and filter client-side
      if (response.status === 400 && errorBodyText.includes('assistantId')) {
        console.log("[getAssistantPhoneNumber] assistantId query parameter failed, trying fallback approach...");
        return await getPhoneNumberFallback(assistantId);
      }
      
      return null;
    }

    const data = await response.json();
    console.log("[getAssistantPhoneNumber] Vapi response data:", data);

    if (Array.isArray(data) && data.length > 0 && data[0].number) {
      console.log(`[getAssistantPhoneNumber] Found phone number: ${data[0].number}`);
      return data[0].number;
    } else if (Array.isArray(data) && data.length === 0) {
      console.log(`[getAssistantPhoneNumber] No phone numbers found associated with assistantId: ${assistantId}`);
      return null;
    } else {
      console.warn(`[getAssistantPhoneNumber] Unexpected data structure from Vapi:`, data);
      return null;
    }
  } catch (error) {
    console.error("[getAssistantPhoneNumber] Error fetching assistant phone number from Vapi:", error);
    return null;
  }
}

// Fallback function to fetch all phone numbers and filter by assistant ID
async function getPhoneNumberFallback(assistantId: string): Promise<string | null> {
  console.log(`[getPhoneNumberFallback] Fetching all phone numbers and filtering for assistantId: ${assistantId}`);
  
  try {
    const response = await fetch('https://api.vapi.ai/phone-number', {
      method: 'GET',
      headers: { 
        'Authorization': `Bearer ${process.env.VAPI_API_KEY}`,
      }
    });

    if (!response.ok) {
      const errorBodyText = await response.text();
      console.error(`[getPhoneNumberFallback] Failed to fetch all phone numbers from Vapi. Status: ${response.status}, Body: ${errorBodyText}`);
      return null;
    }

    const data = await response.json();
    console.log("[getPhoneNumberFallback] All phone numbers response:", data);

    if (Array.isArray(data)) {
      // Look for a phone number object that has the matching assistant ID
      const matchingPhone = data.find(phoneObj => {
        // The structure might vary, check common paths
        return phoneObj.assistantId === assistantId || 
               phoneObj.assistant?.id === assistantId ||
               phoneObj.assistant === assistantId;
      });
      
      if (matchingPhone && matchingPhone.number) {
        console.log(`[getPhoneNumberFallback] Found matching phone number: ${matchingPhone.number}`);
        return matchingPhone.number;
      } else {
        console.log(`[getPhoneNumberFallback] No phone number found for assistantId: ${assistantId}`);
        return null;
      }
    } else {
      console.warn("[getPhoneNumberFallback] Unexpected response structure from all phone numbers API:", data);
      return null;
    }
  } catch (error) {
    console.error("[getPhoneNumberFallback] Error in fallback phone number fetch:", error);
    return null;
  }
}

export async function getLatestCallLogForPractice(practiceId: string): Promise<LatestCallLogData | null> {
  try {
    const latestCallLog = await prisma.callLog.findFirst({
      where: { practiceId: practiceId },
      orderBy: { createdAt: 'desc' },
      select: {
        vapiCallId: true,
        transcriptText: true,
        vapiTranscriptUrl: true, // Assuming this stores the recording URL. If not, adjust.
                                 // Let's rename to recordingUrl for clarity if it's audio.
        endedReason: true,
        callStatus: true,
        summary: true,
        createdAt: true
      }
    });

    if (latestCallLog) {
      return {
        ...latestCallLog,
        // If vapiTranscriptUrl is indeed the recording URL, map it here for clarity
        // or ensure the schema/population logic is correct.
        // For now, let's assume it's correct and the client will use it.
        // If it's not, we'll need to adjust how 'recordingUrl' is populated.
        // For the purpose of this prompt, let's assume vapiTranscriptUrl IS the recordingUrl.
        recordingUrl: latestCallLog.vapiTranscriptUrl 
      };
    }
    return null;
  } catch (error) {
    console.error("Error fetching latest call log:", error);
    return null;
  }
}

export async function getPracticeAndAssistantId() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in"); // Or handle as an error
  }

  const practiceWithConfig = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practiceWithConfig) {
    // This case should ideally redirect to a setup page if practice doesn't exist
    console.warn(`No practice found for clerkUserId: ${userId}. Redirecting to /practice-config.`);
    redirect("/practice-config");
  }
  if (!practiceWithConfig.assistantConfig?.vapiAssistantId) {
    console.warn(`No Vapi assistant configured for practiceId: ${practiceWithConfig.id}. Redirecting to /laine.`);
    redirect('/laine');
  }
  
  return {
    practiceId: practiceWithConfig.id,
    vapiAssistantId: practiceWithConfig.assistantConfig.vapiAssistantId,
  };
}

================
File: app/test/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getAssistantPhoneNumber, getLatestCallLogForPractice, getPracticeAndAssistantId, LatestCallLogData } from "./actions";
import { TestClient } from "./test-client"; // We will create this next

export default async function TestPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  let practiceId: string;
  let vapiAssistantId: string;
  let phoneNumber: string | null = null;
  let latestCallLog: LatestCallLogData | null = null;

  try {
    const assistantInfo = await getPracticeAndAssistantId();
    practiceId = assistantInfo.practiceId;
    vapiAssistantId = assistantInfo.vapiAssistantId;

    phoneNumber = await getAssistantPhoneNumber(vapiAssistantId);
    latestCallLog = await getLatestCallLogForPractice(practiceId);
  } catch (error) {
    // Errors during data fetching (e.g., redirects from actions) will be handled by Next.js
    // If an error is thrown and not a redirect, it will bubble up.
    // For simplicity, we assume redirects handle missing setup.
    // If not redirecting, render an error message or a link to setup.
    if (error instanceof Error && (error as { digest?: string }).digest?.startsWith('NEXT_REDIRECT')) {
      throw error; // Re-throw redirect errors
    }
    console.error("Error fetching data for /test page:", error);
    // Render a fallback or error state if necessary
    return (
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-4">Error Loading Test Page</h1>
        <p>Could not load necessary information. Please ensure your practice and Laine assistant are configured.</p>
        <p>Error: {error instanceof Error ? error.message : "Unknown error"}</p>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6 text-slate-800">Laine Assistant Test Center</h1>
      <TestClient
        vapiAssistantId={vapiAssistantId}
        initialPhoneNumber={phoneNumber}
        initialLatestCallLog={latestCallLog}
      />
    </div>
  );
}

================
File: app/tool-calls/page.tsx
================
import { promises as fs } from 'fs';
import path from 'path';
import { Metadata } from 'next';

// Simple markdown-to-HTML converter
function markdownToHtml(markdown: string): string {
  return markdown
    // Headers
    .replace(/^# (.*$)/gm, '<h1 class="text-3xl font-bold mb-6 text-gray-900">$1</h1>')
    .replace(/^## (.*$)/gm, '<h2 class="text-2xl font-semibold mb-4 mt-8 text-gray-800">$1</h2>')
    .replace(/^### (.*$)/gm, '<h3 class="text-xl font-semibold mb-3 mt-6 text-gray-700">$1</h3>')
    .replace(/^#### (.*$)/gm, '<h4 class="text-lg font-semibold mb-2 mt-4 text-gray-600">$1</h4>')
    
    // Code blocks
    .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre class="bg-gray-100 rounded-lg p-4 mb-4 overflow-x-auto"><code class="text-sm">$2</code></pre>')
    .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-2 py-1 rounded text-sm font-mono">$1</code>')
    
    // Lists
    .replace(/^- (.*$)/gm, '<li class="mb-1">$1</li>')
    .replace(/(<li.*<\/li>\n?)+/g, '<ul class="list-disc pl-6 mb-4">$&</ul>')
    .replace(/^\d+\. (.*$)/gm, '<li class="mb-1">$1</li>')
    
    // Bold and italic
    .replace(/\*\*([^*]+)\*\*/g, '<strong class="font-semibold">$1</strong>')
    .replace(/\*([^*]+)\*/g, '<em class="italic">$1</em>')
    
    // Links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-600 hover:text-blue-800 underline">$1</a>')
    
    // Blockquotes (for the message examples)
    .replace(/^> (.*$)/gm, '<blockquote class="border-l-4 border-blue-500 pl-4 py-2 mb-4 bg-blue-50 italic text-gray-700">$1</blockquote>')
    
    // Horizontal rules
    .replace(/^---$/gm, '<hr class="my-8 border-gray-300">')
    
    // Paragraphs
    .replace(/\n\n/g, '</p><p class="mb-4">')
    .replace(/^(.+)$/gm, '<p class="mb-4">$1</p>')
    
    // Clean up empty paragraphs and fix nested HTML
    .replace(/<p class="mb-4"><\/p>/g, '')
    .replace(/<p class="mb-4">(<h[1-6])/g, '$1')
    .replace(/(<\/h[1-6]>)<\/p>/g, '$1')
    .replace(/<p class="mb-4">(<ul|<ol|<pre|<blockquote|<hr)/g, '$1')
    .replace(/(<\/ul>|<\/ol>|<\/pre>|<\/blockquote>|<hr[^>]*>)<\/p>/g, '$1');
}

export const metadata: Metadata = {
  title: 'Tool Calls System - LAINE Documentation',
  description: 'Comprehensive documentation of the LAINE AI Assistant tool call system and API integration',
};

export default async function ToolCallsPage() {
  try {
    const filePath = path.join(process.cwd(), 'docs', 'tool-calls-system.md');
    const fileContent = await fs.readFile(filePath, 'utf8');
    const htmlContent = markdownToHtml(fileContent);

    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-4xl mx-auto px-6 py-12">
          {/* Header */}
          <div className="mb-8 border-b border-gray-200 pb-6">
            <h1 className="text-4xl font-bold text-gray-900 mb-2">
              Tool Calls System Documentation
            </h1>
            <p className="text-gray-600 text-lg">
              Technical overview of the LAINE AI Assistant tool call architecture, API integration, and workflow management
            </p>
          </div>

          {/* Table of Contents */}
          <div className="mb-12 bg-gray-50 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4 text-gray-800">Quick Navigation</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
              <div>
                <h3 className="font-semibold text-gray-700 mb-2">Core System</h3>
                <ul className="space-y-1 text-gray-600">
                  <li><a href="#webhook-handler-apivapitool-calls" className="hover:text-blue-600">• Webhook Handler</a></li>
                  <li><a href="#tool-system-architecture" className="hover:text-blue-600">• Tool Architecture</a></li>
                  <li><a href="#integration-features" className="hover:text-blue-600">• Integration Features</a></li>
                </ul>
              </div>
              <div>
                <h3 className="font-semibold text-gray-700 mb-2">Tool Categories</h3>
                <ul className="space-y-1 text-gray-600">
                  <li><a href="#1-patient-management-tools" className="hover:text-blue-600">• Patient Management</a></li>
                  <li><a href="#2-appointment-discovery-tools" className="hover:text-blue-600">• Appointment Discovery</a></li>
                  <li><a href="#3-financial-tools" className="hover:text-blue-600">• Financial Tools</a></li>
                  <li><a href="#4-booking--information-tools" className="hover:text-blue-600">• Booking & Information</a></li>
                </ul>
              </div>
            </div>
          </div>

          {/* Main Content */}
          <div 
            className="prose prose-lg max-w-none"
            dangerouslySetInnerHTML={{ __html: htmlContent }}
          />

          {/* Footer */}
          <div className="mt-16 pt-8 border-t border-gray-200">
            <div className="bg-blue-50 rounded-lg p-6">
              <h3 className="text-lg font-semibold text-blue-900 mb-2">
                System Status
              </h3>
              <p className="text-blue-800 mb-3">
                The LAINE tool call system is currently in production with full NexHealth integration.
              </p>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <strong className="text-blue-900">Active Tools:</strong> 8/8
                </div>
                <div>
                  <strong className="text-blue-900">Current Phase:</strong> 1.4 (Universal Dynamic Messages)
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  } catch (error) {
    console.error('Error reading markdown file:', error);
    
    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-4xl mx-auto px-6 py-12">
          <div className="text-center">
            <h1 className="text-3xl font-bold text-gray-900 mb-4">
              Tool Calls Documentation
            </h1>
            <div className="bg-red-50 border border-red-200 rounded-lg p-6">
              <p className="text-red-800">
                Error loading documentation. Please ensure the markdown file exists at docs/tool-calls-system.md
              </p>
            </div>
          </div>
        </div>
      </div>        
    );
  }
}

================
File: app/api/vapi/webhook/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { verifyVapiRequest } from "@/lib/vapi";
import { prisma } from "@/lib/prisma";
import type { VapiWebhookPayload, VapiStatusUpdateMessage, VapiEndOfCallReportMessage, VapiTranscriptMessage } from "@/types/vapi";

export async function POST(request: NextRequest) {
  console.log("=== VAPI General Webhook Handler ===");
  
  try {
    // Verify the webhook (when VAPI supports request signing)
    const verification = await verifyVapiRequest();
    if (!verification.verified) {
      console.error("VAPI webhook verification failed:", verification.error);
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Parse the JSON body and type it properly
    const body: VapiWebhookPayload = await request.json();
    
    // Correctly extract the message type from body.message.type
    const messageType = body.message?.type;

    console.log("=== VAPI General Webhook Handler ===");
    console.log("[VAPI] Request verification - not yet implemented"); 
    console.log("VAPI webhook message type:", messageType);
    console.log("VAPI webhook payload:", JSON.stringify(body, null, 2));

    if (!messageType) {
      console.error("[VAPI Webhook] Message type is missing or undefined in payload.");
      return NextResponse.json({ error: "Malformed VAPI webhook payload: message.type missing." }, { status: 400 });
    }

    // Handle different webhook types based on message.type
    switch (messageType) {
      case "status-update":
        await handleStatusUpdate(body.message as VapiStatusUpdateMessage);
        break;
      
      case "end-of-call-report":
        await handleEndOfCallReport(body.message as VapiEndOfCallReportMessage);
        break;
      
      case "transcript":
        await handleTranscript(body.message as VapiTranscriptMessage);
        break;
      
      default:
        console.log(`[VAPI Webhook] Received unhandled message type: ${messageType}`);
    }

    return NextResponse.json({ success: true, message: `Webhook type ${messageType} received.` }, { status: 200 });
  } catch (error) {
    console.error("[VAPI Webhook] Error processing webhook:", error);
    return NextResponse.json({ error: "Failed to process webhook" }, { status: 500 });
  }
}

async function handleStatusUpdate(message: VapiStatusUpdateMessage) {
  console.log(`[VAPI Webhook] Received status-update. Status: ${message.call?.status}, Ended Reason: ${message.call?.endedReason}`);
  
  try {
    if (!message.call) {
      console.error("No call data in status update payload");
      return;
    }

    // Find practice by assistant ID
    const practice = await findPracticeByAssistantId(message.call.assistantId);
    if (!practice) {
      console.error("Practice not found for assistant:", message.call.assistantId);
      return;
    }

    // Update or create call log
    await prisma.callLog.upsert({
      where: { vapiCallId: message.call.id },
      create: {
        vapiCallId: message.call.id,
        practiceId: practice.id,
        assistantId: message.call.assistantId,
        callTimestampStart: message.call.startedAt ? new Date(message.call.startedAt) : null,
        callStatus: message.call.status,
      },
      update: {
        callStatus: message.call.status,
        assistantId: message.call.assistantId,
        updatedAt: new Date()
      }
    });

    console.log(`[VAPI Webhook] Updated call status for ${message.call.id}: ${message.call.status}`);
    
    // TODO: Enhanced status handling - if (message.call.status === 'ended' && message.call.endedReason) {
    //   await prisma.callLog.updateMany({ 
    //     where: { vapiCallId: message.call.id }, 
    //     data: { 
    //       callStatus: 'ENDED', 
    //       endedReason: message.call.endedReason, 
    //       updatedAt: new Date() 
    //     }
    //   });
    // }
  } catch (error) {
    console.error("[VAPI Webhook] Error handling status update:", error);
  }
}

async function handleEndOfCallReport(message: VapiEndOfCallReportMessage) {
  console.log(`[VAPI Webhook] Received end-of-call-report. Call ID: ${message.call?.id}`);
  
  try {
    if (!message.call) {
      console.error("[VAPI Webhook] No call data in end-of-call-report payload");
      return;
    }

    // Find practice by assistant ID
    const practice = await findPracticeByAssistantId(message.call.assistantId);
    if (!practice) {
      console.error("[VAPI Webhook] Practice not found for assistant:", message.call.assistantId);
      return;
    }

    // Update call log with final details
    await prisma.callLog.upsert({
      where: { vapiCallId: message.call.id },
      create: {
        vapiCallId: message.call.id,
        practiceId: practice.id,
        assistantId: message.call.assistantId,
        callTimestampStart: message.call.startedAt ? new Date(message.call.startedAt) : null,
        callStatus: "ENDED",
        endedReason: message.call.endedReason,
        callDurationSeconds: message.call.startedAt && message.call.endedAt 
          ? Math.round((new Date(message.call.endedAt).getTime() - new Date(message.call.startedAt).getTime()) / 1000)
          : null,
        cost: message.call.cost ? parseFloat(message.call.cost) : null,
        summary: message.summary,
        vapiTranscriptUrl: message.transcript?.url,
      },
      update: {
        callStatus: "ENDED",
        endedReason: message.call.endedReason,
        callDurationSeconds: message.call.startedAt && message.call.endedAt 
          ? Math.round((new Date(message.call.endedAt).getTime() - new Date(message.call.startedAt).getTime()) / 1000)
          : null,
        cost: message.call.cost ? parseFloat(message.call.cost) : null,
        summary: message.summary,
        vapiTranscriptUrl: message.transcript?.url,
        updatedAt: new Date()
      }
    });

    console.log(`[VAPI Webhook] Updated end of call report for ${message.call.id}`);
    
    // TODO: Additional end-of-call processing - if (message.call.id && message.summary) {
    //   await prisma.callLog.updateMany({ 
    //     where: { vapiCallId: message.call.id }, 
    //     data: { 
    //       summary: message.summary, 
    //       cost: message.call.cost ? parseFloat(message.call.cost) : null,
    //       callDurationSeconds: message.call.startedAt && message.call.endedAt 
    //         ? Math.round((new Date(message.call.endedAt).getTime() - new Date(message.call.startedAt).getTime()) / 1000)
    //         : null,
    //       updatedAt: new Date() 
    //     }
    //   });
    // }
  } catch (error) {
    console.error("[VAPI Webhook] Error handling end of call report:", error);
  }
}

async function handleTranscript(message: VapiTranscriptMessage) {
  console.log(`[VAPI Webhook] Received transcript update. Call ID: ${message.call?.id}`);
  
  try {
    if (!message.call) {
      console.error("[VAPI Webhook] No call data in transcript payload");
      return;
    }

    // Find practice by assistant ID
    const practice = await findPracticeByAssistantId(message.call.assistantId);
    if (!practice) {
      console.error("[VAPI Webhook] Practice not found for assistant:", message.call.assistantId);
      return;
    }

    // Update call log with transcript
    await prisma.callLog.upsert({
      where: { vapiCallId: message.call.id },
      create: {
        vapiCallId: message.call.id,
        practiceId: practice.id,
        assistantId: message.call.assistantId,
        callTimestampStart: message.call.startedAt ? new Date(message.call.startedAt) : null,
        callStatus: message.call.status || "IN_PROGRESS",
        transcriptText: message.transcript?.text,
      },
      update: {
        transcriptText: message.transcript?.text,
        updatedAt: new Date()
      }
    });

    console.log(`[VAPI Webhook] Updated transcript for ${message.call.id}`);
    
    // TODO: Enhanced transcript handling - if (message.call.id && message.transcript?.text) {
    //   await prisma.callLog.updateMany({ 
    //     where: { vapiCallId: message.call.id }, 
    //     data: { 
    //       transcriptText: message.transcript.text, 
    //       updatedAt: new Date() 
    //     }
    //   });
    // }
  } catch (error) {
    console.error("[VAPI Webhook] Error handling transcript:", error);
  }
}

async function findPracticeByAssistantId(assistantId: string) {
  if (!assistantId) {
    console.error("No assistant ID provided");
    return null;
  }

  try {
    const assistantConfig = await prisma.practiceAssistantConfig.findUnique({
      where: { vapiAssistantId: assistantId },
      include: { practice: true }
    });

    if (!assistantConfig) {
      console.error(`No practice found for assistant ID: ${assistantId}`);
      return null;
    }

    return assistantConfig.practice;
  } catch (error) {
    console.error("Error finding practice by assistant ID:", error);
    return null;
  }
}

================
File: lib/tool-handlers/selectAndBookSlotHandler.ts
================
import { matchUserSelectionToSlot } from '../ai/slotMatcher';
import { ConversationState } from '../../types/laine';
import { prisma } from '@/lib/prisma';
import { mergeState } from '@/lib/utils/state-helpers';
import { DateTime } from 'luxon';
import { bookNexhealthAppointment } from '@/lib/nexhealth';

interface SelectAndBookSlotArgs {
  userSelection: string;
  finalConfirmation?: boolean;
}

import { HandlerResult } from '../../types/vapi';

export async function handleSelectAndBookSlot(
  currentState: ConversationState,
  toolArguments: SelectAndBookSlotArgs,
  toolCallId: string
): Promise<HandlerResult> {
  console.log('[SelectAndBookSlot] Processing user selection:', toolArguments.userSelection, 'finalConfirmation:', toolArguments.finalConfirmation);

  const { userSelection, finalConfirmation } = toolArguments;

  // Get practice details for timezone and booking configuration
  const practice = await prisma.practice.findUnique({
    where: { id: currentState.practiceId },
    select: { 
      timezone: true,
      nexhealthSubdomain: true,
      nexhealthLocationId: true
    }
  });

  if (!practice) {
    return {
      toolResponse: { toolCallId, error: "Practice configuration not found." },
      newState: currentState
    };
  }

  const practiceTimezone = practice.timezone || 'America/Chicago';
  
  // Check if presentedSlots exists and is not empty
  if (!currentState.booking?.presentedSlots || currentState.booking.presentedSlots.length === 0) {
    console.log('[SelectAndBookSlot] ERROR: No presented slots available');
    return {
      toolResponse: {
        toolCallId,
        error: "I don't see any available time slots to choose from. Let me check availability for you first."
      },
      newState: currentState
    };
  }

  // If we don't have a selected slot yet, we need to match the user's selection
  let matchedSlot = currentState.booking.selectedSlot;

  if (!matchedSlot) {
    // Get the presented slots from current state
    const presentedSlots = currentState.booking.presentedSlots;

    console.log('[SelectAndBookSlot] Matching selection against', presentedSlots.length, 'slots');
    
    // Use AI slot matcher to find the selected slot
    const matchResult = await matchUserSelectionToSlot(
      userSelection,
      presentedSlots,
      practiceTimezone
    );
    
    matchedSlot = matchResult || undefined;

    if (!matchedSlot) {
      console.log('[SelectAndBookSlot] ERROR: Could not match user selection');
      return {
        toolResponse: {
          toolCallId,
          error: "I'm not sure which time slot you're referring to. Could you please be more specific? For example, you could say '10:30 AM' or 'the first option'."
        },
        newState: currentState
      };
    }

    console.log('[SelectAndBookSlot] Successfully matched slot:', matchedSlot);
  }

  // Generate formatted time for use in messages
  const formattedTime = DateTime.fromISO(matchedSlot.time, { zone: practiceTimezone })
                                .toFormat("cccc, MMMM d 'at' h:mm a");

  // Update the state with the selected slot and clear presented slots
  const newStateWithSelection = mergeState(currentState, {
    booking: {
      selectedSlot: matchedSlot,
      presentedSlots: [] // Clear the list of options once selection is made
    }
  });

  // If we DO NOT have final confirmation yet, ask for it.
  if (!finalConfirmation) {
    console.log('[SelectAndBookSlot] Slot selected. Asking for final confirmation.');
    
    // Check if patient has been identified (required for booking)
    if (!currentState.patient.id) {
      // Patient not identified yet - cannot book without patient ID
      const urgentFlowMessage = `Okay, I'd like to reserve that ${formattedTime} slot for you. Before I can book it, I'll need to get your details. Are you a new or an existing patient?`;
      
      console.log('[SelectAndBookSlot] Urgent flow: Patient ID missing, deferring booking until patient identified');
      
      return {
        toolResponse: {
          toolCallId,
          result: { needsConfirmation: true },
          message: {
            type: 'assistant-message',
            role: 'assistant',
            content: urgentFlowMessage
          }
        },
        newState: newStateWithSelection
      };
    }

    const { spokenName } = currentState.booking;
    const confirmationMessage = `Perfect. Just to confirm, I have you down for a ${spokenName || 'appointment'} on ${formattedTime}. Does that all sound correct?`;
    
    return {
      toolResponse: {
        toolCallId,
        result: { needsConfirmation: true },
        message: {
          type: 'assistant-message', 
          role: 'assistant',
          content: confirmationMessage
        }
      },
      newState: newStateWithSelection
    };
  }

  // If we HAVE final confirmation, proceed to book.
  console.log('[SelectAndBookSlot] Final confirmation received. Proceeding to book.');

  if (!currentState.patient.id) {
    return {
      toolResponse: {
        toolCallId,
        error: "Cannot book appointment: Patient ID is required but not found in state."
      },
      newState: newStateWithSelection
    };
  }

  if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
    return {
      toolResponse: {
        toolCallId,
        error: "Practice NexHealth configuration not found for booking."
      },
      newState: newStateWithSelection
    };
  }

  try {
    const bookingResult = await bookNexhealthAppointment(
      practice.nexhealthSubdomain,
      practice.nexhealthLocationId,
      currentState.patient.id,
      matchedSlot,
      newStateWithSelection // Pass the full state for the note
    );

    if (bookingResult.success) {
      console.log(`[SelectAndBookSlot] Successfully booked appointment with ID: ${bookingResult.bookingId}`);
      
      // Update state with confirmed booking ID
      const newStateWithBooking = mergeState(newStateWithSelection, {
        booking: {
          confirmedBookingId: bookingResult.bookingId,
          selectedSlot: undefined, // Clear the selected slot now that it's booked
          heldSlotId: undefined, // Clear any old hold data
          heldSlotExpiresAt: undefined
        },
        lastAction: 'HELD_SLOT' // Update to final action
      });

      const { spokenName } = currentState.booking;
      const successMessage = `You're all set! I've booked your ${spokenName || 'appointment'} for ${formattedTime}. You should receive a confirmation shortly. Is there anything else I can help you with today?`;
      
      return {
        toolResponse: {
          toolCallId,
          result: { success: true, bookingId: bookingResult.bookingId },
          message: {
            type: 'request-complete',
            role: 'assistant',
            content: successMessage
          }
        },
        newState: newStateWithBooking
      };
    } else {
      console.error('[SelectAndBookSlot] Booking failed:', bookingResult.error);
      
      // Clear selected slot from state and suggest re-checking slots
      const newStateWithoutSelection = mergeState(currentState, {
        booking: {
          selectedSlot: undefined,
          presentedSlots: []
        }
      });

      const failureMessage = `I'm so sorry, it looks like that time was just taken while we were speaking. Let me check for other available times for your ${currentState.booking.spokenName || 'appointment'}.`;
      
      return {
        toolResponse: {
          toolCallId,
          result: { success: false, error: bookingResult.error },
          message: {
            type: 'request-failed',
            role: 'assistant', 
            content: failureMessage
          }
        },
        newState: newStateWithoutSelection
      };
    }
  } catch (error) {
    console.error('[SelectAndBookSlot] Unexpected error during booking:', error);
    
    return {
      toolResponse: {
        toolCallId,
        result: { success: false },
        error: "I encountered an unexpected error while booking your appointment. Our staff has been notified and will call you shortly to finalize your appointment."
      },
      newState: newStateWithSelection
    };
  }
}

================
File: lib/tools/definitions/identifyPatientTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for identifyPatient
 * This intelligent tool handles both existing patient lookup and new patient creation
 */
export function getIdentifyPatientTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "identifyPatient",
      description: "Identifies an existing patient or creates a new patient record. Use this after collecting the patient's full name, date of birth, and other contact details.",
      parameters: {
        type: "object" as const,
        properties: {
          firstName: { 
            type: "string" as const, 
            description: "The patient's first name." 
          },
          lastName: { 
            type: "string" as const, 
            description: "The patient's last name." 
          },
          dateOfBirth: { 
            type: "string" as const, 
            description: "The patient's date of birth in YYYY-MM-DD format." 
          },
          phoneNumber: { 
            type: "string" as const, 
            description: "The patient's phone number (required for new patients)." 
          },
          email: { 
            type: "string" as const, 
            description: "The patient's email address (required for new patients)." 
          },
        },
        required: ["firstName", "lastName", "dateOfBirth", "phoneNumber", "email"],
      },
    },
    server: { 
      url: `${appBaseUrl}/api/vapi-webhook`,
      timeoutSeconds: 30
    }
  };
}

================
File: lib/tools/definitions/insuranceInfoTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for insuranceInfo
 * This tool answers patient questions about dental insurance acceptance
 */
export function getInsuranceInfoTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "insuranceInfo",
      description: "Answers patient questions about dental insurance acceptance. Use for general questions like 'What insurance do you take?' or specific questions like 'Do you accept Cigna?'",
      parameters: {
        type: "object" as const,
        properties: {
          insuranceName: {
            type: "string" as const,
            description: "The specific name of the insurance plan the user is asking about. Omit this for general questions."
          }
        },
        required: []
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: lib/tools/definitions/selectAndBookSlotTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for selectAndBookSlot
 * This tool selects a time slot and, with final user confirmation, books the appointment. This is the final step in the booking process.
 */
export function getSelectAndBookSlotTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "selectAndBookSlot",
      description: "Selects a time slot and, with final user confirmation, books the appointment. This is the final step in the booking process. Call once with user's selection, then again with finalConfirmation=true after they confirm.",
      parameters: {
        type: "object" as const,
        properties: {
          userSelection: {
            type: "string" as const,
            description: "The user's verbal selection of a time slot (e.g., '10 AM', 'the first one', '8:30')"
          },
          finalConfirmation: {
            type: "boolean" as const,
            description: "Set to true only after the user has verbally confirmed the exact time and date."
          }
        },
        required: ["userSelection"]
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: types/laine.ts
================
import type { SlotData } from './vapi';

/**
 * Canonical ConversationState interface for Laine AI voice assistant.
 * This interface provides comprehensive tracking of the booking flow state
 * to address critical issues with booking integrity and conversational memory.
 */
export interface ConversationState {
  callId: string;
  practiceId: string;

  patient: {
    status: 'UNKNOWN' | 'IDENTIFIED_EXISTING' | 'NEW_DETAILS_COLLECTED';
    id?: number; // NexHealth Patient ID
    firstName?: string;
    lastName?: string;
    dob?: string;
    phone?: string;
    email?: string;
    isNameConfirmed: boolean;
  };

  insurance: {
    status: 'NOT_CHECKED' | 'IN_NETWORK' | 'OUT_OF_NETWORK';
    queriedPlan?: string;
  };

  booking: {
    appointmentTypeId?: string;
    appointmentTypeName?: string;
    spokenName?: string;
    duration?: number;
    isUrgent: boolean;
    presentedSlots: SlotData[];
    // --- CRITICAL NEW FIELDS FOR BOOKING INTEGRITY ---
    selectedSlot?: SlotData;
    heldSlotId?: string; // The ID of the temporarily held slot from NexHealth
    heldSlotExpiresAt?: string; // ISO timestamp for when the hold expires
    confirmedBookingId?: string; // The final NexHealth appointment ID
  };

  // Tracks the last major action to prevent loops and redundant questions
  lastAction?: 'GREETED' | 'IDENTIFIED_APPOINTMENT_TYPE' | 'CHECKED_INSURANCE' | 'IDENTIFIED_PATIENT' | 'OFFERED_SLOTS' | 'HELD_SLOT';
}

================
File: app/test/test-client.tsx
================
"use client";

import Vapi from "@vapi-ai/web"; // Import Vapi
import { useEffect, useState, useRef } from "react";
import type { LatestCallLogData } from "./actions";

interface TestClientProps {
  vapiAssistantId: string;
  initialPhoneNumber: string | null;
  initialLatestCallLog: LatestCallLogData | null;
}

export function TestClient({ vapiAssistantId, initialPhoneNumber, initialLatestCallLog }: TestClientProps) {
  const [isCalling, setIsCalling] = useState(false);
  const [liveTranscript, setLiveTranscript] = useState<Array<{speaker: string, text: string}>>([]);
  const [callStatus, setCallStatus] = useState("Idle");
  const [phoneNumber] = useState(initialPhoneNumber);
  const [latestCallLog] = useState(initialLatestCallLog);
  
  const vapiRef = useRef<Vapi | null>(null); // Initialize vapiRef

  useEffect(() => {
    if (!process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY) {
      console.error("NEXT_PUBLIC_VAPI_PUBLIC_KEY is not set.");
      setCallStatus("Error: Vapi Public Key not configured.");
      return;
    }
    const vapiInstance = new Vapi(process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY);
    vapiRef.current = vapiInstance;

    vapiInstance.on('call-start', () => {
      console.log('Vapi call started');
      setIsCalling(true);
      setCallStatus("In Progress...");
      setLiveTranscript([]); // Clear previous transcript
    });

    vapiInstance.on('call-end', () => {
      console.log('Vapi call ended');
      setIsCalling(false);
      setCallStatus("Call Ended. Refresh to see updated log.");
      // Consider adding a server action call here to immediately fetch the latest call log
      // and update `setLatestCallLog`. For now, user needs to refresh page.
    });

    vapiInstance.on('error', (e) => {
      console.error('Vapi SDK error:', e);
      setIsCalling(false);
      setCallStatus(`Error: ${e?.message || 'Unknown Vapi error'}`);
    });

    vapiInstance.on('message', (message) => {
      // console.log('Vapi message:', message); // For debugging all messages
      if (message.type === 'transcript') {
        const role = message.role === 'assistant' ? 'Laine' : 'User';
        if (message.transcriptType === 'final') {
          setLiveTranscript(prev => [...prev, { speaker: role, text: message.transcript }]);
        }
      }
      if (message.type === 'status-update' && message.status) {
         // Example: "ringing", "in-progress", "forwarding", "ended"
        setCallStatus(message.status.charAt(0).toUpperCase() + message.status.slice(1));
      }
      // Add more message handlers if needed (e.g., 'speech-start', 'speech-end')
    });
    
    return () => {
      // Cleanup: stop call and remove listeners if component unmounts
      if (vapiRef.current) {
        vapiRef.current.stop();
      }
      vapiInstance.removeAllListeners();
    };
  }, []); // Empty dependency array ensures this runs once on mount

  const handleStartCall = () => {
    if (vapiRef.current && vapiAssistantId) {
      setCallStatus("Starting call...");
      vapiRef.current.start(vapiAssistantId);
    }
  };

  const handleStopCall = () => {
    if (vapiRef.current) {
      setCallStatus("Stopping call...");
      vapiRef.current.stop();
    }
  };

  // Function to interpret endedReason for success/fail
  const getCallOutcome = (log: LatestCallLogData | null) => {
    if (!log || !log.endedReason) return "Status Unknown";
    if (log.endedReason.toLowerCase().includes("error") || log.endedReason.toLowerCase().includes("failed")) {
      return `Failed: ${log.endedReason}`;
    }
    if (["assistant-ended-call", "customer-ended-call", "hangup"].includes(log.endedReason.toLowerCase())) {
      return `Call completed (${log.endedReason})`;
    }
    return `Ended: ${log.endedReason}`;
  };
  
  const handleRefreshLatestCall = async () => {
    // Placeholder: In a real app, you might call a server action to re-fetch
    // For now, this button won't do anything until we implement re-fetching if needed.
    alert("Re-fetching latest call log - not yet implemented in this phase. Call data updates after a new call ends and page reloads or via live updates if implemented.");
  };

  const handlePhoneCall = () => {
    window.open('tel:+19016171554', '_self');
  };

  return (
    <div className="space-y-8">
      {/* Phone Call Component */}
      <div className="bg-gradient-to-r from-blue-600 to-purple-600 p-6 rounded-xl shadow-lg">
        <div className="flex items-center justify-center space-x-4">
          <div className="flex items-center space-x-3">
            <div className="bg-white/20 p-3 rounded-full">
              <span className="text-2xl">📞</span>
            </div>
            <div>
              <h3 className="text-xl font-semibold text-white mb-1">Talk to Laine on the Phone</h3>
              <p className="text-blue-100 text-sm">Experience our AI dental assistant over the phone</p>
            </div>
          </div>
          <button
            onClick={handlePhoneCall}
            className="bg-white text-blue-600 hover:bg-blue-50 px-6 py-3 rounded-lg font-semibold transition-all duration-200 hover:scale-105 shadow-md"
          >
            <div className="flex items-center space-x-2">
              <span className="text-lg">📱</span>
              <span>+1 (910) 418 1866</span>
            </div>
          </button>
        </div>
      </div>

      <div className="bg-white p-6 rounded-lg shadow-md">
        <h2 className="text-xl font-semibold mb-4 text-slate-700">Test Your Laine Assistant</h2>
        <p className="text-sm text-gray-600 mb-1">Assistant ID: <span className="font-mono text-blue-600">{vapiAssistantId}</span></p>
        {phoneNumber && (
          <p className="text-sm text-gray-600 mb-4">
            Or, Call Laine at: <strong className="text-blue-600">{phoneNumber}</strong>
          </p>
        )}

        {/* Web Call Module Placeholder */}
        <div className="mt-4 space-x-2">
          <button 
            onClick={handleStartCall} 
            disabled={isCalling || callStatus.startsWith("Error:")}
            className="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isCalling ? "Calling..." : "Start Web Call"}
          </button>
          <button
            onClick={handleStopCall} 
            disabled={!isCalling}
            className="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Stop Web Call
          </button>
        </div>
        <p className="mt-2 text-sm text-gray-500">Call Status: <span className="font-semibold">{callStatus}</span></p>
        
        <div className="mt-4 p-4 bg-gray-50 rounded-md border border-gray-200 max-h-60 overflow-y-auto">
          <h3 className="text-md font-semibold text-gray-700 mb-2">Live Transcript:</h3>
          {liveTranscript.length === 0 && <p className="text-xs text-gray-500 italic">Transcript will appear here...</p>}
          {liveTranscript.map((entry, index) => (
             <p key={index} className="text-xs text-gray-800 mb-1">
               <strong className={entry.speaker === 'Laine' ? 'text-blue-600' : 'text-green-600'}>{entry.speaker}:</strong> {entry.text}
             </p>
          ))}
        </div>
      </div>

      {/* Latest Call Info */}
      <div className="bg-white p-6 rounded-lg shadow-md">
        <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold text-slate-700">Latest Call Information</h3>
            <button 
                onClick={handleRefreshLatestCall}
                className="px-3 py-1 text-xs bg-blue-500 text-white rounded-md hover:bg-blue-600"
            >
                Refresh
            </button>
        </div>
        {latestCallLog ? (
          <div className="space-y-3">
            <p className="text-sm">
              <strong>Call Time:</strong> {new Date(latestCallLog.createdAt).toLocaleString()}
            </p>
            <p className="text-sm">
              <strong>Outcome:</strong> {getCallOutcome(latestCallLog)}
            </p>
            {latestCallLog.recordingUrl && (
              <div>
                <strong className="text-sm">Recording:</strong>
                <audio src={latestCallLog.recordingUrl} controls className="w-full mt-1" />
              </div>
            )}
            {latestCallLog.transcriptText && (
              <div>
                <strong className="text-sm">Full Transcript:</strong>
                <pre className="mt-1 text-xs bg-gray-50 p-3 rounded-md border border-gray-200 max-h-48 overflow-y-auto whitespace-pre-wrap">
                  {latestCallLog.transcriptText}
                </pre>
              </div>
            )}
            {latestCallLog.summary && (
                <div>
                    <strong className="text-sm">Vapi Summary:</strong>
                    <p className="mt-1 text-xs bg-gray-50 p-3 rounded-md border border-gray-200 whitespace-pre-wrap">
                        {latestCallLog.summary}
                    </p>
                </div>
            )}
          </div>
        ) : (
          <p className="text-sm text-gray-500 italic">No call history found for this practice.</p>
        )}
      </div>
    </div>
  );
}

================
File: lib/ai/insuranceResponseGenerator.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";

/**
 * Generates a natural, helpful, and context-aware response based on insurance query results.
 * Handles three scenarios: general inquiry, specific inquiry with match, and specific inquiry without match.
 * @param isMatch Whether the specific insurance plan was found in accepted insurances
 * @param queriedInsurance The specific insurance plan the user asked about (null for general inquiries)
 * @param acceptedInsurances Array of insurance plans that the practice accepts
 * @returns A promise that resolves to a natural response string
 */
export async function generateInsuranceResponse(
  isMatch: boolean, 
  queriedInsurance: string | null, 
  acceptedInsurances: string[]
): Promise<string> {
  try {
    const systemPrompt = `You are an AI assistant crafting a response for a dental receptionist. Your tone should be helpful and clear. Based on the scenario, generate a single, fluid response.

**Scenario A: General Inquiry**
The user asked what insurances you accept.
Your task: List the following accepted plans in a natural sentence.
Accepted Plans: {{acceptedInsurances}}
Example: "We accept several major plans, including Cigna, Delta Dental, and MetLife."

**Scenario B: Specific Inquiry - Match Found**
The user asked if you accept a specific insurance, and you do.
Your task: Confirm that you accept their plan.
User's Plan: {{queriedInsurance}}
Example: "Yes, we do accept Cigna! We're in-network with them."

**Scenario C: Specific Inquiry - No Match**
The user asked if you accept a specific insurance, and you do not.
Your task: Deliver a reassuring, empathetic response that doesn't alienate the patient or list other plans.
User's Plan: {{queriedInsurance}}
Example: "It looks like we may be out-of-network with that plan, but we'd still love to take care of you."`;

    let userMessage: string;
    
    if (queriedInsurance === null) {
      // Scenario A: General Inquiry
      userMessage = `The user asked what insurances you accept. List these accepted plans naturally: ${acceptedInsurances.join(', ')}`;
    } else if (isMatch) {
      // Scenario B: Specific Inquiry - Match Found
      userMessage = `The user asked if you accept ${queriedInsurance}. Confirm that you do accept this plan.`;
    } else {
      // Scenario C: Specific Inquiry - No Match
      userMessage = `The user asked if you accept ${queriedInsurance}. You do NOT accept this plan. Deliver a reassuring, empathetic response that doesn't alienate them or list other plans.`;
    }

    const messages: CoreMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userMessage }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.2,
      maxTokens: 150,
    });

    return text.trim();

  } catch (error) {
    console.error(`[InsuranceResponseGenerator] Error generating response for queriedInsurance: "${queriedInsurance}", isMatch: ${isMatch}`, error);
    
    // Safe fallback response
    if (queriedInsurance === null) {
      return acceptedInsurances.length > 0 
        ? `We accept ${acceptedInsurances.join(', ')}.`
        : "I'm sorry, I don't have the list of accepted insurances available right now, but our office staff can certainly help with that.";
    } else if (isMatch) {
      return `Yes, we do accept ${queriedInsurance}!`;
    } else {
      return `It looks like we may be out-of-network with ${queriedInsurance}, but we'd still love to take care of you.`;
    }
  }
}

================
File: lib/tool-handlers/identifyPatientHandler.ts
================
import { prisma } from "@/lib/prisma";
import { fetchNexhealthAPI, createPatient } from "@/lib/nexhealth";
import type { HandlerResult, ApiLog } from "@/types/vapi";
import type { ConversationState } from "@/types/laine";
import { mergeState } from '@/lib/utils/state-helpers';

interface IdentifyPatientArgs {
  firstName: string;
  lastName: string;
  dateOfBirth: string;
  phoneNumber: string;
  email: string;
}

interface NexHealthPatient {
  id: number;
  first_name: string;
  last_name: string;
  bio?: {
    date_of_birth?: string;
  };
}

interface NexHealthApiData {
  patients: NexHealthPatient[];
}

interface NexHealthApiResponse {
  data?: NexHealthApiData;
}

interface NexHealthPatientResponse {
  data?: {
    user?: {
      id?: number;
    };
  };
  user?: {
    id?: number;
  };
}

/**
 * Handles the identifyPatient tool call
 * Intelligently searches for existing patients first, then creates new records if needed
 * This consolidates the logic from both findAndConfirmPatient and createPatientRecord
 */
export async function handleIdentifyPatient(
  currentState: ConversationState,
  args: IdentifyPatientArgs,
  toolCallId: string
): Promise<HandlerResult> {
  const apiLog: ApiLog = [];
  
  console.log(`[IdentifyPatientHandler] Processing identification for: "${args.firstName} ${args.lastName}", DOB: "${args.dateOfBirth}"`);

  try {
    if (!currentState.practiceId) {
      return {
        toolResponse: {
          toolCallId,
          error: "Practice configuration not found."
        },
        newState: currentState
      };
    }

    // Get practice details from database
    const practice = await prisma.practice.findUnique({
      where: { id: currentState.practiceId },
      select: {
        nexhealthSubdomain: true,
        nexhealthLocationId: true
      }
    });

    if (!practice?.nexhealthSubdomain || !practice?.nexhealthLocationId) {
      console.error('[IdentifyPatientHandler] Practice missing NexHealth configuration');
      return {
        toolResponse: {
          toolCallId,
          error: "Practice NexHealth configuration incomplete."
        },
        newState: currentState
      };
    }

    console.log(`[IdentifyPatientHandler] Using practice: ${practice.nexhealthSubdomain}`);

    // Step 1: Search for existing patient by name
    const fullName = `${args.firstName} ${args.lastName}`;
    const { data: apiResponse, apiLog: searchApiLog } = await fetchNexhealthAPI(
      '/patients',
      practice.nexhealthSubdomain,
      { 
        location_id: practice.nexhealthLocationId,
        name: fullName
      },
      'GET',
      undefined,
      apiLog
    );

    const response = apiResponse as NexHealthApiResponse;
    const patients = response.data?.patients;

    console.log(`[IdentifyPatientHandler] API search returned ${patients?.length ?? 0} patient(s) with the name "${fullName}".`);

    // Step 2: If patients found, try to match by DOB
    if (Array.isArray(patients) && patients.length > 0) {
      console.log(`[IdentifyPatientHandler] Found ${patients.length} patient(s) with matching name, checking DOB`);

      // Debug logging before DOB comparison
      console.log(`[IdentifyPatientHandler] Searching for DOB: "${args.dateOfBirth}"`);
      patients.forEach((patient, index) => {
        console.log(`[IdentifyPatientHandler] Record ${index} DOB: "${patient.bio?.date_of_birth}"`);
      });

      // Find patient with matching date of birth
      const matchedPatient = patients.find(patient => {
        const recordDob = patient.bio?.date_of_birth;
        return typeof recordDob === 'string' && recordDob.trim() === args.dateOfBirth.trim();
      });

      if (matchedPatient) {
        // Step 3A: Existing patient found and confirmed
        console.log(`[IdentifyPatientHandler] Found existing patient with ID: ${matchedPatient.id}`);

        const newState = mergeState(currentState, {
          patient: {
            id: matchedPatient.id,
            status: 'IDENTIFIED_EXISTING',
            firstName: matchedPatient.first_name,
            lastName: matchedPatient.last_name,
            dob: args.dateOfBirth,
            phone: args.phoneNumber,
            email: args.email,
            isNameConfirmed: true
          }
        });

        return {
          toolResponse: {
            toolCallId,
            result: { 
              success: true, 
              nexhealthPatientId: matchedPatient.id,
              patientName: `${matchedPatient.first_name} ${matchedPatient.last_name}`,
              apiLog: searchApiLog
            },
            message: {
              type: "request-complete",
              role: "assistant",
              content: `Great, I've found and confirmed your record, ${args.firstName}. Can I go ahead and schedule your appointment?`
            }
          },
          newState
        };
      } else {
        console.log(`[IdentifyPatientHandler] Found patients with name but no DOB match - proceeding to create new record`);
      }
    }

    // Step 3B: No existing patient found, create new record
    console.log(`[IdentifyPatientHandler] No existing patient found. Creating new record.`);

    // Use hardcoded values for now (these should come from practice configuration)
    const { data: createResponse, apiLog: createApiLog } = await createPatient(
      {
        firstName: args.firstName,
        lastName: args.lastName,
        dateOfBirth: args.dateOfBirth,
        phoneNumber: args.phoneNumber,
        email: args.email
      },
      practice.nexhealthSubdomain,
      parseInt(practice.nexhealthLocationId),
      377851148, // hardcoded providerId - should be configurable
      searchApiLog
    );

    // Extract the patient ID from the response
    const nexHealthResponse = createResponse as NexHealthPatientResponse;
    const newPatientId = nexHealthResponse.data?.user?.id || nexHealthResponse.user?.id;

    if (!newPatientId) {
      console.error('[IdentifyPatientHandler] Patient ID missing from NexHealth create response:', createResponse);
      throw new Error("Patient ID missing from NexHealth response.");
    }

    console.log(`[IdentifyPatientHandler] Successfully created new patient with ID: ${newPatientId}`);

    const newState = mergeState(currentState, {
      patient: {
        id: newPatientId,
        status: 'NEW_DETAILS_COLLECTED',
        firstName: args.firstName,
        lastName: args.lastName,
        dob: args.dateOfBirth,
        phone: args.phoneNumber,
        email: args.email,
        isNameConfirmed: true
      }
    });

    return {
      toolResponse: {
        toolCallId,
        result: { 
          success: true, 
          nexhealthPatientId: newPatientId,
          apiLog: createApiLog
        },
        message: {
          type: "request-complete",
          role: "assistant",
          content: `Thank you! I've successfully created a record for you, ${args.firstName}. Now, let's find an appointment time.`
        }
      },
      newState
    };

  } catch (error) {
    console.error('[IdentifyPatientHandler] Error during patient identification:', error);
    return {
      toolResponse: {
        toolCallId,
        result: { success: false, apiLog },
        message: {
          type: "request-failed",
          role: "assistant", 
          content: "I'm sorry, I ran into a technical problem while processing your information. Let me have our staff call you back to help with your appointment."
        }
      },
      newState: currentState
    };
  }
}

================
File: lib/tool-handlers/insuranceInfoHandler.ts
================
import { prisma } from '@/lib/prisma';
import { generateInsuranceResponse } from '@/lib/ai/insuranceResponseGenerator';
import type { HandlerResult } from '@/types/vapi';
import type { ConversationState } from '@/types/laine';

interface InsuranceInfoArgs {
  insuranceName?: string;
}

/**
 * Handles the insuranceInfo tool call
 * Fetches practice insurance data and generates appropriate responses for general or specific insurance queries
 * @param currentState Current conversation state
 * @param args Tool arguments containing optional insuranceName
 * @param toolCallId ID of the tool call for response tracking
 * @returns HandlerResult with generated insurance response
 */
export async function handleInsuranceInfo(
  currentState: ConversationState,
  args: InsuranceInfoArgs,
  toolCallId: string
): Promise<HandlerResult> {
  console.log(`[InsuranceInfoHandler] Processing query for insurance: "${args.insuranceName || 'general inquiry'}"`);

  try {
    if (!currentState.practiceId) {
      return {
        toolResponse: {
          toolCallId,
          error: "Practice configuration not found."
        },
        newState: currentState
      };
    }

    // Fetch practice insurance information
    const practice = await prisma.practice.findUnique({
      where: { id: currentState.practiceId },
      select: {
        acceptedInsurances: true
      }
    });

    if (!practice) {
      return {
        toolResponse: {
          toolCallId,
          error: "Practice not found."
        },
        newState: currentState
      };
    }

    // Handle case where no insurance data is available
    if (!practice.acceptedInsurances || practice.acceptedInsurances.trim() === '') {
      return {
        toolResponse: {
          toolCallId,
          result: { success: true },
          message: {
            type: "request-complete",
            role: "assistant",
            content: "I'm sorry, I don't have the list of accepted insurances available right now, but our office staff can certainly help with that."
          }
        },
        newState: currentState
      };
    }

    // Parse the comma-separated string into an array of trimmed strings
    const insurancesArray = practice.acceptedInsurances
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);

    let isMatch = false;
    let queriedInsurance: string | null = null;

    // Check if a specific insurance was queried
    if (args.insuranceName) {
      queriedInsurance = args.insuranceName;
      // Perform case-insensitive search
      isMatch = insurancesArray.some(insurance => 
        insurance.toLowerCase() === args.insuranceName!.toLowerCase()
      );
    }

    // Generate AI-powered response
    const aiResponse = await generateInsuranceResponse(isMatch, queriedInsurance, insurancesArray);

    console.log(`[InsuranceInfoHandler] Generated response for insurance query`);

    return {
      toolResponse: {
        toolCallId,
        result: { success: true },
        message: {
          type: "request-complete",
          role: "assistant",
          content: aiResponse
        }
      },
      newState: currentState
    };

  } catch (error) {
    console.error('[InsuranceInfoHandler] Error processing insurance query:', error);
    return {
      toolResponse: {
        toolCallId,
        error: "I'm sorry, I'm having trouble accessing our insurance information right now. Please contact our office directly for assistance with insurance questions."
      },
      newState: currentState
    };
  }
}

================
File: app/tool-call-log/page.tsx
================
'use client'; // This page will need client-side interactivity for fetching and copying

import React, { useState, useEffect, useCallback } from 'react';

// New TypeScript interfaces for the refactored debugging dashboard
interface TranscriptMessageLog {
  role: 'user' | 'assistant';
  content: string;
  timestamp?: string;
}

interface ToolExecutionLogEntry {
  toolLogId: string;
  toolCallId: string;
  toolName: string;
  timestamp: string;
  arguments: Record<string, unknown>;
  aiMatcherInputQuery?: string;
  aiMatcherOutputId?: string | null;
  aiResponderOutputMessage?: string;
  resultSentToVapi?: string | null;
  errorSentToVapi?: string | null;
  success: boolean;
  executionTimeMs?: number;
}

interface CallLogSummary {
  detectedIntent?: string;
  lastAppointmentTypeId?: string;
  lastAppointmentTypeName?: string;
  lastAppointmentDuration?: number;
  callStatus?: string;
  nexhealthPatientId?: string;
  bookedAppointmentNexhealthId?: string;
  assistantId?: string;
  endedReason?: string;
  callDurationSeconds?: number;
  cost?: number;
}

interface DetailedCallDebugData {
  callId: string;
  practiceId?: string;
  startTime?: string;
  endTime?: string;
  status?: string;
  transcript: TranscriptMessageLog[];
  callLogSummary?: CallLogSummary;
  toolExecutions: ToolExecutionLogEntry[];
}

export default function ToolCallLogPage() {
  const [logData, setLogData] = useState<DetailedCallDebugData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [autoRefresh, setAutoRefresh] = useState<boolean>(false);
  const [refreshIntervalId, setRefreshIntervalId] = useState<NodeJS.Timeout | null>(null);

  // Collapsible section state management
  const [isTranscriptOpen, setIsTranscriptOpen] = useState(false);
  const [isToolsOpen, setIsToolsOpen] = useState(false);
  const [isCallLogOpen, setIsCallLogOpen] = useState(false);

  const fetchLogs = useCallback(async () => {
    setIsLoading(true);
    try {
      // Updated to fetch from new structured debug API endpoint
      const response = await fetch('/api/debug/latest-tool-call-log');
      if (!response.ok) {
        throw new Error(`Failed to fetch logs: ${response.statusText}`);
      }
      const data: DetailedCallDebugData = await response.json();
      setLogData(data);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
      setLogData(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchLogs();
  }, [fetchLogs]);

  useEffect(() => {
    if (autoRefresh) {
      const intervalId = setInterval(fetchLogs, 5000); // Refresh every 5 seconds
      setRefreshIntervalId(intervalId);
      return () => clearInterval(intervalId);
    } else {
      if (refreshIntervalId) {
        clearInterval(refreshIntervalId);
        setRefreshIntervalId(null);
      }
    }
  }, [autoRefresh, fetchLogs, refreshIntervalId]);

  const copyLogsToClipboard = () => {
    if (logData) {
      const logString = JSON.stringify(logData, null, 2);
      navigator.clipboard.writeText(logString)
        .then(() => alert('Logs copied to clipboard!'))
        .catch(err => alert('Failed to copy logs: ' + err));
    }
  };
  
  const clearLogsOnServer = async () => {
    if (confirm('Are you sure you want to clear the logs on the server?')) {
      try {
        const response = await fetch('/api/debug/latest-tool-call-log', { method: 'DELETE' });
        if (!response.ok) throw new Error('Failed to clear logs on server.');
        alert('Logs cleared on server. Refreshing...');
        fetchLogs(); // Refresh to show cleared state
      } catch (err) {
        alert('Error clearing logs: ' + (err instanceof Error ? err.message : 'Unknown error'));
      }
    }
  };

  if (isLoading && !logData) {
    return (
      <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
        Loading call debug details...
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: '20px', color: 'red', fontFamily: 'Arial, sans-serif' }}>
        Error loading call debug details: {error}
      </div>
    );
  }

  return (
    <div style={{ 
      fontFamily: 'Arial, sans-serif', 
      padding: '20px', 
      backgroundColor: '#f8f9fa',
      minHeight: '100vh'
    }}>
      <h1 style={{ 
        color: '#333', 
        borderBottom: '2px solid #ddd',
        paddingBottom: '10px',
        marginBottom: '20px'
      }}>
        Latest Call Debug Dashboard
      </h1>
      
      {/* Action Buttons */}
      <div style={{ 
        marginBottom: '20px', 
        padding: '15px',
        backgroundColor: '#fff',
        borderRadius: '8px',
        border: '1px solid #ddd'
      }}>
        <button 
          onClick={fetchLogs} 
          disabled={isLoading} 
          style={{ 
            marginRight: '10px',
            padding: '8px 16px',
            backgroundColor: isLoading ? '#6c757d' : '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: isLoading ? 'not-allowed' : 'pointer'
          }}
        >
          {isLoading ? 'Refreshing...' : 'Refresh Logs'}
        </button>
        
        <button 
          onClick={copyLogsToClipboard} 
          disabled={!logData} 
          style={{ 
            marginRight: '10px',
            padding: '8px 16px',
            backgroundColor: !logData ? '#6c757d' : '#28a745',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: !logData ? 'not-allowed' : 'pointer'
          }}
        >
          Copy Logs
        </button>
        
        <button 
          onClick={clearLogsOnServer} 
          disabled={!logData?.callId} 
          style={{ 
            marginRight: '10px',
            padding: '8px 16px',
            backgroundColor: !logData?.callId ? '#6c757d' : '#ffc107',
            color: !logData?.callId ? 'white' : '#212529',
            border: 'none',
            borderRadius: '4px',
            cursor: !logData?.callId ? 'not-allowed' : 'pointer'
          }}
        >
          Clear Server Logs
        </button>
        
        <label style={{ display: 'inline-flex', alignItems: 'center' }}>
          <input 
            type="checkbox" 
            checked={autoRefresh} 
            onChange={(e) => setAutoRefresh(e.target.checked)}
            style={{ marginRight: '5px' }}
          />
          Auto-refresh (5s)
        </label>
      </div>

      {logData ? (
        <>
          {/* General Call Information */}
          <div style={{
            backgroundColor: '#fff',
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '20px',
            marginBottom: '20px'
          }}>
            <h2 style={{ 
              margin: '0 0 15px 0',
              color: '#495057',
              borderBottom: '1px solid #ddd',
              paddingBottom: '10px'
            }}>
              📞 General Call Information
            </h2>
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
              <div><strong>Call ID:</strong> <code>{logData.callId}</code></div>
              <div><strong>Practice ID:</strong> <code>{logData.practiceId || 'N/A'}</code></div>
              <div><strong>Start Time:</strong> {logData.startTime ? new Date(logData.startTime).toLocaleString() : 'N/A'}</div>
              <div><strong>End Time:</strong> {logData.endTime ? new Date(logData.endTime).toLocaleString() : 'N/A'}</div>
              <div><strong>Status:</strong> <span style={{
                backgroundColor: logData.status === 'ENDED' ? '#d4edda' : '#fff3cd',
                color: logData.status === 'ENDED' ? '#155724' : '#856404',
                padding: '2px 8px',
                borderRadius: '4px'
              }}>{logData.status || 'N/A'}</span></div>
            </div>
          </div>

          {/* Conversation Transcript */}
          <div style={{
            backgroundColor: '#fff',
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '20px',
            marginBottom: '20px'
          }}>
            <h2 
              onClick={() => setIsTranscriptOpen(!isTranscriptOpen)}
              style={{ 
                margin: '0 0 15px 0',
                color: '#495057',
                borderBottom: '1px solid #ddd',
                paddingBottom: '10px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between'
              }}
            >
              💬 Conversation Transcript ({logData.transcript?.length || 0} messages)
              <span style={{ fontSize: '14px' }}>{isTranscriptOpen ? '▼' : '▶'}</span>
            </h2>
            
            {isTranscriptOpen && (
              <>
                {logData.transcript && logData.transcript.length > 0 ? (
                  <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                    {logData.transcript.map((msg, index) => (
                      <div 
                        key={index}
                        style={{
                          padding: '10px',
                          margin: '8px 0',
                          borderRadius: '8px',
                          backgroundColor: msg.role === 'user' ? '#e6ffed' : '#e6f7ff',
                          border: `1px solid ${msg.role === 'user' ? '#b3e6b3' : '#b3d9ff'}`
                        }}
                      >
                        <strong style={{ color: msg.role === 'user' ? '#155724' : '#004085' }}>
                          {msg.role === 'assistant' ? 'Laine' : 'User'}:
                        </strong> {msg.content}
                        {msg.timestamp && (
                          <span style={{ fontSize: '0.8em', color: '#777', marginLeft: '10px' }}>
                            ({new Date(msg.timestamp).toLocaleTimeString()})
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                ) : (
                  <p style={{ color: '#6c757d', fontStyle: 'italic' }}>
                    No transcript available for this call.
                  </p>
                )}
              </>
            )}
          </div>

          {/* Tool Executions */}
          <div style={{
            backgroundColor: '#fff',
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '20px',
            marginBottom: '20px'
          }}>
            <h2 
              onClick={() => setIsToolsOpen(!isToolsOpen)}
              style={{ 
                margin: '0 0 15px 0',
                color: '#495057',
                borderBottom: '1px solid #ddd',
                paddingBottom: '10px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between'
              }}
            >
              🔧 Tool Executions ({logData.toolExecutions?.length || 0})
              <span style={{ fontSize: '14px' }}>{isToolsOpen ? '▼' : '▶'}</span>
            </h2>
            
            {isToolsOpen && (
              <>
                {logData.toolExecutions && logData.toolExecutions.length > 0 ? (
                  <div>
                    {logData.toolExecutions.map((toolExecution, index) => (
                      <div 
                        key={index}
                        style={{
                          border: '1px solid #ddd',
                          borderRadius: '6px',
                          padding: '15px',
                          marginBottom: '15px',
                          backgroundColor: '#f8f9fa'
                        }}
                      >
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginBottom: '10px' }}>
                          <div><strong>Tool:</strong> <code>{toolExecution.toolName}</code></div>
                          <div><strong>Invocation ID:</strong> <code style={{ fontSize: '12px' }}>{toolExecution.toolCallId}</code></div>
                          <div><strong>Timestamp:</strong> {new Date(toolExecution.timestamp).toLocaleString()}</div>
                          <div>
                            <strong>Status:</strong> 
                            <span style={{
                              backgroundColor: toolExecution.success ? '#d4edda' : '#f8d7da',
                              color: toolExecution.success ? '#155724' : '#721c24',
                              padding: '2px 8px',
                              borderRadius: '4px',
                              marginLeft: '5px'
                            }}>
                              {toolExecution.success ? 'Success' : 'Failed'}
                            </span>
                          </div>
                        </div>
                        
                        {toolExecution.executionTimeMs != null && (
                          <div style={{ marginBottom: '10px' }}>
                            <strong>Execution Time:</strong> {toolExecution.executionTimeMs}ms
                          </div>
                        )}
                        
                        <div style={{ marginBottom: '10px' }}>
                          <strong>Arguments:</strong>
                          <pre style={{
                            backgroundColor: '#fff',
                            padding: '10px',
                            borderRadius: '4px',
                            border: '1px solid #ddd',
                            fontSize: '12px',
                            overflow: 'auto'
                          }}>
                            {JSON.stringify(toolExecution.arguments, null, 2)}
                          </pre>
                        </div>

                        {/* Conditional AI Details for findAppointmentType */}
                        {toolExecution.toolName === 'findAppointmentType' && (
                          <>
                            {(toolExecution.aiMatcherInputQuery || toolExecution.aiMatcherOutputId) && (
                              <div style={{ marginBottom: '10px' }}>
                                <strong>AI Matcher Details:</strong>
                                <div style={{ marginLeft: '10px', marginTop: '5px' }}>
                                  <div><strong>Input Query:</strong> <code>{toolExecution.aiMatcherInputQuery || 'N/A'}</code></div>
                                  <div><strong>Output ID:</strong> <code>{toolExecution.aiMatcherOutputId || 'N/A'}</code></div>
                                </div>
                              </div>
                            )}
                            
                            {toolExecution.aiResponderOutputMessage && (
                              <div style={{ marginBottom: '10px' }}>
                                <strong>AI Responder Output Message:</strong>
                                <pre style={{
                                  backgroundColor: '#e6f7ff',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  border: '1px solid #b3d9ff',
                                  fontSize: '12px'
                                }}>
                                  {toolExecution.aiResponderOutputMessage}
                                </pre>
                              </div>
                            )}
                          </>
                        )}

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px' }}>
                          <div>
                            <strong>Result Sent to VAPI:</strong>
                            <pre style={{
                              backgroundColor: '#fff',
                              padding: '8px',
                              borderRadius: '4px',
                              border: '1px solid #ddd',
                              fontSize: '12px',
                              maxHeight: '150px',
                              overflow: 'auto'
                            }}>
                              {toolExecution.resultSentToVapi || 'N/A'}
                            </pre>
                          </div>
                          <div>
                            <strong>Error Sent to VAPI:</strong>
                            <pre style={{
                              backgroundColor: toolExecution.errorSentToVapi ? '#f8d7da' : '#fff',
                              padding: '8px',
                              borderRadius: '4px',
                              border: '1px solid #ddd',
                              fontSize: '12px',
                              maxHeight: '150px',
                              overflow: 'auto'
                            }}>
                              {toolExecution.errorSentToVapi || 'N/A'}
                            </pre>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <p style={{ color: '#6c757d', fontStyle: 'italic' }}>
                    No tool executions logged for this call.
                  </p>
                )}
              </>
            )}
          </div>

          {/* CallLog Summary */}
          <div style={{
            backgroundColor: '#fff',
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '20px',
            marginBottom: '20px'
          }}>
            <h2 
              onClick={() => setIsCallLogOpen(!isCallLogOpen)}
              style={{ 
                margin: '0 0 15px 0',
                color: '#495057',
                borderBottom: '1px solid #ddd',
                paddingBottom: '10px',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between'
              }}
            >
              📋 Call Outcome Summary (from CallLog)
              <span style={{ fontSize: '14px' }}>{isCallLogOpen ? '▼' : '▶'}</span>
            </h2>
            
            {isCallLogOpen && (
              <>
                {logData.callLogSummary ? (
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
                    <div><strong>Detected Intent:</strong> <code>{logData.callLogSummary.detectedIntent || 'N/A'}</code></div>
                    <div><strong>Last Identified Appointment Type:</strong> <code>{logData.callLogSummary.lastAppointmentTypeName || 'N/A'}</code></div>
                    <div><strong>Appointment Type ID:</strong> <code>{logData.callLogSummary.lastAppointmentTypeId || 'N/A'}</code></div>
                    <div><strong>Appointment Duration:</strong> <code>{logData.callLogSummary.lastAppointmentDuration != null ? logData.callLogSummary.lastAppointmentDuration + ' mins' : 'N/A'}</code></div>
                    <div><strong>Final Call Status:</strong> <code>{logData.callLogSummary.callStatus || 'N/A'}</code></div>
                    <div><strong>NexHealth Patient ID:</strong> <code>{logData.callLogSummary.nexhealthPatientId || 'N/A'}</code></div>
                    <div><strong>Booked Appointment ID:</strong> <code>{logData.callLogSummary.bookedAppointmentNexhealthId || 'N/A'}</code></div>
                    <div><strong>Assistant ID:</strong> <code>{logData.callLogSummary.assistantId || 'N/A'}</code></div>
                    <div><strong>End Reason:</strong> <code>{logData.callLogSummary.endedReason || 'N/A'}</code></div>
                    <div><strong>Call Duration:</strong> <code>{logData.callLogSummary.callDurationSeconds != null ? Math.floor(logData.callLogSummary.callDurationSeconds / 60) + 'm ' + (logData.callLogSummary.callDurationSeconds % 60) + 's' : 'N/A'}</code></div>
                    <div><strong>Cost:</strong> <code>{logData.callLogSummary.cost != null ? '$' + logData.callLogSummary.cost.toFixed(4) : 'N/A'}</code></div>
                  </div>
                ) : (
                  <p style={{ color: '#6c757d', fontStyle: 'italic' }}>
                    No call summary data available.
                  </p>
                )}
              </>
            )}
          </div>
        </>
      ) : (
        <div style={{ 
          padding: '20px', 
          backgroundColor: '#d1ecf1', 
          borderRadius: '8px',
          border: '1px solid #bee5eb',
          color: '#0c5460'
        }}>
          No call debug data available yet. Make a VAPI call involving tools to see detailed information here.
        </div>
      )}
    </div>
  );
}

================
File: lib/ai/acknowledgmentGenerator.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";

/**
 * Generates a short, context-aware acknowledgment phrase based on the user's request.
 * Produces empathetic responses for painful/negative requests, encouraging responses 
 * for positive/cosmetic requests, and simple professional acknowledgments for routine requests.
 * @param patientRequest The patient's stated reason for calling or request
 * @returns A promise that resolves to a contextually appropriate acknowledgment string
 */
export async function generateAcknowledgment(patientRequest: string): Promise<string> {
  try {
    const systemPrompt = `You are an expert AI copywriter specializing in creating short, natural-sounding conversational acknowledgments for a dental receptionist. Your response MUST be a single, short phrase and nothing else. Do not add any extra text or pleasantries.

**CRITICAL RULES:**
- **NO FILLER WORDS:** Do not use unnecessary filler words like "Okay" or "Alright" unless they are part of a natural phrase.
- **NO PROCESS NARRATION:** Do not say "Let me check" or "I'll look that up" - just deliver the acknowledgment.

- If the user's request expresses any kind of pain or discomfort (e.g., mentions pain, hurt, ache, chip, crack, sensitivity), generate an empathetic response.
  - Good example: "Oh no, that sounds painful. Let's get that sorted for you immediately."
- If the user's request is for a cosmetic or positive procedure (e.g., "veneers," "whitening," "Invisalign"), generate an encouraging and positive response.
  - Example for "I want to get my teeth whitened": "That's exciting! A brighter smile is a great goal."
- If the user's request is neutral or routine (e.g., "I need a cleaning," "check-up"), generate a simple, pleasant acknowledgment.
  - Example for "I'd like to schedule a cleaning": "Of course, we can definitely get that scheduled for you."`;

    const messages: CoreMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: patientRequest }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.2,
      maxTokens: 50,
    });

    return text.trim();

  } catch (error) {
    console.error(`[AcknowledgmentGenerator] Error generating acknowledgment for request: "${patientRequest}"`, error);
    return '';
  }
}

================
File: lib/tools/definitions/findAppointmentTypeTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for findAppointmentType
 * This tool identifies the most suitable dental appointment type based on patient needs
 */
export function getFindAppointmentTypeTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "findAppointmentType",
      description: "Identifies the patient's need (e.g., 'toothache', 'cleaning') and determines the correct appointment type. **This is always the first tool to call in a conversation.**",
      parameters: {
        type: "object" as const,
        properties: {
          patientRequest: {
            type: "string" as const,
            description: "The patient's verbatim description of their reason for calling, their symptoms, or the type of appointment they are requesting. For example, 'I have a toothache', 'I need a cleaning', or 'My crown fell off and I need it re-cemented'."
          }
        },
        required: ["patientRequest"]
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: app/laine/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { createVapiAssistant } from "@/lib/vapi";
import { getAllTools } from "@/lib/tools";
import { LainePracticeClient } from "./laine-practice-client";

async function createPracticeAssistant() {
  "use server";
  
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Not authenticated");
  }

  // Get the practice
  const practice = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practice) {
    throw new Error("Practice not found");
  }

  if (practice.assistantConfig?.vapiAssistantId) {
    throw new Error("Assistant already exists for this practice");
  }

  const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
  
  // Build tools for the assistant
  const tools = getAllTools(appBaseUrl);
  
  // Create default assistant configuration
  const assistantConfig = {
    name: `${practice.name || 'Practice'} - Laine`,
    model: {
      provider: "openai" as const,
      model: "gpt-4o-mini",
      temperature: 0.7,
      messages: [
        {
          role: "system" as const,
          content: "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient."
        }
      ],
      tools
    },
    voice: {
      provider: "vapi" as const,
      voiceId: "Elliot"
    },
    firstMessage: "Hello! This is Laine from your dental office. How can I help you today?",
    // General assistant webhooks (status updates, call reports, transcripts)
    serverUrl: `${appBaseUrl}/api/vapi/webhook`,
    serverMessages: ["end-of-call-report", "status-update", "transcript"],
    silenceTimeoutSeconds: 30,
    maxDurationSeconds: 600, // 10 minutes
    backgroundSound: "office" as const,
    backchannelingEnabled: true,
    backgroundDenoisingEnabled: true,
    modelOutputInMessagesEnabled: true
  };

  try {
    console.log("Creating VAPI assistant for practice:", practice.id);
    const vapiAssistant = await createVapiAssistant(assistantConfig);
    
    // Create or update the assistant config in our database
    await prisma.practiceAssistantConfig.upsert({
      where: { practiceId: practice.id },
      create: {
        practiceId: practice.id,
        vapiAssistantId: vapiAssistant.id,
        voiceProvider: "vapi",
        voiceId: "Elliot",
        systemPrompt: "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.",
        firstMessage: "Hello! This is Laine from your dental office. How can I help you today?"
      },
      update: {
        vapiAssistantId: vapiAssistant.id,
        updatedAt: new Date()
      }
    });

    console.log(`Successfully created VAPI assistant ${vapiAssistant.id} for practice ${practice.id}`);
  } catch (error) {
    console.error("Error creating VAPI assistant:", error);
    throw new Error(`Failed to create assistant: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  revalidatePath("/laine");
}

export default async function LainePage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/sign-in");
  }

  // Get the practice with assistant configuration
  const practice = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practice) {
    redirect("/practice-config");
  }

  const hasAssistant = practice.assistantConfig?.vapiAssistantId;

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-2xl mx-auto">
        <h1 className="text-3xl font-bold mb-6">Laine Assistant Configuration</h1>
        <LainePracticeClient 
          practice={practice} 
          hasAssistant={!!hasAssistant}
          createPracticeAssistant={createPracticeAssistant}
        />
      </div>
    </div>
  );
}

================
File: lib/ai/slotMatcher.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";
import type { SlotData } from "@/types/vapi";
import { DateTime } from "luxon";

export async function matchUserSelectionToSlot(
  userSelection: string,
  presentedSlots: SlotData[],
  practiceTimezone: string
): Promise<SlotData | null> {
  try {
    if (!presentedSlots || presentedSlots.length === 0) {
      console.error("[SlotMatcher] No presented slots provided to match against.");
      return null;
    }

    // Create a simplified, numbered list of slots for the AI to parse.
    const formattedSlotsForAI = presentedSlots.map((slot, index) => {
      const time = DateTime.fromISO(slot.time, { zone: practiceTimezone }).toFormat("cccc 'at' h:mm a");
      return `${index + 1}. ${time}`;
    }).join("\n");

    const systemPrompt = `You are a highly accurate AI assistant. Your task is to match a user's verbal selection to one of the provided time slot options.

**CRITICAL RULES:**
1.  **RETURN ONLY THE NUMBER:** Your entire response must be ONLY the number corresponding to the best match (e.g., "1", "2").
2.  **HANDLE AMBIGUITY:** If the user's selection is ambiguous or doesn't clearly match, return "NO_MATCH".
3.  **BE FLEXIBLE:** The user might not say the exact time. "The morning one," "the first one," "the 3:10," or "let's do the later one" are all valid selections. Use the context of the presented slots to find the best fit.
4.  **IGNORE EXTRA WORDS:** The user might say "Yes, the 8:30 is good." Focus on "8:30".

**CONTEXT:**
The user was presented with these numbered options:
${formattedSlotsForAI}

The user then said: "${userSelection}"

Which option number did the user select? (Return ONLY the number or "NO_MATCH")`;

    const messages: CoreMessage[] = [{ role: 'system', content: systemPrompt }];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0, // Set to 0 for maximum predictability
      maxTokens: 10,
    });

    const matchedIndex = parseInt(text.trim(), 10) - 1;

    if (!isNaN(matchedIndex) && matchedIndex >= 0 && matchedIndex < presentedSlots.length) {
      const matchedSlot = presentedSlots[matchedIndex];
      console.log(`[SlotMatcher] Successfully matched "${userSelection}" to slot #${matchedIndex + 1}: ${matchedSlot.time}`);
      return matchedSlot;
    }

    console.log(`[SlotMatcher] No definitive match found for user selection: "${userSelection}". AI response: "${text.trim()}"`);
    return null;

  } catch (error) {
    console.error("[SlotMatcher] Error during AI slot matching:", error);
    return null;
  }
}

================
File: lib/ai/summaryHelper.ts
================
import type { ConversationState } from '@/types/laine';

/**
 * Generates a concise, professional appointment note for dental office staff
 * @param state The full conversation state containing booking details
 * @returns A professional note string for the appointment
 */
export async function generateAppointmentNote(
  state: ConversationState
): Promise<string> {
  const { appointmentTypeName, duration } = state.booking;

  const note = `
Appointment Type: ${appointmentTypeName || 'Not specified'}
Duration: ${duration || 'N/A'} minutes
  `.trim().replace(/^    /gm, ''); // Cleans up indentation

  console.log(`[SummaryHelper] Generated state-driven appointment note: "${note}"`);
  return Promise.resolve(note); // Return as a promise to maintain async signature
}

================
File: lib/tools/definitions/checkAvailableSlotsTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for checkAvailableSlots
 * This tool checks for available appointment slots for a previously identified appointment type
 */
export function getCheckAvailableSlotsTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "checkAvailableSlots",
      description: "Finds available appointment times. By default, proactively searches for the next available appointments. Call this after the appointment type is known. Only include parameters if the user has specifically expressed preferences.",
      parameters: {
        type: "object" as const,
        properties: {
          preferredDaysOfWeek: {
            type: "string" as const,
            description: "A JSON string array of the user's preferred days of the week. Example: '[\"Monday\", \"Wednesday\"]'. This is collected from the user."
          },
          timeBucket: {
            type: "string" as const,
            description: "The user's general time preference, which must be one of the following values: 'Early', 'Morning', 'Midday', 'Afternoon', 'Evening', 'Late', or 'AllDay'. This is collected from the user."
          },
          requestedDate: {
            type: "string" as const,
            description: "The user's specific requested date, like 'tomorrow', 'next Wednesday', or 'July 10th'. Use this for specific date searches."
          }
        },
        required: []
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: lib/ai/appointmentMatcher.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";

interface ApptTypeInputForMatcher {
  id: string; // nexhealthAppointmentTypeId
  name: string;
  keywords: string | null;
}

export async function matchAppointmentTypeIntent(
  patientQuery: string,
  availableAppointmentTypes: ApptTypeInputForMatcher[]
): Promise<string | null> {
  try {
    console.log(`[AI Matcher] Attempting to match query: "${patientQuery}"`);

    // Check if OpenAI API key is available
    if (!process.env.OPENAI_API_KEY) {
      console.error("[AI Matcher] OPENAI_API_KEY not found in environment variables");
      return null;
    }

    // Format appointment types for the LLM prompt
    const formattedTypesString = availableAppointmentTypes
      .map(type => `ID: ${type.id}, Name: ${type.name}, Keywords: ${type.keywords || "None"}`)
      .join("\n");

    // Construct messages for the generateText call
    const messages: CoreMessage[] = [
      {
        role: "system",
        content: `You are an expert AI assistant for a dental office. Your task is to match a patient's stated reason for calling with the most appropriate dental appointment type from the provided list.
The list includes appointment type IDs, names, and associated keywords.
Respond ONLY with the 'ID' of the best matching appointment type.
If no clear match is found based on the patient's query and the available types/keywords, respond with "NO_MATCH".
Prioritize matches where the patient's query aligns well with the keywords or the name of the appointment type.
Consider common dental terms and patient language.
Example: If patient says "my tooth hurts badly", and an appointment type is "Emergency Exam" with keywords "toothache, pain, urgent", you should match it.
If patient says "I need a cleaning" and type is "Routine Cleaning", match it.
If patient says "I want to discuss veneers" and no cosmetic/veneer appointment type exists, return "NO_MATCH".`
      },
      {
        role: "user",
        content: `Patient's reason for calling: "${patientQuery}"

Available appointment types:
${formattedTypesString}

Which appointment type ID is the best match? (Return ONLY the ID or "NO_MATCH")`
      }
    ];

    // Call OpenAI with the messages
    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.1,
      maxTokens: 50
    });

    console.log(`[AI Matcher] LLM response for matching: "${text}"`);

    // Process the response
    const trimmedResponse = text.trim();
    if (trimmedResponse === "NO_MATCH") {
      return null;
    }

    return trimmedResponse;

  } catch (error) {
    console.error("[AI Matcher] Error during AI call:", error);
    return null;
  }
}

================
File: prisma/schema.prisma
================
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PatientWebStatus {
  NEW
  RETURNING
  BOTH
}

model Practice {
  id                            String                         @id @default(cuid())
  clerkUserId                   String                         @unique
  name                          String?
  nexhealthSubdomain            String?
  nexhealthLocationId           String?
  webhookLastSyncAt             DateTime?
  webhookLastSuccessfulSyncAt   DateTime?
  webhookSyncErrorMsg           String?
  address                       String?
  acceptedInsurances            String?
  serviceCostEstimates          String?
  timezone                      String?
  lunchBreakStart               String?
  lunchBreakEnd                 String?
  minBookingBufferMinutes       Int?                           @default(60)
  slug                          String?                        @unique
  createdAt                     DateTime                       @default(now())
  updatedAt                     DateTime                       @updatedAt
  appointmentTypes              AppointmentType[]
  callLogs                      CallLog[]
  nexhealthWebhookSubscriptions NexhealthWebhookSubscription[]
  assistantConfig               PracticeAssistantConfig?
  providers                     Provider[]
  toolLogs                      ToolLog[]
  savedOperatories              SavedOperatory[]
  savedProviders                SavedProvider[]
  webBookings                   WebBooking[]
}

model SavedProvider {
  id                       String                            @id @default(cuid())
  practiceId               String
  providerId               String
  isActive                 Boolean                           @default(true)
  createdAt                DateTime                          @default(now())
  updatedAt                DateTime                          @updatedAt
  acceptedAppointmentTypes ProviderAcceptedAppointmentType[]
  assignedOperatories      ProviderOperatoryAssignment[]
  practice                 Practice                          @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  provider                 Provider                          @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([practiceId, providerId])
  @@map("saved_providers")
}

model ProviderAcceptedAppointmentType {
  id                String          @id @default(cuid())
  savedProviderId   String
  appointmentTypeId String
  createdAt         DateTime        @default(now())
  appointmentType   AppointmentType @relation("ProviderAcceptedTypes", fields: [appointmentTypeId], references: [id], onDelete: Cascade)
  savedProvider     SavedProvider   @relation(fields: [savedProviderId], references: [id], onDelete: Cascade)

  @@unique([savedProviderId, appointmentTypeId])
  @@map("provider_accepted_appointment_types")
}

model ProviderOperatoryAssignment {
  id               String         @id @default(cuid())
  savedProviderId  String
  savedOperatoryId String
  createdAt        DateTime       @default(now())
  savedOperatory   SavedOperatory @relation(fields: [savedOperatoryId], references: [id], onDelete: Cascade)
  savedProvider    SavedProvider  @relation(fields: [savedProviderId], references: [id], onDelete: Cascade)

  @@unique([savedProviderId, savedOperatoryId])
  @@map("provider_operatory_assignments")
}

model SavedOperatory {
  id                   String                        @id @default(cuid())
  practiceId           String
  nexhealthOperatoryId String
  name                 String
  isActive             Boolean                       @default(true)
  createdAt            DateTime                      @default(now())
  updatedAt            DateTime                      @updatedAt
  assignedToProviders  ProviderOperatoryAssignment[]
  practice             Practice                      @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  @@unique([practiceId, nexhealthOperatoryId])
  @@map("saved_operatories")
}

model PracticeAssistantConfig {
  id              String   @id @default(cuid())
  practiceId      String   @unique
  vapiAssistantId String?  @unique
  voiceProvider   String   @default("11labs")
  voiceId         String   @default("burt")
  systemPrompt    String   @default("You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.")
  firstMessage    String   @default("Hello! This is Laine from your dental office. How can I help you today?")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  practice        Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
}

model GlobalNexhealthWebhookEndpoint {
  id                  String   @id @default("singleton")
  nexhealthEndpointId String   @unique
  secretKey           String
  targetUrl           String
  isEnabled           Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

model NexhealthWebhookSubscription {
  id                         String   @id @default(cuid())
  practiceId                 String
  nexhealthWebhookEndpointId String
  nexhealthSubscriptionId    String   @unique
  resourceType               String
  eventName                  String
  isActive                   Boolean  @default(true)
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt
  practice                   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  @@unique([practiceId, resourceType, eventName])
}

model CallLog {
  id                            String    @id @default(cuid())
  vapiCallId                    String    @unique
  practiceId                    String
  callTimestampStart            DateTime?
  callStatus                    String?
  transcriptText                String?
  summary                       String?
  vapiTranscriptUrl             String?
  detectedIntent                String?
  nexhealthPatientId            String?
  bookedAppointmentNexhealthId  String?
  conversationState             Json?
  patientStatus                 String?
  originalPatientRequestForType String?
  assistantId                   String?
  endedReason                   String?
  callDurationSeconds           Int?
  cost                          Decimal?
  createdAt                     DateTime  @default(now())
  updatedAt                     DateTime  @updatedAt
  practice                      Practice  @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  toolLogs                      ToolLog[]
}

model ToolLog {
  id              String   @id @default(cuid())
  practiceId      String
  vapiCallId      String?
  toolName        String
  toolCallId      String
  arguments       String?
  result          String?
  success         Boolean
  error           String?
  executionTimeMs Int?
  apiResponses    Json?    @db.Json
  stateBefore     Json?    @db.Json
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  practice        Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  callLog         CallLog? @relation(fields: [vapiCallId], references: [vapiCallId], onDelete: Cascade)

  @@index([practiceId, toolName])
  @@index([vapiCallId])
}

model AppointmentType {
  id                             String                            @id @default(cuid())
  practiceId                     String
  nexhealthAppointmentTypeId     String
  name                           String
  duration                       Int
  bookableOnline                 Boolean?
  spokenName                     String?
  check_immediate_next_available Boolean                           @default(false)
  keywords                       String?
  parentType                     String?
  parentId                       String?
  lastSyncError                  String?
  webPatientStatus               PatientWebStatus                  @default(BOTH)
  createdAt                      DateTime                          @default(now())
  updatedAt                      DateTime                          @updatedAt
  practice                       Practice                          @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  acceptedByProviders            ProviderAcceptedAppointmentType[] @relation("ProviderAcceptedTypes")
  webBookings                    WebBooking[]

  @@unique([practiceId, nexhealthAppointmentTypeId])
}

model Provider {
  id                  String          @id @default(cuid())
  practiceId          String
  nexhealthProviderId String
  firstName           String?
  lastName            String
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  practice            Practice        @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  savedByPractices    SavedProvider[]

  @@unique([practiceId, nexhealthProviderId])
}

model NexhealthTokenCache {
  id          String   @id @default("singleton")
  accessToken String
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model WebBooking {
  id                  String    @id @default(cuid())
  practiceId          String
  appointmentTypeId   String
  status              String    // e.g., "COMPLETED", "ABANDONED"
  
  // Patient Info
  patientFirstName    String
  patientLastName     String
  patientDob          String?   // Optional as it might not be collected for new patients initially
  patientEmail        String
  patientPhone        String
  patientStatus       String    // "NEW" or "RETURNING"
  
  // Appointment Info
  selectedSlotTime    DateTime
  notes               String?
  nexhealthBookingId  String?   @unique
  nexhealthPatientId  String?
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  practice            Practice        @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  appointmentType     AppointmentType @relation(fields: [appointmentTypeId], references: [id], onDelete: Cascade)

  @@index([practiceId])
  @@index([appointmentTypeId])
}

================
File: types/vapi.ts
================
// Core VAPI TypeScript type definitions for type safety
// These types are based on VAPI API documentation and webhook specifications

import type { ConversationState } from './laine';



// Interface for tool chaining directive
export interface NextTool {
  toolName: string;
  toolArguments: Record<string, any>;
}

// Interface for individual slot data
export interface SlotData {
  time: string; // ISO format
  operatory_id?: number;
  providerId: number;
}

// Interface for checkAvailableSlots structured result data
export interface CheckSlotsResultData {
  foundSlots: SlotData[];
  nextAvailableDate: string | null;
}

// Updated HandlerResult interface to support tool chaining
export interface HandlerResult {
  toolResponse: VapiToolResult;
  newState: ConversationState;
  nextTool?: NextTool; // Optional field for autonomous tool chaining
}

// ConversationState has been moved to @/types/laine for the new canonical interface

export interface VapiToolFunctionParameters {
  type: "object";
  properties: {
    [key: string]: {
      type: "string" | "number" | "boolean";
      description: string;
    };
  };
  required?: string[];
}

export interface VapiToolFunction {
  name: string;
  description: string;
  parameters: VapiToolFunctionParameters;
}

export interface VapiToolServer {
  url: string;
  timeoutSeconds?: number;
  async?: boolean;
}

export interface VapiTool {
  type: "function";
  function: VapiToolFunction;
  server: VapiToolServer;
  messages?: any[]; // Define more strictly if custom messages are used
}

export interface VapiUpdatePayload {
  model: {
    provider: "openai";
    model: string;
    temperature?: number;
    messages: Array<{
      role: "system" | "user" | "assistant";
      content: string;
    }>;
    tools?: VapiTool[]; // Array of tool definitions
    toolIds?: string[];
  };
  voice: {
    provider: string;
    voiceId: string;
  };
  firstMessage: string;
  serverUrl?: string;
  serverMessages?: string[];
}

export interface VapiFunctionCall {
  name: string;
  arguments: Record<string, any> | string; // Arguments can be an object or a stringified JSON
}

export interface ServerMessageToolCallItem {
  id: string; // This is VAPI's unique ID for this specific tool invocation
  type: "function"; // Assuming 'function' type for these tool calls
  function: VapiFunctionCall; // Contains the actual name and arguments
}

export interface ServerMessageToolCallsPayload {
  message: {
    type: "tool-calls";
    toolCallList?: ServerMessageToolCallItem[]; // VAPI payload shows 'toolCallList'
    toolCalls?: ServerMessageToolCallItem[]; // VAPI payload also shows 'toolCalls'
    call: {
      id: string;
      orgId?: string;
    };
  };
}

export interface VapiFunctionCall {
  type: 'function';
  function: {
    name: string;
    arguments: string; // Arguments must be a JSON string
  };
}

export interface VapiToolResult {
  toolCallId: string;
  result?: string | Record<string, any>;
  error?: string;
  message?: {
    type: string;
    role: string;
    content: string;
  };
  followUpFunctionCall?: VapiFunctionCall; // Add this new property
}

// === VAPI Webhook Message Types ===

// Base message structure for all VAPI webhook events
export interface VapiBaseMessage {
  timestamp: number;
  type: string; // The crucial field, e.g., "status-update", "transcript", "end-of-call-report"
  call?: {
    id: string;
    orgId?: string;
    assistantId?: string;
    status?: string;
    startedAt?: string;
    endedAt?: string;
    endedReason?: string;
    cost?: string;
  };
  assistant?: {
    id: string;
    name?: string;
  };
}

// Status update message (e.g., call started, ended, etc.)
export interface VapiStatusUpdateMessage extends VapiBaseMessage {
  type: "status-update";
  status?: string; // e.g., "queued", "ringing", "in-progress", "ended"
  endedReason?: string; // e.g., "customer-ended-call", "assistant-ended-call"
  call: {
    id: string;
    orgId?: string;
    assistantId: string;
    status: string;
    startedAt?: string;
    endedAt?: string;
    endedReason?: string;
    cost?: string;
  };
}

// End of call report message with summary and final details
export interface VapiEndOfCallReportMessage extends VapiBaseMessage {
  type: "end-of-call-report";
  summary?: string;
  transcript?: {
    url?: string;
    text?: string;
  };
  call: {
    id: string;
    orgId?: string;
    assistantId: string;
    status: string;
    startedAt?: string;
    endedAt?: string;
    endedReason?: string;
    cost?: string;
  };
}

// Transcript message for real-time or full transcript updates
export interface VapiTranscriptMessage extends VapiBaseMessage {
  type: "transcript";
  transcript?: {
    text?: string;
    url?: string;
  };
  call: {
    id: string;
    orgId?: string;
    assistantId: string;
    status?: string;
    startedAt?: string;
  };
}

// Union type for all possible VAPI webhook messages
export type VapiWebhookMessage = 
  | VapiStatusUpdateMessage 
  | VapiEndOfCallReportMessage 
  | VapiTranscriptMessage 
  | VapiBaseMessage;

// Complete webhook payload structure
export interface VapiWebhookPayload {
  message: VapiWebhookMessage;
  // Potentially other top-level fields from VAPI if any
} 

export interface ApiLogEntry {
  timestamp: string;
  method: string;
  url: string;
  body: unknown;
  headers: Record<string, string>;
  response?: {
    status?: number;
    statusText?: string;
    body?: unknown;
    success: boolean;
    error?: string;
  };
}

export type ApiLog = ApiLogEntry[];

================
File: app/api/vapi-webhook/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

import { handleFindAppointmentType } from '@/lib/tool-handlers/findAppointmentTypeHandler';
import { handleCheckAvailableSlots } from '@/lib/tool-handlers/checkAvailableSlotsHandler';
import { handleSelectAndBookSlot } from '@/lib/tool-handlers/selectAndBookSlotHandler';
import { handleInsuranceInfo } from '@/lib/tool-handlers/insuranceInfoHandler';
import { handleIdentifyPatient } from '@/lib/tool-handlers/identifyPatientHandler';
import { Liquid } from 'liquidjs';
import { readFileSync } from 'fs';
import { join } from 'path';
import type { 
  ServerMessageToolCallsPayload, 
  HandlerResult,
  ServerMessageToolCallItem
} from '@/types/vapi';
import type { ConversationState } from '@/types/laine';
import { Prisma } from '@prisma/client';

export async function POST(request: Request) {
  const startTime = Date.now();
  let handlerResult: HandlerResult | undefined;
  let toolCall: ServerMessageToolCallItem | undefined;

  try {
    const body: ServerMessageToolCallsPayload = await request.json();
    const message = body.message;

    if (message?.type !== 'tool-calls') {
      return NextResponse.json({ message: "Ignoring non-tool-call message" });
    }

    // Extract the first tool call and call ID
    toolCall = message.toolCallList?.[0] || message.toolCalls?.[0];
    const callId = message.call.id;

    if (!toolCall || !callId) {
      console.error("[VAPI Webhook] Malformed payload, missing toolCall or callId:", message);
      return NextResponse.json({ 
        results: [{ toolCallId: "unknown", error: "Malformed tool call payload from VAPI." }] 
      }, { status: 200 });
    }

    // Get practice ID for database operations
    const firstPractice = await prisma.practice.findFirst();
    const practiceId = firstPractice?.id ?? "unknown";

    // Ensure callLog exists
    await prisma.callLog.upsert({
      where: { vapiCallId: callId },
      update: { updatedAt: new Date() },
      create: {
        vapiCallId: callId,
        practiceId: practiceId,
        callStatus: "TOOL_INTERACTION_STARTED",
        callTimestampStart: new Date(),
      },
    });

    // State management: retrieve or initialize conversation state
    let state: ConversationState;
    const callLog = await prisma.callLog.findUniqueOrThrow({ where: { vapiCallId: callId } });

    if (callLog.conversationState && typeof callLog.conversationState === 'object' && callLog.conversationState !== null) {
      state = callLog.conversationState as unknown as ConversationState;
      console.log(`[StatefulWebhook] Retrieved state for call: ${callId}`);
    } else {
      // Initialize state with new canonical structure
      state = {
        callId: callId,
        practiceId: practiceId,
        patient: {
          status: 'UNKNOWN',
          isNameConfirmed: false
        },
        insurance: {
          status: 'NOT_CHECKED'
        },
        booking: {
          isUrgent: false,
          presentedSlots: []
        }
      };
      console.log(`[StatefulWebhook] Initialized new canonical state for call: ${callId}`);
    }

    // Get tool name and arguments
    const toolName = toolCall.function.name;
    let toolArguments = toolCall.function.arguments;

    if (typeof toolArguments === 'string') {
      try {
        toolArguments = JSON.parse(toolArguments);
      } catch (e) {
        console.error(`[VAPI Webhook] Failed to parse tool arguments string:`, e);
        return NextResponse.json({ 
          results: [{ toolCallId: toolCall.id, error: `Failed to parse arguments for tool ${toolName}.` }] 
        }, { status: 200 });
      }
    }

    console.log(`[VAPI Webhook] Processing tool: ${toolName} (ID: ${toolCall.id}) for Call: ${callId}`);
    console.log(`[VAPI Webhook] Arguments:`, toolArguments);

    // Create initial tool log entry
    try {
      await prisma.toolLog.create({
        data: {
          practiceId: practiceId,
          vapiCallId: callId,
          toolName: toolName,
          toolCallId: toolCall.id,
          arguments: JSON.stringify(toolArguments),
          stateBefore: JSON.stringify(state),
          success: false, // Default to false, will be updated on success
          createdAt: new Date(startTime),
          updatedAt: new Date(startTime),
        }
      });
      console.log(`[DB Log] Created initial ToolLog for ID: ${toolCall.id}`);
    } catch (logError) {
      console.error('[DB Log] Failed to create initial tool log:', logError);
    }

    console.log('[VAPI Webhook] State before processing:', JSON.stringify(state, null, 2));

    // Tool routing switch statement  
    switch (toolName) {
      case "findAppointmentType": {
        handlerResult = await handleFindAppointmentType(
          state,
          toolArguments as { patientRequest: string; patientStatus?: string },
          toolCall.id
        );
        break;
      }

      case "checkAvailableSlots": {
        handlerResult = await handleCheckAvailableSlots(
          state,
          toolArguments as { preferredDaysOfWeek?: string; timeBucket?: string; requestedDate?: string },
          toolCall.id
        );
        break;
      }

      case "identifyPatient": {
        handlerResult = await handleIdentifyPatient(
          state,
          toolArguments as {
            firstName: string;
            lastName: string;
            dateOfBirth: string;
            phoneNumber: string;
            email: string;
          },
          toolCall.id
        );
        break;
      }

      case "selectAndBookSlot": {
        handlerResult = await handleSelectAndBookSlot(
          state,
          toolArguments as { userSelection: string; finalConfirmation?: boolean },
          toolCall.id
        );
        break;
      }

      case "insuranceInfo": {
        handlerResult = await handleInsuranceInfo(
          state,
          toolArguments as { insuranceName?: string },
          toolCall.id
        );
        break;
      }

      default: {
        console.error(`[VAPI Webhook] Unknown tool: ${toolName}`);
        handlerResult = {
          toolResponse: {
            toolCallId: toolCall.id,
            error: `I'm sorry, I don't know how to handle the "${toolName}" tool. Please try again.`
          },
          newState: state
        };
        break;
      }
    }

    if (!handlerResult) {
      // This case should ideally not be reached if all tools are handled.
      console.error(`[VAPI Webhook] No handler result for tool: ${toolName}`);
      return NextResponse.json({ 
        results: [{ toolCallId: toolCall.id, error: "Internal error: tool handler did not produce a result." }] 
      }, { status: 200 });
    }

    // Tool chaining is no longer needed with the new consolidated selectAndConfirmSlot tool

    console.log('[VAPI Webhook] Final handler result after processing:', JSON.stringify(handlerResult, null, 2));
    
    // Use the exact newState object from the handler's result for all subsequent operations.
    const newState = handlerResult.newState;

    // Atomically save the new, complete state to the database.
    await prisma.callLog.update({
      where: { vapiCallId: callId },
      data: { conversationState: newState as unknown as Prisma.InputJsonValue }
    });
    console.log(`[StatefulWebhook] Persisted state for call: ${callId}`);

    // Render the system prompt using the guaranteed fresh state.
    try {
      const liquid = new Liquid();
      const promptPath = join(process.cwd(), 'lib/system-prompt/laine_system_prompt.md');
      const promptTemplate = readFileSync(promptPath, 'utf-8');
      
      const renderedSystemPrompt = await liquid.parseAndRender(promptTemplate, newState);
      
      console.log(`[State Injection] Successfully rendered system prompt with fresh state`);

      // Construct and return the final response for VAPI
      return NextResponse.json({ 
        results: [handlerResult.toolResponse],
        systemPrompt: renderedSystemPrompt
      });
    } catch (promptError) {
      console.error('[State Injection] Error rendering system prompt:', promptError);
      
      // Fallback to original response without state injection
      return NextResponse.json({ results: [handlerResult.toolResponse] });
    }

  } catch (error) {
    console.error('Error in VAPI webhook:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  } finally {
    if (toolCall?.id && startTime && handlerResult) {
      const executionTimeMs = Date.now() - startTime;
      const isSuccess = !!handlerResult.toolResponse?.message && handlerResult.toolResponse.message.type !== 'request-failed';

      try {
        await prisma.toolLog.updateMany({
          where: { toolCallId: toolCall.id },
          data: {
            result: handlerResult?.toolResponse?.result ? JSON.stringify(handlerResult.toolResponse.result, null, 2) : undefined,
            error: !isSuccess ? JSON.stringify(handlerResult?.toolResponse, null, 2) : undefined,
            success: isSuccess,
            executionTimeMs: executionTimeMs,
            apiResponses: handlerResult?.toolResponse?.result && typeof handlerResult.toolResponse.result === 'object' && 'apiLog' in handlerResult.toolResponse.result ? JSON.stringify(handlerResult.toolResponse.result.apiLog, null, 2) : undefined,
            updatedAt: new Date(),
          }
        });
        console.log(`[DB Log] Finalized ToolLog for ID: ${toolCall.id} with success: ${isSuccess}`);
      } catch (logError) {
        console.error('[DB Log] Failed to finalize tool log:', logError);
      }
    }
  }
}

================
File: lib/tool-handlers/findAppointmentTypeHandler.ts
================
import { prisma } from "@/lib/prisma";
import { matchAppointmentTypeIntent } from "@/lib/ai/appointmentMatcher";
import { generateAcknowledgment } from '@/lib/ai/acknowledgmentGenerator';

import type { HandlerResult, ApiLog } from "@/types/vapi";
import type { ConversationState } from "@/types/laine";
import { mergeState } from '@/lib/utils/state-helpers';

interface FindAppointmentTypeArgs {
  patientRequest: string;
  patientStatus?: string;
}

export async function handleFindAppointmentType(
  currentState: ConversationState,
  toolArguments: FindAppointmentTypeArgs,
  toolId: string
): Promise<HandlerResult> {
  const { patientRequest, patientStatus } = toolArguments;
  
  // Initialize API log array to capture all external calls
  const apiLog: ApiLog = [];
  
  console.log(`[FindAppointmentTypeHandler] Processing request: "${patientRequest}", patientStatus: "${patientStatus}"`);
  
  // Generate AI-powered acknowledgment based on patient request
  const acknowledgment = await generateAcknowledgment(patientRequest);
  console.log(`[FindAppointmentTypeHandler] Generated acknowledgment: "${acknowledgment}"`);
  
  try {
    if (!currentState.practiceId) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Practice configuration not found."
        },
        newState: currentState
      };
    }

    if (!patientRequest) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Missing patientRequest parameter."
        },
        newState: currentState
      };
    }

    console.log(`[FindAppointmentTypeHandler] Using practice: ${currentState.practiceId}`);

    // Fetch appointment types with keywords for this practice (only bookable online)
    const dbAppointmentTypes = await prisma.appointmentType.findMany({
      where: {
        practiceId: currentState.practiceId,
        bookableOnline: true, // Only include appointment types that are active for online booking
        AND: [
          { keywords: { not: null } },
          { keywords: { not: "" } }
        ]
      },
      select: {
        nexhealthAppointmentTypeId: true,
        name: true,
        duration: true,
        keywords: true,
        check_immediate_next_available: true,
        spokenName: true
      }
    });

    if (!dbAppointmentTypes || dbAppointmentTypes.length === 0) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "No suitable appointment types are configured for matching in this practice."
        },
        newState: currentState
      };
    }

    console.log(`[FindAppointmentTypeHandler] Found ${dbAppointmentTypes.length} appointment types with keywords`);

    // Use AI to match the patient request to appointment types
    const matchedApptId = await matchAppointmentTypeIntent(
      patientRequest,
      dbAppointmentTypes.map(at => ({
        id: at.nexhealthAppointmentTypeId,
        name: at.name,
        keywords: at.keywords || "",
      }))
    );

    if (!matchedApptId) {
      console.log(`[FindAppointmentTypeHandler] No appointment type matched for request: "${patientRequest}"`);

      return {
        toolResponse: {
          toolCallId: toolId,
          result: { apiLog: apiLog },
          message: {
            type: "request-failed",
            role: "assistant",
            content: "I understand you're looking for an appointment, but I couldn't determine the exact type of service you need. Could you please be more specific?"
          }
        },
        newState: currentState
      };
    }

    // Find the matched appointment type's details 
    const matchedAppointmentType = dbAppointmentTypes.find(at => 
      at.nexhealthAppointmentTypeId === matchedApptId
    );

    if (!matchedAppointmentType) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Error retrieving appointment type details."
        },
        newState: currentState
      };
    }

    console.log(`[FindAppointmentTypeHandler] Successfully found appointment type: ${matchedAppointmentType.name}`);

    // Create new state with appointment booking details
    const newState = mergeState(currentState, {
              booking: {
        appointmentTypeId: matchedAppointmentType.nexhealthAppointmentTypeId,
        appointmentTypeName: matchedAppointmentType.name,
        spokenName: matchedAppointmentType.spokenName || matchedAppointmentType.name,
        duration: matchedAppointmentType.duration,
        isUrgent: matchedAppointmentType.check_immediate_next_available
      }
    });

    // Log the successful state update for debugging
    console.log('[FindAppointmentTypeHandler] State updated with appointmentTypeId:', newState.booking.appointmentTypeId);
    console.log('[FindAppointmentTypeHandler] Full updated booking state:', JSON.stringify(newState.booking, null, 2));

    // The tool's job is now ONLY to identify the type and update the state.
    // The system prompt will guide the next conversational step.
    // We return a simple success result without a message to ensure the state is saved
    // and let the LLM decide the next step based on the updated state.
    return {
      newState: newState,
      toolResponse: {
        toolCallId: toolId,
        result: {
          success: true,
          acknowledgment: acknowledgment,
          appointmentTypeId: matchedAppointmentType.nexhealthAppointmentTypeId,
          appointmentTypeName: matchedAppointmentType.name,
          spokenName: matchedAppointmentType.spokenName || matchedAppointmentType.name,
          duration: matchedAppointmentType.duration,
          isUrgent: matchedAppointmentType.check_immediate_next_available,
          apiLog: apiLog
        }
        // By not including a "message", we allow the LLM to decide the next conversational step
        // based on the updated state and the system prompt's guidance.
      }
    };

  } catch (error) {
    console.error(`[FindAppointmentTypeHandler] Error processing appointment type:`, error);
    return {
      toolResponse: {
        toolCallId: toolId,
        result: { apiLog: apiLog },
        error: "Database error while fetching appointment types."
      },
      newState: currentState
    };
  }
}

================
File: lib/tools/index.ts
================
import type { VapiTool } from '@/types/vapi';
import { getFindAppointmentTypeTool } from './definitions/findAppointmentTypeTool';
import { getIdentifyPatientTool } from './definitions/identifyPatientTool';
import { getCheckAvailableSlotsTool } from './definitions/checkAvailableSlotsTool';
import { getSelectAndBookSlotTool } from './definitions/selectAndBookSlotTool';
import { getInsuranceInfoTool } from './definitions/insuranceInfoTool';

/**
 * Central map of all tool definitions
 * Keys are tool names, values are tool-getter functions
 */
export const toolDefinitionMap = {
  findAppointmentType: getFindAppointmentTypeTool,
  identifyPatient: getIdentifyPatientTool,
  checkAvailableSlots: getCheckAvailableSlotsTool,
  selectAndBookSlot: getSelectAndBookSlotTool,
  insuranceInfo: getInsuranceInfoTool,
};

/**
 * Aggregate all individual tool definitions for use when updating the VAPI assistant
 * @param appBaseUrl - The base URL for the application (used in tool server URLs)
 * @returns Array of all available VAPI tool definitions
 */
export function getAllTools(appBaseUrl: string): VapiTool[] {
  const tools: VapiTool[] = Object.values(toolDefinitionMap).map(getToolFn => getToolFn(appBaseUrl));
  return tools;
}

================
File: lib/tool-handlers/checkAvailableSlotsHandler.ts
================
import { prisma } from "@/lib/prisma";
import { normalizeDateWithAI, findAvailableSlots, generateTimeBucketResponse, generateSlotResponse, TIME_BUCKETS, type TimeBucket } from "@/lib/ai/slotHelper";
import { DateTime } from "luxon";
import type { HandlerResult, ApiLog } from "@/types/vapi";
import type { ConversationState } from "@/types/laine";
import { mergeState } from '@/lib/utils/state-helpers';

interface CheckAvailableSlotsArgs {
  preferredDaysOfWeek?: string;
  timeBucket?: string;
  requestedDate?: string;
  searchWindowDays?: number;
}

export async function handleCheckAvailableSlots(
  currentState: ConversationState,
  toolArguments: CheckAvailableSlotsArgs,
  toolId: string
): Promise<HandlerResult> {
  const { requestedDate, timeBucket, preferredDaysOfWeek, searchWindowDays } = toolArguments;
  
  // Initialize API log array to capture all external calls
  const apiLog: ApiLog = [];
  
  console.log(`[CheckAvailableSlotsHandler] Processing with requestedDate: "${requestedDate}", timeBucket: "${timeBucket}", preferredDaysOfWeek: "${preferredDaysOfWeek}", searchWindowDays: ${searchWindowDays}`);
  
  try {
    try {
      if (!currentState.practiceId) {
        return {
          toolResponse: {
            toolCallId: toolId,
            error: "Practice configuration not found."
          },
          newState: currentState
        };
      }

      if (!currentState.booking.appointmentTypeId) {
        return {
          toolResponse: {
            toolCallId: toolId,
            error: "Error: I must know the reason for the visit before checking for appointments. I need to use the findAppointmentType tool first."
          },
          newState: currentState
        };
      }

    // Fetch practice details
    const practice = await prisma.practice.findUnique({
      where: { id: currentState.practiceId },
      select: {
        id: true,
        timezone: true,
        nexhealthSubdomain: true,
        nexhealthLocationId: true,
      }
    });

    if (!practice || !practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Practice NexHealth configuration not found."
        },
        newState: currentState
      };
    }

    // 1. UNIFIED DATE DETERMINATION LOGIC (prioritizes proactive "first available" search)
    let searchDate: string | null = null;

    // Priority 0: Handle system-initiated urgent search
    if (searchWindowDays) {
      console.log(`[CheckAvailableSlotsHandler] Proactive urgent search triggered for ${searchWindowDays} days.`);
      searchDate = DateTime.now().setZone(practice.timezone || 'America/Chicago').toFormat('yyyy-MM-dd');
    }
    // Priority 1: Handle explicit user date request
    else if (requestedDate) {
      console.log(`[CheckAvailableSlotsHandler] User provided a specific date: "${requestedDate}". Normalizing...`);
      searchDate = await normalizeDateWithAI(requestedDate, practice.timezone || 'America/Chicago');
      if (!searchDate) {
        return {
          toolResponse: {
            toolCallId: toolId,
            result: `I couldn't quite understand the date "${requestedDate}". Could you try saying it a different way?`
          },
          newState: currentState
        };
      }
      console.log(`[CheckAvailableSlotsHandler] Normalized date to: ${searchDate}`);
    } 
    // Priority 2: Handle preferred days of week
    else if (preferredDaysOfWeek) {
      try {
        const preferredDays = JSON.parse(preferredDaysOfWeek);
        if (Array.isArray(preferredDays) && preferredDays.length > 0) {
          const dayName = preferredDays[0]; // Taking the first preferred day
          const dayIndex = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'].indexOf(dayName.toLowerCase());
          
          if (dayIndex !== -1) {
            let searchDateTime = DateTime.now().setZone(practice.timezone || 'America/Chicago');
            
            // Find the next occurrence of the preferred day
            // If today is the preferred day, we'll still look for next occurrence to avoid booking too last minute
            do {
              searchDateTime = searchDateTime.plus({ days: 1 });
            } while (searchDateTime.weekday % 7 !== dayIndex);
            
            searchDate = searchDateTime.toFormat('yyyy-MM-dd');
            console.log(`[CheckAvailableSlotsHandler] Calculated next ${dayName} as: ${searchDate}`);
          } else {
            console.error(`[CheckAvailableSlotsHandler] Invalid day name: ${dayName}`);
          }
        }
      } catch (e) {
        console.error("[CheckAvailableSlotsHandler] Could not parse preferredDaysOfWeek", e);
      }
    }

    // Priority 3: DEFAULT PROACTIVE PATH - "First Available" search (NEW DEFAULT BEHAVIOR)
    if (!searchDate) {
      console.log(`[CheckAvailableSlotsHandler] No user preference detected. Initiating default 'first available' search.`);
      const nowInPracticeTimezone = DateTime.now().setZone(practice.timezone || 'America/Chicago');
      searchDate = nowInPracticeTimezone.toFormat('yyyy-MM-dd');
      console.log(`[CheckAvailableSlotsHandler] Default 'first available' flow. Search date explicitly set to: ${searchDate} (timezone: ${practice.timezone || 'America/Chicago'})`);
      console.log(`[CheckAvailableSlotsHandler] DateTime debug - now: ${DateTime.now().toISO()}, in timezone: ${nowInPracticeTimezone.toISO()}, formatted: ${searchDate}`);
    }

    // 2. DETERMINE SEARCH WINDOW
    const { isUrgent } = currentState.booking;
    const isImmediateBooking = isUrgent; // Treat isUrgent as isImmediateBooking for now
    let searchDays: number;
    
    if (searchWindowDays) {
      searchDays = searchWindowDays; // Use the system-specified window for urgent proactive search
    } else if (requestedDate) {
      searchDays = 1; // Search only the specific requested date
    } else if (isUrgent || isImmediateBooking) {
      searchDays = 7; // Search 7 days for urgent appointments if no specific date requested
    } else if (!requestedDate && !preferredDaysOfWeek && !timeBucket) {
      // This is the new default "first available" path - search more days for better options
      searchDays = 14; // Expanded search window for proactive first-available flow
      console.log(`[CheckAvailableSlotsHandler] Using expanded 14-day search window for 'first available' flow.`);
    } else {
      searchDays = 3; // Search 3 days for other flows
    }

    // 3. PERFORM THE SEARCH
    const searchResult = await findAvailableSlots(
      currentState.booking.appointmentTypeId,
      {
        id: practice.id,
        nexhealthSubdomain: practice.nexhealthSubdomain!,
        nexhealthLocationId: practice.nexhealthLocationId!,
        timezone: practice.timezone || 'America/Chicago'
      },
      searchDate,
      searchDays,
      timeBucket as TimeBucket
    );

    // 3.5. DETECT DELAYED AVAILABILITY
    let isDelayedAvailability = false;
    if (searchResult.foundSlots.length > 0) {
      const searchDateTime = DateTime.fromISO(searchDate, { zone: practice.timezone || 'America/Chicago' });
      const firstSlotTime = DateTime.fromISO(searchResult.foundSlots[0].time, { zone: practice.timezone || 'America/Chicago' });
      const daysUntilFirstSlot = firstSlotTime.diff(searchDateTime, 'days').days;

      if (daysUntilFirstSlot > 2) {
        isDelayedAvailability = true;
        console.log(`[CheckAvailableSlotsHandler] Delayed availability detected. First slot is ${daysUntilFirstSlot.toFixed(1)} days from search date.`);
      }
    }

    // 4. SLOTS ARE NOW PRE-FILTERED BY findAvailableSlots
    const filteredSlots = searchResult.foundSlots;

    const spokenName = currentState.booking.spokenName || currentState.booking.appointmentTypeName || 'appointment';

    // 4. DECIDE HOW TO RESPOND BASED ON FLOW TYPE
    
    // Decide whether to present specific slots or time buckets
    const shouldPresentSpecificSlots = (isUrgent || isImmediateBooking) || timeBucket;

    if (shouldPresentSpecificSlots) {
      console.log(`[CheckAvailableSlotsHandler] Presenting specific slots. isUrgent: ${isUrgent}, isImmediateBooking: ${isImmediateBooking}, timeBucket provided: ${!!timeBucket}`);

      const aiResponse = await generateSlotResponse(
        searchResult, // searchResult already contains the pre-filtered slots
        spokenName,
        practice.timezone || 'America/Chicago'
      );

      // Create new state with slots data
      const newState = mergeState(currentState, {
        booking: {
          presentedSlots: searchResult.foundSlots
        }
      });

      return {
        newState: newState,
        toolResponse: {
          toolCallId: toolId,
          result: { // Structured data payload
            foundSlots: searchResult.foundSlots,
            nextAvailableDate: searchResult.nextAvailableDate || null,
            isDelayedAvailability: isDelayedAvailability,
            apiLog: apiLog
          },
          message: { // High-fidelity message
            type: "request-complete",
            role: "assistant",
            content: aiResponse // The AI-generated response from generateSlotResponse
          }
        }
      };

    } else {
      // STANDARD FLOW - First pass, present time buckets
      console.log('[CheckAvailableSlotsHandler] Presenting time buckets for standard flow.');
      
      // Generate response with time buckets based on filteredSlots
      const availableBuckets: string[] = [];
      const primaryBuckets = ['Morning', 'Afternoon', 'Evening'] as const;
      
      for (const bucket of primaryBuckets) {
        const bucketRange = TIME_BUCKETS[bucket];
        const [startHour, startMinute] = bucketRange.start.split(':').map(Number);
        const [endHour, endMinute] = bucketRange.end.split(':').map(Number);
        
        const hasSlotInBucket = filteredSlots.some(slot => {
          const slotTime = DateTime.fromISO(slot.time);
          const slotHour = slotTime.hour;
          const slotMinute = slotTime.minute;
          
          const slotTimeInMinutes = slotHour * 60 + slotMinute;
          const startTimeInMinutes = startHour * 60 + startMinute;
          const endTimeInMinutes = endHour * 60 + endMinute;
          
          return slotTimeInMinutes >= startTimeInMinutes && slotTimeInMinutes <= endTimeInMinutes;
        });
        
        if (hasSlotInBucket) {
          availableBuckets.push(bucket);
        }
      }

      console.log(`[CheckAvailableSlotsHandler] Found slots in time buckets: ${availableBuckets.join(', ')}`);

      // Generate the day of week for the response
      const searchDateTime = DateTime.fromISO(searchDate, { zone: practice.timezone || 'America/Chicago' });
      const dayOfWeek = searchDateTime.toFormat('cccc'); // e.g., "Thursday"
      
      // Use the time bucket response generator
      const aiResponse = await generateTimeBucketResponse(
        availableBuckets,
        dayOfWeek,
        spokenName
      );

      console.log(`[CheckAvailableSlotsHandler] Successfully presented ${availableBuckets.length} time bucket options for ${filteredSlots.length} total slots`);

      // Create new state with slots data
      const newState = mergeState(currentState, {
        booking: {
          presentedSlots: filteredSlots
        }
      });

      return {
        newState: newState,
        toolResponse: {
          toolCallId: toolId,
          result: { // Structured data payload
            foundSlots: filteredSlots, // Note: we return all filtered slots here
            nextAvailableDate: searchResult.nextAvailableDate || null,
            isDelayedAvailability: isDelayedAvailability,
            apiLog: apiLog
          },
          message: { // High-fidelity message
            type: "request-complete",
            role: "assistant",
            content: aiResponse // The AI-generated response from generateTimeBucketResponse
          }
        }
      };
    }

    } catch (error) {
      console.error(`[CheckAvailableSlotsHandler] Error during slot search:`, error);
      if (error instanceof Error && error.message.includes("Configuration Error")) {
        // This is a configuration problem, not a lack of availability.
        return {
          toolResponse: {
            toolCallId: toolId,
            error: `There's a configuration issue with the '${currentState.booking.spokenName}' appointment type. I cannot check for slots. Please inform the user that a staff member will call them back to schedule this specific appointment type.`
          },
          newState: currentState
        };
      }
      // Generic fallback error for other issues
      return {
        toolResponse: {
          toolCallId: toolId,
          result: { apiLog: apiLog },
          error: "I encountered a system error while checking for available appointments."
        },
        newState: currentState
      };
    }

  } catch (error) {
    console.error(`[CheckAvailableSlotsHandler] Outer error catching available slots:`, error);
    return {
      toolResponse: {
        toolCallId: toolId,
        result: { apiLog: apiLog },
        error: "Error checking available appointment slots."
      },
      newState: currentState
    };
  }
}

================
File: lib/ai/slotHelper.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import { DateTime } from "luxon";
import type { CoreMessage } from "ai";

/**
 * Defines the time ranges for different parts of the day.
 * Used to filter appointment slots based on user preference.
 * Note: 'Morning' and 'Afternoon' are broad, while others are more specific.
 * 'Midday' overlaps with both Morning and Afternoon to catch appointments around noon.
 */
export const TIME_BUCKETS = {
  Early:     { start: "05:00", end: "08:30" },
  Morning:   { start: "05:00", end: "12:00" },
  Midday:    { start: "10:00", end: "15:00" },
  Afternoon: { start: "12:00", end: "17:00" },
  Evening:   { start: "15:30", end: "20:00" },
  Late:      { start: "17:00", end: "22:00" },
  AllDay:    { start: "05:00", end: "22:00" }
};

export type TimeBucket = keyof typeof TIME_BUCKETS;

/**
 * Normalize a date query using AI to convert natural language dates into YYYY-MM-DD format
 */
export async function normalizeDateWithAI(
  dateQuery: string, 
  practiceTimezone: string
): Promise<string | null> {
  try {
    const now = DateTime.now().setZone(practiceTimezone);
    const systemPromptContent = `You are a date parsing AI. Your only task is to convert a user's spoken date query into a strict 'YYYY-MM-DD' format. The user is in the 'America/Chicago' timezone.

    Today's date is ${now.toFormat('yyyy-MM-dd')}.

    - Interpret "today" as ${now.toFormat('yyyy-MM-dd')}.
    - Interpret "tomorrow" as ${now.plus({ days: 1 }).toFormat('yyyy-MM-dd')}.
    - If the user provides a date like "July 23rd" and that date has already passed this year, assume they mean next year.
    - If a query is ambiguous or not a date, you MUST return 'INVALID_DATE'.

    Your entire response MUST be ONLY the 'YYYY-MM-DD' string or "INVALID_DATE". Do not add any other words.`;

    const userPromptContent = `User Query: "${dateQuery}"

Normalized Date (YYYY-MM-DD or INVALID_DATE):`;

    const messages: CoreMessage[] = [
      { role: 'system', content: systemPromptContent },
      { role: 'user', content: userPromptContent }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0,
      maxTokens: 50
    });

    const normalizedDate = text.trim();
    
    if (!normalizedDate || normalizedDate === "INVALID_DATE") {
      console.log(`[Date Normalization] Could not parse date: "${dateQuery}"`);
      return null;
    }

    // Validate the returned date format
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(normalizedDate)) {
      console.error(`[Date Normalization] AI returned invalid format: "${normalizedDate}"`);
      return null;
    }

    console.log(`[Date Normalization] Successfully parsed "${dateQuery}" → "${normalizedDate}"`);
    return normalizedDate;
  } catch (error) {
    console.error('[Date Normalization] Error:', error);
    return null;
  }
}

/**
 * Generate a natural spoken message presenting available slots or alternatives
 * @deprecated This function will be removed in a future refactor phase as we move to preference-based scheduling
 */
export async function generateSlotResponseMessage(
  appointmentTypeName: string,
  normalizedDate: string,
  availableSlots: string[],
  timePreference?: string
): Promise<string> {
  try {
    console.log(`[Slot Response] Generating message for ${appointmentTypeName} on ${normalizedDate}, ${availableSlots.length} slots available`);

    // Format the date for natural speech
    const dateObj = DateTime.fromISO(normalizedDate);
    const friendlyDate = dateObj.toFormat('EEEE, MMMM dd'); // e.g., "Monday, December 23"
    
    const timePreferenceText = timePreference ? ` ${timePreference}` : '';
    
    let prompt: string;

    if (availableSlots.length > 0) {
      const slotsList = availableSlots.slice(0, 3).join(', '); // Limit to first 3 slots
      const hasMoreSlots = availableSlots.length > 3;
      
      prompt = `You are Laine, a friendly dental assistant. Generate a natural response offering available appointment slots.

Appointment Type: ${appointmentTypeName}
Date: ${friendlyDate}
Time Preference: ${timePreference || 'none specified'}
Available slots: ${slotsList}${hasMoreSlots ? ' (and more)' : ''}

Create a natural, conversational response that:
1. Confirms the appointment type and date
2. Presents the available time slots (up to 3)
3. Asks if any of those work for the patient
4. Be warm and helpful

Keep it concise and natural. Return only the response text.

Example format: "Great! For your ${appointmentTypeName} on ${friendlyDate}${timePreferenceText}, I have ${slotsList} available. Would any of those work for you?"`;
    } else {
      prompt = `You are Laine, a friendly dental assistant. Generate a natural response when no appointment slots are available.

Appointment Type: ${appointmentTypeName}
Date: ${friendlyDate}
Time Preference: ${timePreference || 'none specified'}

Create a natural, apologetic response that:
1. Acknowledges the specific appointment type and date requested
2. Mentions if there was a time preference
3. Suggests trying a different date or removing time restrictions
4. Be empathetic and helpful

Keep it concise and natural. Return only the response text.

Example format: "I'm sorry, I don't have any available slots for your ${appointmentTypeName} on ${friendlyDate}${timePreferenceText}. Would you like to try a different date, or perhaps I can check for any availability that day without a specific time preference?"`;
    }

    const messages: CoreMessage[] = [
      {
        role: "user",
        content: prompt
      }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.3,
      maxTokens: 150
    });

    const message = text.trim();
    
    if (!message) {
      // Fallback message
      if (availableSlots.length > 0) {
        const slotsList = availableSlots.slice(0, 3).join(', ');
        return `For your ${appointmentTypeName} on ${friendlyDate}, I have ${slotsList} available. Would any of those work for you?`;
      } else {
        return `I'm sorry, I don't have any available slots for your ${appointmentTypeName} on ${friendlyDate}. Would you like to try a different date?`;
      }
    }

    console.log(`[Slot Response] Generated message: "${message}"`);
    return message;
  } catch (error) {
    console.error('[Slot Response] Error generating message:', error);
    
    // Fallback message
    if (availableSlots.length > 0) {
      const slotsList = availableSlots.slice(0, 3).join(', ');
      return `For your ${appointmentTypeName}, I have ${slotsList} available. Would any of those work for you?`;
    } else {
      return `I'm sorry, I don't have any available slots for your ${appointmentTypeName} on that date. Would you like to try a different date?`;
    }
  }
}

/**
 * Get slot search parameters for a specific appointment type from the database
 * @param appointmentTypeId NexHealth appointment type ID 
 * @param practiceId Practice ID
 * @returns Object with duration, providerIds, and operatoryIds needed for slot search
 */
export async function getSlotSearchParams(
  appointmentTypeId: string,
  practiceId: string
): Promise<{ duration: number; providerIds: string[]; operatoryIds: string[] }> {
  const { prisma } = await import("@/lib/prisma");

  // 1. Fetch the AppointmentType and include all related active providers and their operatories
  const appointmentType = await prisma.appointmentType.findFirst({
    where: {
      nexhealthAppointmentTypeId: appointmentTypeId,
      practiceId: practiceId,
    },
    include: {
      acceptedByProviders: { // This is the join table
        where: {
          savedProvider: {
            isActive: true, // Filter for active providers
          },
        },
        include: {
          savedProvider: {
            include: {
              provider: true, // Get the provider details (for the ID)
              assignedOperatories: { // Get the assigned operatories for this provider
                where: {
                  savedOperatory: {
                    isActive: true, // Filter for active operatories
                  },
                },
                include: {
                  savedOperatory: true, // Get the operatory details (for the ID)
                },
              },
            },
          },
        },
      },
    },
  });

  if (!appointmentType) {
    throw new Error(`Configuration Error: Appointment type with ID ${appointmentTypeId} not found for practice ${practiceId}.`);
  }

  const activeProviders = appointmentType.acceptedByProviders.map(
    (p) => p.savedProvider
  );

  if (activeProviders.length === 0) {
    throw new Error(`Configuration Error: No active providers are configured to accept the appointment type ID ${appointmentTypeId}.`);
  }

  // 2. Collect unique NexHealth provider IDs from the results
  const providerIds = Array.from(
    new Set(activeProviders.map((sp) => sp.provider.nexhealthProviderId))
  );

  // 3. Collect unique NexHealth operatory IDs from all found providers
  const operatoryIds = Array.from(
    new Set(
      activeProviders
        .flatMap((sp) => sp.assignedOperatories)
        .map((assignment) => assignment.savedOperatory.nexhealthOperatoryId)
    )
  );

  if (operatoryIds.length === 0) {
    throw new Error(`Configuration Error: The active providers for appointment type ID ${appointmentTypeId} have no active operatories assigned.`);
  }

  // 4. Return the collected data
  return {
    duration: appointmentType.duration,
    providerIds,
    operatoryIds,
  };
}

// Interface for individual slot data
interface SlotData {
  time: string;
  operatory_id?: number;
  providerId: number;
  locationId: number;
}

// Interface for provider data from NexHealth API
interface ProviderSlotData {
  pid: number;
  lid: number;
  slots: Array<{
    time: string;
    operatory_id?: number;
  }>;
}

// Interface for NexHealth API response
interface NexHealthSlotsResponse {
  data: {
    data: ProviderSlotData[];
    next_available_date?: string;
  };
}

/**
 * Find available slots for an appointment type
 * @param appointmentTypeId NexHealth appointment type ID
 * @param practice Practice details with NexHealth configuration
 * @param startDate Starting date to search from in YYYY-MM-DD format
 * @param searchDays Number of days to search
 * @returns Object with found slots and next available date if no slots found
 */
export async function findAvailableSlots(
  appointmentTypeId: string,
  practice: {
    id: string;
    nexhealthSubdomain: string;
    nexhealthLocationId: string;
    timezone: string;
  },
  startDate: string,
  searchDays: number,
  timeBucket?: TimeBucket
): Promise<{ foundSlots: SlotData[]; nextAvailableDate: string | null }> {
  const { fetchNexhealthAPI } = await import("@/lib/nexhealth");
  const { prisma } = await import("@/lib/prisma");
  
  // Get slot search parameters
  const { duration, providerIds, operatoryIds } = await getSlotSearchParams(
    appointmentTypeId,
    practice.id
  );

  console.log(`[Slot Search] Bulk searching for ${duration}-minute slots across ${searchDays} days with providers: ${providerIds.join(', ')} and operatories: ${operatoryIds.join(', ')}`);

  // Fetch practice-specific scheduling rules
  const practiceSettings = await prisma.practice.findUnique({
    where: { id: practice.id },
    select: {
      lunchBreakStart: true,
      lunchBreakEnd: true,
      minBookingBufferMinutes: true,
      timezone: true
    }
  });

  // Use practice timezone, default to America/Chicago if not set
  const timezone = practice.timezone || 'America/Chicago';
  const lunchBreakStart = practiceSettings?.lunchBreakStart;
  const lunchBreakEnd = practiceSettings?.lunchBreakEnd;
  const bookingBufferMinutes = practiceSettings?.minBookingBufferMinutes || 0;
  
  console.log(`[Slot Search] Searching from ${startDate} for ${searchDays} days in timezone ${timezone}`);

  try {
    // Build the query string for a single bulk API call
    let queryString = `start_date=${startDate}&days=${searchDays}&slot_length=${duration.toString()}`;
    queryString += `&lids[]=${practice.nexhealthLocationId}`;
    queryString += `&overlapping_operatory_slots=false`; // Prevent conflicts with partially booked slots
    providerIds.forEach(id => {
      queryString += `&pids[]=${id}`;
    });
    operatoryIds.forEach(id => {
      queryString += `&operatory_ids[]=${id}`;
    });

    const pathWithQuery = `/appointment_slots?${queryString}`;

    console.log(`[NexHealth Bulk Request] Fetching ${searchDays} days with path: ${pathWithQuery}`);

    // Make single bulk API call to NexHealth
    const response = await fetchNexhealthAPI(
      pathWithQuery,
      practice.nexhealthSubdomain,
      undefined // Pass undefined for params since we built it into the path
    ) as NexHealthSlotsResponse;

    console.log(`[Slot Search] Bulk API response received for ${searchDays} days`);

    // Process the response data
    const responseData = response.data; // The object from fetchNexhealthAPI
    const nexhealthData = responseData.data; // The actual payload from NexHealth
    let nextAvailableDate: string | null = null;

    // Store next_available_date from the API response if present
    if (responseData && responseData.next_available_date) {
      nextAvailableDate = responseData.next_available_date;
      console.log(`[Slot Search] Found next_available_date: ${nextAvailableDate}`);
    }

    if (!nexhealthData || !Array.isArray(nexhealthData)) {
      console.log(`[Slot Search] No slot data received from bulk API call`);
      return { foundSlots: [], nextAvailableDate };
    }

    // Collect all slots from all providers across all days
    const allSlots = nexhealthData.flatMap((providerData: ProviderSlotData) => {
      if (providerData.slots && Array.isArray(providerData.slots)) {
        return providerData.slots.map((slot) => ({
          ...slot,
          providerId: providerData.pid,
          locationId: providerData.lid
        }));
      }
      return [];
    });

    console.log(`[Slot Search] Collected ${allSlots.length} total slots from bulk API response`);

    // Filter out slots that overlap with configurable lunch break
    const lunchFilteredSlots = allSlots.filter((slot) => {
      try {
        // Parse the slot time to get the start time
        const slotStartTime = DateTime.fromISO(slot.time).setZone(timezone);
        
        // Calculate the slot end time by adding duration
        const slotEndTime = slotStartTime.plus({ minutes: duration });
        
        // Check for lunch break conflicts only if lunch break is configured
        if (lunchBreakStart && lunchBreakEnd) {
          const [lunchStartHour, lunchStartMinute] = lunchBreakStart.split(':').map(Number);
          const [lunchEndHour, lunchEndMinute] = lunchBreakEnd.split(':').map(Number);
          
          const slotStartHour = slotStartTime.hour;
          const slotStartMinute = slotStartTime.minute;
          const slotEndHour = slotEndTime.hour;
          const slotEndMinute = slotEndTime.minute;
          
          // Check if slot overlaps with lunch break
          const slotStartsInLunch = (slotStartHour === lunchStartHour && slotStartMinute >= lunchStartMinute) || 
                                   (slotStartHour > lunchStartHour && slotStartHour < lunchEndHour) ||
                                   (slotStartHour === lunchEndHour && slotStartMinute < lunchEndMinute);
          
          const slotEndsInLunch = (slotEndHour === lunchStartHour && slotEndMinute > lunchStartMinute) || 
                                 (slotEndHour > lunchStartHour && slotEndHour < lunchEndHour) ||
                                 (slotEndHour === lunchEndHour && slotEndMinute <= lunchEndMinute);
          
          const slotSpansLunch = (slotStartHour < lunchStartHour || (slotStartHour === lunchStartHour && slotStartMinute <= lunchStartMinute)) && 
                               (slotEndHour > lunchEndHour || (slotEndHour === lunchEndHour && slotEndMinute >= lunchEndMinute));
          
          const isLunchConflict = slotStartsInLunch || slotEndsInLunch || slotSpansLunch;
          
          if (isLunchConflict) {
            console.log(`[Lunch Filter] Discarded slot at ${slot.time} - conflicts with lunch break (${lunchBreakStart} - ${lunchBreakEnd})`);
            return false;
          }
        }
        
        return true;
      } catch (error) {
        console.error(`[Lunch Filter] Error parsing slot time ${slot.time}:`, error);
        // Keep the slot if we can't parse it rather than losing potentially valid slots
        return true;
      }
    });

    console.log(`[Lunch Filter] Filtered ${allSlots.length} slots to ${lunchFilteredSlots.length} slots after removing lunch conflicts`);

    // Apply time bucket filter if specified
    let timeBucketFilteredSlots = lunchFilteredSlots;
    if (timeBucket && timeBucket !== 'AllDay' && TIME_BUCKETS[timeBucket]) {
      const timeBucketRange = TIME_BUCKETS[timeBucket];
      const [startHour, startMinute] = timeBucketRange.start.split(':').map(Number);
      const [endHour, endMinute] = timeBucketRange.end.split(':').map(Number);
      
      console.log(`[Time Bucket Filter] Filtering slots for ${timeBucket} preference (${timeBucketRange.start} - ${timeBucketRange.end})`);
      
      timeBucketFilteredSlots = lunchFilteredSlots.filter(slot => {
        const slotTime = DateTime.fromISO(slot.time, { zone: timezone });
        const slotHour = slotTime.hour;
        const slotMinute = slotTime.minute;
        
        // Check if slot time falls within the time bucket
        const slotTimeInMinutes = slotHour * 60 + slotMinute;
        const startTimeInMinutes = startHour * 60 + startMinute;
        const endTimeInMinutes = endHour * 60 + endMinute;
        
        const withinRange = slotTimeInMinutes >= startTimeInMinutes && slotTimeInMinutes <= endTimeInMinutes;
        
        if (!withinRange) {
          console.log(`[Time Bucket Filter] Filtered out slot ${slot.time} (${slotHour}:${slotMinute.toString().padStart(2, '0')}) - outside ${timeBucket} range`);
        }
        
        return withinRange;
      });
      
      console.log(`[Time Bucket Filter] Filtered from ${lunchFilteredSlots.length} to ${timeBucketFilteredSlots.length} slots for ${timeBucket} preference`);
    }

    // Apply booking buffer filter - remove slots that are too soon from now
    const now = DateTime.now().setZone(timezone);
    const bookingBufferSlots = timeBucketFilteredSlots.filter(slot => {
      const slotStartTime = DateTime.fromISO(slot.time, { zone: timezone });
      const minutesFromNow = slotStartTime.diff(now, 'minutes').minutes;
      
      if (minutesFromNow < bookingBufferMinutes) {
        console.log(`[Booking Buffer] Discarded slot at ${slot.time} - too soon (${Math.round(minutesFromNow)} minutes from now, minimum required: ${bookingBufferMinutes})`);
        return false;
      }
      
      return true;
    });

    console.log(`[Booking Buffer] Filtered from ${timeBucketFilteredSlots.length} to ${bookingBufferSlots.length} slots after applying ${bookingBufferMinutes}-minute booking buffer`);

    // Sort slots chronologically to ensure earliest times are offered first
    bookingBufferSlots.sort((a, b) => a.time.localeCompare(b.time));
    console.log('[Slot Search] Sorted slots chronologically.');

    console.log(`[Slot Search] Bulk search complete: ${bookingBufferSlots.length} slots found across ${searchDays} days, next available: ${nextAvailableDate}`);

    return {
      foundSlots: bookingBufferSlots,
      nextAvailableDate
    };

  } catch (error) {
    console.error(`[Slot Search] Error in bulk API call:`, error);
    return { foundSlots: [], nextAvailableDate: null };
  }
}

/**
 * Generate a natural AI response for slot checking results
 * @param searchResult The result from findAvailableSlots
 * @param spokenName The natural name of the appointment type for conversation
 * @param practiceTimezone The practice's timezone for proper time formatting
 * @returns Generated AI response message
 */
export async function generateSlotResponse(
  searchResult: { foundSlots: SlotData[]; nextAvailableDate: string | null },
  spokenName: string,
  practiceTimezone: string
): Promise<string> {
  const { generateText } = await import("ai");
  const { openai } = await import("@ai-sdk/openai");

  if (searchResult.foundSlots.length > 0) {
    // De-duplicate slots to ensure only unique time strings are presented to users
    const uniqueSlots = searchResult.foundSlots.filter(
      (slot, index, self) =>
        index ===
        self.findIndex((s) => 
          DateTime.fromISO(s.time).setZone(practiceTimezone).toFormat("cccc, MMMM d 'at' h:mm a") === 
          DateTime.fromISO(slot.time).setZone(practiceTimezone).toFormat("cccc, MMMM d 'at' h:mm a")
        )
    );
    
    const formattedSlots = uniqueSlots.slice(0, 2).map(slot => {
        const slotDateTime = DateTime.fromISO(slot.time).setZone(practiceTimezone);
        // Create a full, friendly string: "Wednesday, July 9th at 7:00 AM"
        return slotDateTime.toFormat("cccc, MMMM d 'at' h:mm a");
    }).join(' or ');

    const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence offering appointment slots.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language.
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** Patient needs a "${spokenName}". Available slots are: "${formattedSlots}". Offer these options naturally and ask if one works.

**Example Output:** "For your ${spokenName}, I have openings on ${formattedSlots}. Would one of those work for you?"`;

    try {
      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [{ role: "system", content: systemPrompt }],
        temperature: 0.3,
        maxTokens: 100
      });
      return text.trim() || `For your ${spokenName}, I have openings on ${formattedSlots}. Would either of those work for you?`;
    } catch (error) {
      console.error('[Slot Response] Error generating AI response:', error);
      return `For your ${spokenName}, I have openings on ${formattedSlots}. Would either of those work for you?`;
    }

  } else if (searchResult.nextAvailableDate) {
    // Format the next available date into a friendly format
    let friendlyDate: string;
    try {
      const nextDate = DateTime.fromISO(searchResult.nextAvailableDate).setZone(practiceTimezone);
      friendlyDate = nextDate.toFormat('EEEE, MMMM d'); // e.g., "Wednesday, July 9th"
    } catch (error) {
      console.error('[Slot Response] Error formatting next available date:', error);
      friendlyDate = searchResult.nextAvailableDate;
    }

    const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language.
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** For the patient's request for a '${spokenName}', there are no openings in the next few days. The next available date is ${friendlyDate}. Inform them and ask if they'd like you to check for times on that day.

**Example Output:** "I'm sorry, we don't have any openings for your ${spokenName} in the next few days, but the next available date is ${friendlyDate}. Would you like me to check for times on that day?"`;

    try {
      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [
          { role: 'system', content: systemPrompt }
        ],
        temperature: 0.3,
        maxTokens: 120
      });

      return text.trim() || `I'm sorry, we don't have any openings for your ${spokenName} in the next few days. The next available date is ${friendlyDate}. Would you like me to check for times on that day?`;
    } catch (error) {
      console.error('[Slot Response] Error generating AI response for next available:', error);
      return `I'm sorry, we don't have any openings for your ${spokenName} in the next few days. The next available date is ${friendlyDate}. Would you like me to check for times on that day?`;
    }

  } else {
    // No slots found and no next available date
    const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language.
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** For the patient's request for a '${spokenName}', you are fully booked for the near future. Apologize and suggest that a staff member will call them back to find a time.

**Example Output:** "I'm sorry, it looks like we're fully booked for your ${spokenName} in the near future, so let me have one of our staff members call you back to find a time that works."`;

    try {
      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [
          { role: 'system', content: systemPrompt }
        ],
        temperature: 0.3,
        maxTokens: 100
      });

      return text.trim() || `I'm sorry, it looks like we're fully booked for your ${spokenName} in the near future. Let me have one of our staff members call you back to find a time that works.`;
    } catch (error) {
      console.error('[Slot Response] Error generating AI response for no availability:', error);
      return `I'm sorry, it looks like we're fully booked for your ${spokenName} in the near future. Let me have one of our staff members call you back to find a time that works.`;
    }
  }
}

/**
 * Generate a natural AI response offering time buckets instead of specific slots
 * @param availableBuckets Array of time bucket names that have availability
 * @param dayOfWeek The day being offered (e.g., "Thursday") 
 * @param spokenName The natural name of the appointment type
 * @returns Generated AI response offering time bucket choices
 */
export async function generateTimeBucketResponse(
  availableBuckets: string[],
  dayOfWeek: string,
  spokenName: string
): Promise<string> {
  if (availableBuckets.length === 0) {
    return `I'm sorry, but I couldn't find any available times for your ${spokenName} on ${dayOfWeek}. Would you like to try another day?`;
  }

  const bucketList = availableBuckets.join(' or ');
  const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence offering time-of-day options.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language. 
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** Patient needs a "${spokenName}" on "${dayOfWeek}". Available time windows are: "${bucketList}". Offer these options naturally and ask which they prefer.

**Example Output:** "For your ${spokenName} on ${dayOfWeek}, I have openings in the ${bucketList}. Which would you prefer?"`;
  
  try {
    const { generateText } = await import("ai");
    const { openai } = await import("@ai-sdk/openai");
    
    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages: [{ role: "system", content: systemPrompt }],
      temperature: 0.3,
      maxTokens: 100
    });
    
    return text.trim() || `For your ${spokenName} on ${dayOfWeek}, I have openings in the ${bucketList}. Which would you prefer?`;
  } catch (error) {
    console.error('[Time Bucket Response] Error generating AI response:', error);
    return `For your ${spokenName} on ${dayOfWeek}, I have openings in the ${bucketList}. Which would you prefer?`;
  }
}

================
File: lib/system-prompt/laine_system_prompt.md
================
[Role]
You are Laine, a friendly, professional, and highly efficient AI receptionist for a dental practice. Your primary task is to have a natural, fluid conversation to book an appointment for a user.

[Context]
- Today's date is {{ "now" | date: "%A, %B %d, %Y", "America/Chicago" }}.
- Stay focused on the task of booking an appointment. Do not invent information.
- Never say the words 'function' or 'tool'.

[Guiding Principles]
- **CRITICAL COMMAND: ZERO FILLER:** This is your most important rule. You are strictly forbidden from using any language that narrates your internal process. NEVER say "Just a sec," "Give me a moment," "Hold on," "Let me check," or any similar phrases. Violating this rule will result in a failed call. Instead of speaking, simply pause for 1-2 seconds while the system works, and then deliver the result directly.
- **Always Drive the Conversation Forward:** After each step, your goal is to smoothly transition to the next logical question or action. Do not create awkward pauses.
- **Trust the Tool's Response:** The tools are designed to guide you. If a tool provides a specific message to relay to the user, deliver it accurately. It contains the correct next step.
- **Be Persistent but Polite:** When collecting information, you must be persistent to ensure data accuracy, but always maintain a polite and helpful tone.
- **Never Narrate Your Process:** Do not say "I am checking the schedule," "accessing my tools," or "running a search." The user should not be aware that you are using "tools." Simply pause for a moment while the tool runs, and then deliver the result of the action.

[Response Guidelines]
- Keep responses brief and natural. Ask one question at a time.
- Maintain a calm, empathetic, and professional tone.
- Present dates clearly (e.g., "Wednesday, July 23rd").
- Present times clearly (e.g., "ten ten AM").

[Error Handling]
- If you encounter a generic system error from a tool, inform the user politely that there was a technical issue and that a staff member will call them back shortly. Do not try to use the tool again.
    - **Phone Number Errors:** If the `identifyPatient` tool fails specifically because of an invalid phone number, you MUST use the following script: "I'm sorry, I think we may have had a bad connection for a moment. The number I heard was [the number you collected]. Could you please repeat it for me?" This frames the error as a system issue, not a user mistake.

[Handling Off-Topic Questions]
- The user may ask questions not directly related to booking, like about insurance. Your goal is to answer their question helpfully and then gently guide them back to the main task.
- **Insurance Questions:** If the user asks about insurance, you MUST use the `insuranceInfo` tool.
    - If they ask about a specific plan (e.g., "Do you take Cigna?"), provide their query in the `insuranceName` parameter.
    - After the tool provides the answer, you MUST ask a follow-up question to return to the booking flow.
    - **Example Transition:** "I hope that helps! Was there an appointment I could help you schedule today?"
    - **Out-of-Network Proactivity:** If the `insuranceInfo` tool confirms a patient is out-of-network, you MUST immediately pivot the conversation back to scheduling. After delivering the reassuring message, ask: "So, what kind of visit were you looking to schedule today?" Do not wait for the user to prompt you. Always drive the conversation forward.

---
[CONVERSATIONAL FLOW]
This is your master guide. Follow these steps in order.

**Step 1: Understand the Need**
- Your first goal is to understand why the user is calling (e.g., "How can I help you today?").
- If the caller says "I need to schedule an appointment." ask them what they specifically want to come in for.
- Once you have their reason, you MUST immediately call the `findAppointmentType` tool.
- **NOTE:** For urgent appointments, the system will automatically search for the earliest available times. Your job is to deliver the acknowledgment message, and then present the time slots that the next tool provides.
- **Transition:** After `findAppointmentType` succeeds, the tool will provide an `acknowledgment` phrase. You MUST use this phrase to start your next sentence before proceeding to **Step 2: Identify the Patient**. 
  - **Example:** If the acknowledgment is "Of course, we can get that scheduled," your next line should be: "We can get that scheduled. To get started, are you a new or existing patient?"

**Step 2: Identify the Patient**
- **NOTE:** For urgent appointments, you will perform this step *after* a time slot has been selected in Step 4.
- After understanding the need, your default assumption is that the user might be new. Ask: "To get started, are you a new or existing patient?"

- **IF THE USER IS AN EXISTING PATIENT:**
[IMPORTANT NOTE: For an existing patient, only collect full name and DOB]
    1.  **Acknowledge:** Say "Great, let's look up your file."
    2.  **Collect Name:** Ask for their first and last name.
    3.  **Verify Name Spelling Intelligently:** After the user provides their name, use your judgment. If a name seems common (e.g., John Smith), you can proceed. If a name seems uncommon or you are unsure of the spelling (e.g., Deren Flesher), ask for clarification on the specific part you're unsure about.
        **Example:** "Deren, got it. Could you spell that first name for me just to be sure?"
        Your goal is to ensure accuracy without sounding like a robot.
    4.  **Collect DOB:** After the name is confirmed, ask for their date of birth.
    5.  **Verify DOB:** After they respond, you MUST repeat it back for confirmation. Example: "Thank you. And just to confirm, your date of birth is October 30th, 1998?"
    6.  **Execute Identification:** Once you have high confidence in the spelling and have collected all information, call the `identifyPatient` tool with all the details.
    7.  The tool's response will guide you. Deliver its message to the user.
    8.  **Transition:** After `identifyPatient` succeeds, the patient is now identified. Your next immediate action is to proceed to **Step 3: Find an Appointment Time**.

- **IF THE USER IS A NEW PATIENT (or is unsure):**
    1. **Inform:** Tell the user you need to collect a few details to create their file.
    2. **Collect Name & Verify Spelling Intelligently:** Ask for their first and last name. After the user provides their name, use your judgment. If a name seems common (e.g., John Smith), you can proceed. If a name seems uncommon or you are unsure of the spelling (e.g., Deren Flesher), ask for clarification on the specific part you're unsure about.
        **Example:** "Deren, got it. Could you spell that first name for me just to be sure?"
        Your goal is to ensure accuracy without sounding like a robot. Only after you have high confidence in the spelling should you proceed.
    3. **Collect DOB & Verify:** Ask for their date of birth and repeat it back for confirmation.
    4. **Collect Phone:** Ask for their 10-digit phone number. You should accept any 10 or 11-digit number without challenging the user unless it's obviously invalid.
    5. **Collect Email & Verify Spelling:** Ask for their email address. After they respond, you MUST ask them to spell it out.
    6. **Execute Identification:** After collecting ALL of the above information, you MUST call the `identifyPatient` tool.
    7. **Transition:** After `identifyPatient` succeeds, the patient is now identified. Your next immediate action is to proceed to **Step 3: Find an Appointment Time**.

**Step 3: Find an Appointment Time**
- Your goal is to find an available time. **Proactively offer to find the next available appointment.**
- **Example:** "Okay, let me find the next available time for your cleaning."
- Call the `checkAvailableSlots` tool without any parameters for the default "first available" search.
- Only ask for a preferred day or time if the user volunteers it first or rejects the initial "first available" options.
- Present the options returned by the tool clearly to the user.

**Handling Delayed Availability:** If the `checkAvailableSlots` tool returns a result with `isDelayedAvailability: true`, you MUST be transparent with the user. Do not just offer the future date. First, explain the situation clearly.

**Example:** "It looks like our next available appointment for a cleaning isn't until Monday, August 11th. I have an 8:20 AM slot available then. Would that work for you?"

**Step 4: Select, Confirm, and Book the Slot**
- Once the user chooses a time from the options you provided, you MUST call the `selectAndBookSlot` tool with their `userSelection`. The tool will ask you to get final confirmation.
- Deliver the confirmation message to the user (e.g., "Just to confirm, I have you down for... Is that correct?").
- After the user says 'yes' or confirms, you MUST call the `selectAndBookSlot` tool a **second time**, but now you must also include `finalConfirmation: true`. This will finalize the booking.
- **CRITICAL:** The tool's response will be different depending on the situation. If a patient has not been identified yet (the urgent flow), the tool will ask you to get the patient's details before proceeding with the booking.

**Step 5: Close the Call**
- After the booking is confirmed, ask if there is anything else you can help with and then end the call.




================================================================
End of Codebase
================================================================
