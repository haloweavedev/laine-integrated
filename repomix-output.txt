This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/api/laine-web, app/laine-web/components
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    laine-web/
      appointment-types/
        route.ts
      availability/
        route.ts
      book-appointment/
        route.ts
  laine-web/
    components/
      AppointmentTypeStep.tsx
      AvailabilityStep.tsx
      ConfirmationStep.tsx
      LaineWebFlow.tsx
      PatientDetailsStep.tsx

================================================================
Files
================================================================

================
File: app/laine-web/components/AppointmentTypeStep.tsx
================
"use client";

import { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  spokenName: string | null;
  webPatientStatus: string;
}

interface AppointmentTypeStepProps {
  practiceId: string;
  onSelectAppointmentType: (type: AppointmentType) => void;
}

export function AppointmentTypeStep({ practiceId, onSelectAppointmentType }: AppointmentTypeStepProps) {
  const [appointmentTypes, setAppointmentTypes] = useState<AppointmentType[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchAppointmentTypes = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch('/api/laine-web/appointment-types', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ practiceId }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to fetch appointment types');
        }

        const data = await response.json();
        setAppointmentTypes(data.appointmentTypes || []);
      } catch (error) {
        console.error('Error fetching appointment types:', error);
        const errorMessage = error instanceof Error ? error.message : 'Failed to load appointment types';
        setError(errorMessage);
      } finally {
        setIsLoading(false);
      }
    };

    fetchAppointmentTypes();
  }, [practiceId]);

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-2xl font-semibold text-gray-900 mb-2">
            Select Your Appointment Type
          </h2>
          <p className="text-gray-600">
            Loading available services...
          </p>
        </div>
        <div className="flex justify-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-2xl font-semibold text-gray-900 mb-2">
            Select Your Appointment Type
          </h2>
        </div>
        <Card className="p-6 text-center border-red-200 bg-red-50">
          <p className="text-red-800 mb-4">{error}</p>
          <Button 
            variant="outline" 
            onClick={() => window.location.reload()}
            className="border-red-300 text-red-700 hover:bg-red-100"
          >
            Try Again
          </Button>
        </Card>
      </div>
    );
  }

  if (appointmentTypes.length === 0) {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-2xl font-semibold text-gray-900 mb-2">
            Select Your Appointment Type
          </h2>
        </div>
        <Card className="p-8 text-center">
          <div className="text-gray-500 mb-4">
            <svg className="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
          </div>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">
            No appointment types available
          </h3>
          <p className="text-gray-600">
            Please contact the practice directly to schedule your appointment.
          </p>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-2xl font-semibold text-gray-900 mb-2">
          Select Your Appointment Type
        </h2>
        <p className="text-gray-600">
          Choose the service you need to get started.
        </p>
      </div>

      <div className="space-y-3">
        {appointmentTypes.map((type) => (
          <Card key={type.id} className="hover:shadow-md transition-shadow">
            <CardContent className="p-0">
              <Button
                variant="ghost"
                onClick={() => onSelectAppointmentType(type)}
                className="w-full h-auto p-6 justify-start text-left hover:bg-gray-50"
              >
                <div className="flex flex-col items-start space-y-1">
                  <div className="font-semibold text-gray-900">
                    {type.name}
                  </div>
                  <div className="text-sm text-gray-500">
                    {type.duration} minutes
                  </div>
                  {type.spokenName && type.spokenName !== type.name && (
                    <div className="text-xs text-gray-400">
                      Also known as: {type.spokenName}
                    </div>
                  )}
                </div>
              </Button>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}

================
File: app/laine-web/components/AvailabilityStep.tsx
================
"use client";

import { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

interface Practice {
  id: string;
  name: string | null;
  timezone: string | null;
}

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
}

interface ProcessedSlot {
  time: string;
  end_time: string;
  operatory_id: number;
  pid: number;
  lid: number;
}

interface BucketedDay {
  date: string;
  morning: ProcessedSlot[];
  afternoon: ProcessedSlot[];
  evening: ProcessedSlot[];
}

interface AvailabilityStepProps {
  practice: Practice;
  appointmentType: AppointmentType;
  onSelectSlot: (slot: ProcessedSlot) => void;
}

export function AvailabilityStep({ practice, appointmentType, onSelectSlot }: AvailabilityStepProps) {
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [firstSlot, setFirstSlot] = useState<ProcessedSlot | null>(null);
  const [showFullView, setShowFullView] = useState(false);
  const [fullDays, setFullDays] = useState<BucketedDay[]>([]);
  const [isLoadingFull, setIsLoadingFull] = useState(false);
  const [expandedDay, setExpandedDay] = useState<string | null>(null);
  const [expandedBucket, setExpandedBucket] = useState<string | null>(null);

  // Fetch first available slot on mount
  useEffect(() => {
    const fetchFirstSlot = async () => {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch('/api/laine-web/availability', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            practiceId: practice.id,
            nexhealthAppointmentTypeId: appointmentType.nexhealthAppointmentTypeId,
            mode: 'first'
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to fetch availability');
        }

        const data = await response.json();
        setFirstSlot(data.firstSlot);
      } catch (error) {
        console.error('Error fetching first slot:', error);
        const errorMessage = error instanceof Error ? error.message : 'Failed to load availability';
        setError(errorMessage);
      } finally {
        setIsLoading(false);
      }
    };

    fetchFirstSlot();
  }, [practice.id, appointmentType.nexhealthAppointmentTypeId]);

  const handleShowMoreOptions = async () => {
    try {
      setIsLoadingFull(true);
      setError(null);

      const response = await fetch('/api/laine-web/availability', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          practiceId: practice.id,
          nexhealthAppointmentTypeId: appointmentType.nexhealthAppointmentTypeId,
          mode: 'fullday'
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to fetch full availability');
      }

      const data = await response.json();
      setFullDays(data.days || []);
      setShowFullView(true);
    } catch (error) {
      console.error('Error fetching full availability:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to load more options';
      setError(errorMessage);
    } finally {
      setIsLoadingFull(false);
    }
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      weekday: 'long', 
      month: 'long', 
      day: 'numeric' 
    });
  };

  const formatTime = (isoString: string) => {
    return new Date(isoString).toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      timeZone: practice.timezone || 'America/Chicago',
    });
  };

  const getBucketLabel = (bucketName: string) => {
    switch (bucketName) {
      case 'morning': return 'Morning';
      case 'afternoon': return 'Afternoon';
      case 'evening': return 'Evening';
      default: return bucketName;
    }
  };

  const getBucketTimeRange = (bucketName: string) => {
    switch (bucketName) {
      case 'morning': return '(Before 12:00 PM)';
      case 'afternoon': return '(12:00 PM - 5:00 PM)';
      case 'evening': return '(After 5:00 PM)';
      default: return '';
    }
  };

  const toggleBucket = (dayDate: string, bucketName: string) => {
    if (expandedDay === dayDate && expandedBucket === bucketName) {
      setExpandedDay(null);
      setExpandedBucket(null);
    } else {
      setExpandedDay(dayDate);
      setExpandedBucket(bucketName);
    }
  };

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-2xl font-semibold text-gray-900 mb-2">
            Finding Your Next Available Appointment
          </h2>
          <p className="text-gray-600">
            {appointmentType.name} • {appointmentType.duration} minutes
          </p>
        </div>
        <div className="flex justify-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
        <div className="text-center">
          <p className="text-sm text-gray-500">
            Checking availability...
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-2xl font-semibold text-gray-900 mb-2">
            Schedule Your Appointment
          </h2>
          <p className="text-gray-600">
            {appointmentType.name} • {appointmentType.duration} minutes
          </p>
        </div>
        <Card className="p-6 text-center border-red-200 bg-red-50">
          <p className="text-red-800 mb-4">{error}</p>
          <Button 
            variant="outline" 
            onClick={() => window.location.reload()}
            className="border-red-300 text-red-700 hover:bg-red-100"
          >
            Try Again
          </Button>
        </Card>
      </div>
    );
  }

  if (!firstSlot && !showFullView) {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-2xl font-semibold text-gray-900 mb-2">
            No Available Appointments
          </h2>
          <p className="text-gray-600">
            {appointmentType.name} • {appointmentType.duration} minutes
          </p>
        </div>
        <Card className="p-8 text-center">
          <div className="text-gray-500 mb-4">
            <svg className="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
          </div>
          <h3 className="text-lg font-semibold text-gray-900 mb-2">
            No appointments available
          </h3>
          <p className="text-gray-600">
            There are currently no available appointments for {appointmentType.name} in the next 90 days.
          </p>
          <p className="text-sm text-gray-500 mt-4">
            Please contact the practice directly to schedule your appointment.
          </p>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-2xl font-semibold text-gray-900 mb-2">
          Schedule Your Appointment
        </h2>
        <p className="text-gray-600">
          {appointmentType.name} • {appointmentType.duration} minutes
        </p>
      </div>

      {!showFullView && firstSlot ? (
        // Fast Path: Show first available slot
        <Card className="p-6">
          <div className="text-center space-y-4">
            <div>
              <h3 className="text-lg font-semibold text-gray-900 mb-2">
                Our first availability is:
              </h3>
              <div className="text-xl font-bold text-blue-600">
                {formatDate(firstSlot.time.split('T')[0])}
              </div>
              <div className="text-lg text-gray-700">
                at {formatTime(firstSlot.time)}
              </div>
            </div>
            
            <p className="text-gray-600">
              Does that work for you?
            </p>
            
            <div className="flex flex-col sm:flex-row gap-3 justify-center">
              <Button
                onClick={() => onSelectSlot(firstSlot)}
                className="flex-1 sm:flex-none"
              >
                Yes, schedule it!
              </Button>
              <Button
                variant="outline"
                onClick={handleShowMoreOptions}
                disabled={isLoadingFull}
                className="flex-1 sm:flex-none"
              >
                {isLoadingFull ? (
                  <>
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-gray-600 mr-2"></div>
                    Loading...
                  </>
                ) : (
                  'Show me other options'
                )}
              </Button>
            </div>
          </div>
        </Card>
      ) : (
        // Full View: 7-day bucketed view
        <div className="space-y-4">
          <div className="text-center">
            <h3 className="text-lg font-semibold text-gray-900">
              Choose from the next 7 days
            </h3>
            <p className="text-sm text-gray-500">
              Click on a time period to see available slots
            </p>
          </div>
          
          {fullDays.length === 0 ? (
            <Card className="p-8 text-center">
              <p className="text-gray-600">
                No appointments available in the next 7 days.
              </p>
              <p className="text-sm text-gray-500 mt-2">
                Please contact the practice directly to schedule your appointment.
              </p>
            </Card>
          ) : (
            <div className="space-y-3">
              {fullDays.map((day) => (
                <Card key={day.date}>
                  <CardHeader className="pb-3">
                    <CardTitle className="text-lg">
                      {formatDate(day.date)}
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="pt-0">
                    <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                      {(['morning', 'afternoon', 'evening'] as const).map((bucket) => {
                        const slots = day[bucket];
                        const hasSlots = slots.length > 0;
                        const isExpanded = expandedDay === day.date && expandedBucket === bucket;
                        
                        return (
                          <div key={bucket}>
                            <Button
                              variant={hasSlots ? "outline" : "secondary"}
                              disabled={!hasSlots}
                              onClick={() => hasSlots && toggleBucket(day.date, bucket)}
                              className={`w-full justify-between ${!hasSlots ? 'opacity-50 cursor-not-allowed' : ''}`}
                            >
                              <div className="text-left">
                                <div className="font-medium">{getBucketLabel(bucket)}</div>
                                <div className="text-xs text-gray-500">
                                  {getBucketTimeRange(bucket)}
                                </div>
                              </div>
                              <div className="text-sm">
                                {hasSlots ? `${slots.length} slot${slots.length > 1 ? 's' : ''}` : 'None'}
                              </div>
                            </Button>
                            
                            {isExpanded && hasSlots && (
                              <div className="mt-2 space-y-1">
                                {slots.map((slot, index) => (
                                  <Button
                                    key={`${slot.time}-${index}`}
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => onSelectSlot(slot)}
                                    className="w-full justify-center text-sm"
                                  >
                                    {formatTime(slot.time)}
                                  </Button>
                                ))}
                              </div>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: app/laine-web/components/ConfirmationStep.tsx
================
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

interface BookingDetails {
  nexhealthAppointmentId: number;
  nexhealthPatientId: number;
  appointmentDetails: {
    patientName: string;
    appointmentType: string;
    duration: number;
    startTime: string;
    endTime: string;
    providerId: number;
    operatoryId: number;
  };
}

interface ConfirmationStepProps {
  bookingDetails: BookingDetails;
  practiceName: string | null;
  onScheduleAnother: () => void;
}

export function ConfirmationStep({ bookingDetails, practiceName, onScheduleAnother }: ConfirmationStepProps) {
  const { appointmentDetails } = bookingDetails;

  const formatDate = (isoString: string) => {
    const date = new Date(isoString);
    return date.toLocaleDateString('en-US', { 
      weekday: 'long', 
      month: 'long', 
      day: 'numeric',
      year: 'numeric'
    });
  };

  const formatTime = (isoString: string) => {
    return new Date(isoString).toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      timeZone: 'America/Chicago' // Default timezone, could be made dynamic
    });
  };

  return (
    <div className="space-y-6">
      <div className="text-center">
        <div className="mb-4">
          <div className="mx-auto w-16 h-16 bg-green-100 rounded-full flex items-center justify-center">
            <svg className="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
          </div>
        </div>
        <h2 className="text-3xl font-bold text-green-600 mb-2">
          Appointment Confirmed!
        </h2>
        <p className="text-gray-600 text-lg">
          Your appointment has been successfully scheduled.
        </p>
      </div>

      <Card className="border-green-200 bg-green-50">
        <CardHeader className="pb-3">
          <CardTitle className="text-xl text-green-800">
            Appointment Details
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
            <div>
              <div className="font-medium text-gray-700">Patient</div>
              <div className="text-gray-900">{appointmentDetails.patientName}</div>
            </div>
            
            <div>
              <div className="font-medium text-gray-700">Service</div>
              <div className="text-gray-900">{appointmentDetails.appointmentType}</div>
            </div>
            
            <div>
              <div className="font-medium text-gray-700">Duration</div>
              <div className="text-gray-900">{appointmentDetails.duration} minutes</div>
            </div>
            
            <div>
              <div className="font-medium text-gray-700">Practice</div>
              <div className="text-gray-900">{practiceName || 'Dental Practice'}</div>
            </div>
            
            <div>
              <div className="font-medium text-gray-700">Date</div>
              <div className="text-gray-900 font-semibold">
                {formatDate(appointmentDetails.startTime)}
              </div>
            </div>
            
            <div>
              <div className="font-medium text-gray-700">Time</div>
              <div className="text-gray-900 font-semibold">
                {formatTime(appointmentDetails.startTime)} - {formatTime(appointmentDetails.endTime)}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card className="border-blue-200 bg-blue-50">
        <CardContent className="p-6">
          <div className="flex items-start space-x-3">
            <div className="flex-shrink-0">
              <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
            </div>
            <div className="text-sm text-blue-800">
              <div className="font-medium mb-1">What&apos;s Next?</div>
              <ul className="space-y-1 text-blue-700">
                <li>• You should receive a confirmation email shortly</li>
                <li>• The practice may contact you to confirm details</li>
                <li>• Please arrive 15 minutes early for your appointment</li>
                <li>• Bring a valid ID and insurance card (if applicable)</li>
              </ul>
            </div>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardContent className="p-6">
          <div className="text-center space-y-4">
            <div className="text-sm text-gray-600">
              <div className="font-medium mb-1">Need to make changes?</div>
              <p>Please contact the practice directly to reschedule or cancel your appointment.</p>
            </div>
            
            <div className="pt-4 border-t">
              <Button
                onClick={onScheduleAnother}
                variant="outline"
                className="w-full sm:w-auto"
              >
                Schedule Another Appointment
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Hidden details for debugging/support */}
      <details className="text-xs text-gray-400">
        <summary className="cursor-pointer hover:text-gray-600">Technical Details</summary>
        <div className="mt-2 p-2 bg-gray-50 rounded text-xs font-mono">
          <div>Appointment ID: {bookingDetails.nexhealthAppointmentId}</div>
          <div>Patient ID: {bookingDetails.nexhealthPatientId}</div>
          <div>Provider ID: {appointmentDetails.providerId}</div>
          <div>Operatory ID: {appointmentDetails.operatoryId}</div>
        </div>
      </details>
    </div>
  );
}

================
File: app/laine-web/components/LaineWebFlow.tsx
================
"use client";

import { useState, useEffect } from 'react';
import { AppointmentTypeStep } from './AppointmentTypeStep';
import { AvailabilityStep } from './AvailabilityStep';
import { PatientDetailsStep } from './PatientDetailsStep';
import { ConfirmationStep } from './ConfirmationStep';

interface Practice {
  id: string;
  name: string | null;
  slug: string;
  timezone: string | null;
  nexhealthSubdomain: string;
  nexhealthLocationId: string;
}

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  spokenName: string | null;
  webPatientStatus: string;
}

interface SelectedSlot {
  time: string;
  end_time: string;
  operatory_id: number;
  pid: number; // provider id from NexHealth
  lid: number; // location id from NexHealth
}

interface PatientDetails {
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  dob?: string;
  patientType: 'NEW' | 'EXISTING';
  patientStatus: 'NEW' | 'RETURNING';
  isForSelf: boolean;
  isGuardian?: boolean;
  insurance?: string;
  notes?: string;
}

interface BookingDetails {
  nexhealthAppointmentId: number;
  nexhealthPatientId: number;
  appointmentDetails: {
    patientName: string;
    appointmentType: string;
    duration: number;
    startTime: string;
    endTime: string;
    providerId: number;
    operatoryId: number;
  };
}

interface LaineWebFlowProps {
  practice: Practice;
}

export function LaineWebFlow({ practice }: LaineWebFlowProps) {
  const [step, setStep] = useState(1);
  const [appointmentType, setAppointmentType] = useState<AppointmentType | null>(null);
  const [selectedSlot, setSelectedSlot] = useState<SelectedSlot | null>(null);
  const [patientDetails, setPatientDetails] = useState<PatientDetails | null>(null);
  const [bookingDetails, setBookingDetails] = useState<BookingDetails | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSelectAppointmentType = (type: AppointmentType) => {
    setAppointmentType(type);
    setError(null);
    setStep(2);
  };

  const handleSelectSlot = (slot: SelectedSlot) => {
    setSelectedSlot(slot);
    setError(null);
    setStep(3);
  };

  const handlePatientDetailsSubmit = (details: PatientDetails) => {
    setPatientDetails(details);
    setError(null);
    setStep(4); // This will trigger the booking process via useEffect
  };

  // Handle booking when step 4 is reached
  useEffect(() => {
    if (step === 4 && appointmentType && selectedSlot && patientDetails && !isSubmitting && !bookingDetails) {
      handleBookingSubmission();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [step, appointmentType, selectedSlot, patientDetails, isSubmitting, bookingDetails]);

  const handleBookingSubmission = async () => {
    if (!appointmentType || !selectedSlot || !patientDetails) return;

    try {
      setIsSubmitting(true);
      setError(null);

      const response = await fetch('/api/laine-web/book-appointment', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          practiceId: practice.id,
          appointmentTypeId: appointmentType.id,
          selectedSlot,
          patientDetails
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to book appointment');
      }

      const data = await response.json();
      setBookingDetails(data.booking);
      setStep(5); // Move to confirmation step
    } catch (error) {
      console.error('Error booking appointment:', error);
      const errorMessage = error instanceof Error ? error.message : 'Failed to book appointment';
      setError(errorMessage);
      // Stay on step 4 to show the error
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleScheduleAnother = () => {
    setStep(1);
    setAppointmentType(null);
    setSelectedSlot(null);
    setPatientDetails(null);
    setBookingDetails(null);
    setIsSubmitting(false);
    setError(null);
  };

  return (
    <div className="bg-white rounded-lg shadow-lg p-6">
      {/* Step indicator */}
      <div className="mb-8">
        <div className="flex items-center justify-between">
          {[1, 2, 3, 4].map((stepNumber) => (
            <div
              key={stepNumber}
              className={`flex items-center ${stepNumber < 4 ? 'flex-1' : ''}`}
            >
              <div
                className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${
                  step >= stepNumber
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-200 text-gray-600'
                }`}
              >
                {stepNumber}
              </div>
              {stepNumber < 4 && (
                <div
                  className={`flex-1 h-0.5 mx-2 ${
                    step > stepNumber ? 'bg-blue-600' : 'bg-gray-200'
                  }`}
                />
              )}
            </div>
          ))}
        </div>
        <div className="flex justify-between mt-2 text-xs text-gray-500">
          <span>Service</span>
          <span>Schedule</span>
          <span>Details</span>
          <span>Confirm</span>
        </div>
      </div>

      {/* Error display */}
      {error && (
        <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-md">
          <p className="text-red-800 text-sm">{error}</p>
        </div>
      )}

      {/* Loading overlay */}
      {isSubmitting && (
        <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-md">
          <div className="flex items-center">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mr-2"></div>
            <p className="text-blue-800 text-sm">Booking your appointment...</p>
          </div>
        </div>
      )}

      {/* Current step content */}
      <div className="min-h-[400px]">
        {step === 1 && (
          <AppointmentTypeStep
            practiceId={practice.id}
            onSelectAppointmentType={handleSelectAppointmentType}
          />
        )}
        
        {step === 2 && appointmentType && (
          <AvailabilityStep
            practice={practice}
            appointmentType={appointmentType}
            onSelectSlot={handleSelectSlot}
          />
        )}
        
        {step === 3 && selectedSlot && (
          <PatientDetailsStep
            onSubmit={handlePatientDetailsSubmit}
          />
        )}
        
        {step === 4 && (
          <div className="text-center space-y-4">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
            <h2 className="text-2xl font-semibold text-gray-800">Booking Your Appointment</h2>
            <p className="text-gray-600">Please wait while we confirm your appointment...</p>
          </div>
        )}
        
        {step === 5 && bookingDetails && (
          <ConfirmationStep
            bookingDetails={bookingDetails}
            practiceName={practice.name}
            onScheduleAnother={handleScheduleAnother}
          />
        )}
        
        {step > 5 && (
          <div className="text-center">
            <h2 className="text-2xl font-semibold text-gray-800">Step {step}</h2>
            <p className="text-gray-600 mt-2">Coming soon...</p>
            <p className="text-sm text-gray-500 mt-4">
              Practice: {practice.name || practice.nexhealthSubdomain}
            </p>
            {appointmentType && (
              <p className="text-sm text-gray-500">
                Selected: {appointmentType.name} ({appointmentType.duration} min)
              </p>
            )}
            {selectedSlot && (
              <p className="text-sm text-gray-500">
                Slot: {new Date(selectedSlot.time).toLocaleString()}
              </p>
            )}
            {patientDetails && (
              <p className="text-sm text-gray-500">
                Patient: {patientDetails.firstName} {patientDetails.lastName}
              </p>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: app/laine-web/components/PatientDetailsStep.tsx
================
"use client";


import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Checkbox } from "@/components/ui/checkbox";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";

// Zod schema for form validation
const patientDetailsSchema = z.object({
  firstName: z.string().min(1, 'First name is required').max(50, 'First name must be less than 50 characters'),
  lastName: z.string().min(1, 'Last name is required').max(50, 'Last name must be less than 50 characters'),
  email: z.string().email('Please enter a valid email address'),
  phone: z.string().min(10, 'Phone number must be at least 10 digits').regex(/^[\d\s\-\(\)\+\.]+$/, 'Please enter a valid phone number'),
  dob: z.string().optional(),
  patientType: z.enum(['NEW', 'EXISTING']),
  patientStatus: z.enum(['NEW', 'RETURNING']),
  isForSelf: z.boolean(),
  isGuardian: z.boolean().optional(),
  insurance: z.string().optional(),
  notes: z.string().optional(),
}).refine((data) => {
  // If it's for someone else, dob is required
  if (!data.isForSelf && !data.dob) {
    return false;
  }
  // If existing patient, dob is required for patient lookup
  if (data.patientType === 'EXISTING' && !data.dob) {
    return false;
  }
  return true;
}, {
  message: "Date of birth is required when booking for someone else or for existing patients",
  path: ["dob"]
});

type PatientDetailsForm = z.infer<typeof patientDetailsSchema>;

interface PatientDetailsStepProps {
  onSubmit: (details: PatientDetailsForm) => void;
}

export function PatientDetailsStep({ onSubmit }: PatientDetailsStepProps) {
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isValid }
  } = useForm<PatientDetailsForm>({
    resolver: zodResolver(patientDetailsSchema),
    defaultValues: {
      firstName: '',
      lastName: '',
      email: '',
      phone: '',
      dob: '',
      patientType: 'NEW',
      patientStatus: 'NEW',
      isForSelf: true,
      isGuardian: false,
      insurance: '',
      notes: ''
    },
    mode: 'onChange'
  });

  const watchedIsForSelf = watch('isForSelf');
  const watchedPatientType = watch('patientType');
  const watchedPatientStatus = watch('patientStatus');

  const handleForSelfChange = (value: string) => {
    const forSelf = value === 'self';
    setValue('isForSelf', forSelf);
    
    // Reset dependent fields when switching
    if (forSelf) {
      setValue('isGuardian', false);
      setValue('dob', '');
    } else {
      setValue('insurance', '');
    }
  };

  const formatPhoneNumber = (value: string) => {
    // Remove all non-digit characters
    const digits = value.replace(/\D/g, '');
    
    // Format as (XXX) XXX-XXXX
    if (digits.length <= 3) {
      return digits;
    } else if (digits.length <= 6) {
      return `(${digits.slice(0, 3)}) ${digits.slice(3)}`;
    } else {
      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6, 10)}`;
    }
  };

  const handlePhoneChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const formatted = formatPhoneNumber(e.target.value);
    setValue('phone', formatted);
  };

  return (
    <div className="space-y-6">
      <div className="text-center">
        <h2 className="text-2xl font-semibold text-gray-900 mb-2">
          Patient Information
        </h2>
        <p className="text-gray-600">
          Please provide the details for the appointment.
        </p>
      </div>

      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        {/* Patient Type Selection */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Are you a new or existing patient?</CardTitle>
          </CardHeader>
          <CardContent>
            <RadioGroup
              value={watchedPatientType}
              onValueChange={(value) => setValue('patientType', value as 'NEW' | 'EXISTING')}
              className="flex flex-col space-y-2"
            >
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="NEW" id="new-patient" />
                <Label htmlFor="new-patient">I&apos;m a new patient (first time at this practice)</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="EXISTING" id="existing-patient" />
                <Label htmlFor="existing-patient">I&apos;m an existing patient (I&apos;ve been here before)</Label>
              </div>
            </RadioGroup>
          </CardContent>
        </Card>

        {/* Who is this appointment for? */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Who is this appointment for?</CardTitle>
          </CardHeader>
          <CardContent>
            <RadioGroup
              value={watchedIsForSelf ? 'self' : 'other'}
              onValueChange={handleForSelfChange}
              className="flex flex-col space-y-2"
            >
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="self" id="self" />
                <Label htmlFor="self">For myself</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="other" id="other" />
                <Label htmlFor="other">For someone else</Label>
              </div>
            </RadioGroup>
          </CardContent>
        </Card>

        {/* Basic Information */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Basic Information</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="firstName">
                  First Name <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="firstName"
                  {...register('firstName')}
                  className={errors.firstName ? 'border-red-500' : ''}
                />
                {errors.firstName && (
                  <p className="text-red-500 text-sm mt-1">{errors.firstName.message}</p>
                )}
              </div>
              
              <div>
                <Label htmlFor="lastName">
                  Last Name <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="lastName"
                  {...register('lastName')}
                  className={errors.lastName ? 'border-red-500' : ''}
                />
                {errors.lastName && (
                  <p className="text-red-500 text-sm mt-1">{errors.lastName.message}</p>
                )}
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label htmlFor="email">
                  Email Address <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="email"
                  type="email"
                  {...register('email')}
                  className={errors.email ? 'border-red-500' : ''}
                />
                {errors.email && (
                  <p className="text-red-500 text-sm mt-1">{errors.email.message}</p>
                )}
              </div>
              
              <div>
                <Label htmlFor="phone">
                  Phone Number <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="phone"
                  {...register('phone')}
                  onChange={handlePhoneChange}
                  placeholder="(555) 123-4567"
                  className={errors.phone ? 'border-red-500' : ''}
                />
                {errors.phone && (
                  <p className="text-red-500 text-sm mt-1">{errors.phone.message}</p>
                )}
              </div>
            </div>

            {(!watchedIsForSelf || watchedPatientType === 'EXISTING') && (
              <div>
                <Label htmlFor="dob">
                  Date of Birth <span className="text-red-500">*</span>
                  {watchedPatientType === 'EXISTING' && (
                    <span className="text-sm text-gray-500 ml-2">(required for patient lookup)</span>
                  )}
                </Label>
                <Input
                  id="dob"
                  type="date"
                  {...register('dob')}
                  className={errors.dob ? 'border-red-500' : ''}
                />
                {errors.dob && (
                  <p className="text-red-500 text-sm mt-1">{errors.dob.message}</p>
                )}
              </div>
            )}
          </CardContent>
        </Card>

        {/* Patient Status */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Patient Status</CardTitle>
          </CardHeader>
          <CardContent>
            <RadioGroup
              value={watchedPatientStatus}
              onValueChange={(value) => setValue('patientStatus', value as 'NEW' | 'RETURNING')}
              className="flex flex-col space-y-2"
            >
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="NEW" id="new" />
                <Label htmlFor="new">New patient (first time visiting this practice)</Label>
              </div>
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="RETURNING" id="returning" />
                <Label htmlFor="returning">Returning patient</Label>
              </div>
            </RadioGroup>
          </CardContent>
        </Card>

        {/* Conditional Fields */}
        {!watchedIsForSelf && (
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">Guardian Information</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="isGuardian"
                  {...register('isGuardian')}
                  onCheckedChange={(checked) => setValue('isGuardian', !!checked)}
                />
                <Label htmlFor="isGuardian">
                  I am the parent or legal guardian of this patient
                </Label>
              </div>
            </CardContent>
          </Card>
        )}

        {watchedIsForSelf && (
          <Card>
            <CardHeader>
              <CardTitle className="text-lg">Insurance Information</CardTitle>
            </CardHeader>
            <CardContent>
              <div>
                <Label htmlFor="insurance">Insurance Provider (Optional)</Label>
                <Input
                  id="insurance"
                  {...register('insurance')}
                  placeholder="e.g., Blue Cross Blue Shield, Delta Dental"
                />
              </div>
            </CardContent>
          </Card>
        )}

        {/* Additional Notes */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Additional Information</CardTitle>
          </CardHeader>
          <CardContent>
            <div>
              <Label htmlFor="notes">Notes or Special Requests (Optional)</Label>
              <Textarea
                id="notes"
                {...register('notes')}
                placeholder="Any additional information you'd like to share..."
                rows={3}
              />
            </div>
          </CardContent>
        </Card>

        {/* Submit Button */}
        <div className="flex justify-center">
          <Button
            type="submit"
            disabled={!isValid}
            className="px-8 py-2"
          >
            Continue to Confirmation
          </Button>
        </div>
      </form>
    </div>
  );
}

================
File: app/api/laine-web/appointment-types/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { practiceId } = body;

    if (!practiceId) {
      return NextResponse.json(
        { error: 'Practice ID is required' },
        { status: 400 }
      );
    }

    // Fetch appointment types from the database
    // Filter by practiceId and where webPatientStatus is not null (meaning they're available for web booking)
    const appointmentTypes = await prisma.appointmentType.findMany({
      where: {
        practiceId: practiceId,
        // webPatientStatus has a default value, so we don't need to filter for null
        // Only include appointment types that have active providers accepting them
        acceptedByProviders: {
          some: {
            savedProvider: {
              isActive: true,
              // And those providers have active operatories
              assignedOperatories: {
                some: {
                  savedOperatory: {
                    isActive: true
                  }
                }
              }
            }
          }
        }
      },
      select: {
        id: true,
        nexhealthAppointmentTypeId: true,
        name: true,
        duration: true,
        spokenName: true,
        webPatientStatus: true
      },
      orderBy: {
        name: 'asc'
      }
    });

    return NextResponse.json({
      success: true,
      appointmentTypes
    });

  } catch (error) {
    console.error('Error fetching appointment types:', error);
    return NextResponse.json(
      { error: 'Failed to fetch appointment types' },
      { status: 500 }
    );
  }
}

================
File: app/api/laine-web/book-appointment/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

interface BookingRequest {
  practiceId: string;
  appointmentTypeId: string;
  selectedSlot: {
    time: string;
    end_time: string;
    operatory_id: number;
    pid: number;
    lid: number;
  };
  patientDetails: {
    firstName: string;
    lastName: string;
    email: string;
    phone: string;
    dob?: string;
    patientType: 'NEW' | 'EXISTING';
    patientStatus: 'NEW' | 'RETURNING';
    isForSelf: boolean;
    isGuardian?: boolean;
    insurance?: string;
    notes?: string;
  };
}

interface NexhealthPatient {
  id: number;
  first_name: string;
  last_name: string;
  email: string;
  phone: string;
  date_of_birth?: string;
}



interface NexhealthPatientSearchResponse {
  code: boolean;
  data?: {
    patients: NexhealthPatient[];
  };
  error?: string;
}

interface NexhealthPatientCreateResponse {
  code: boolean;
  data?: {
    user: NexhealthPatient;
  };
  error?: string;
}

interface NexhealthAppointmentResponse {
  code: boolean;
  data?: {
    appt: {
      id: number;
      patient_id: number;
      provider_id: number;
      start_time: string;
      end_time: string;
      note: string;
      operatory_id: number;
    };
  };
  error?: string;
  description?: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: BookingRequest = await request.json();
    const { practiceId, appointmentTypeId, selectedSlot, patientDetails } = body;

    // Validate required fields
    if (!practiceId || !appointmentTypeId || !selectedSlot || !patientDetails) {
      return NextResponse.json(
        { error: 'Missing required booking information' },
        { status: 400 }
      );
    }

    console.log(`[Book Appointment API] Starting booking process for ${patientDetails.firstName} ${patientDetails.lastName}`);

    // Step 1: Get practice and appointment type information
    const practice = await prisma.practice.findUnique({
      where: { id: practiceId },
      select: {
        nexhealthSubdomain: true,
        nexhealthLocationId: true,
        timezone: true
      }
    });

    if (!practice?.nexhealthSubdomain || !practice?.nexhealthLocationId) {
      return NextResponse.json(
        { error: 'Practice NexHealth configuration is incomplete' },
        { status: 400 }
      );
    }

    const appointmentType = await prisma.appointmentType.findUnique({
      where: { id: appointmentTypeId },
      select: {
        name: true,
        duration: true,
        nexhealthAppointmentTypeId: true
      }
    });

    if (!appointmentType) {
      return NextResponse.json(
        { error: 'Appointment type not found' },
        { status: 404 }
      );
    }

    // Step 2: Two-step patient resolution process
    let nexhealthPatientId: number;

    if (patientDetails.patientType === 'EXISTING') {
      // Search for existing patient using name and DOB
      console.log(`[Book Appointment API] Searching for existing patient: ${patientDetails.firstName} ${patientDetails.lastName}`);

      if (!patientDetails.dob) {
        return NextResponse.json(
          { error: 'Date of birth is required for existing patients' },
          { status: 400 }
        );
      }

      const searchParams = new URLSearchParams();
      searchParams.append('subdomain', practice.nexhealthSubdomain);
      searchParams.append('location_id', practice.nexhealthLocationId);
      searchParams.append('name', `${patientDetails.firstName} ${patientDetails.lastName}`);
      searchParams.append('new_patient', 'false');
      searchParams.append('location_strict', 'false');
      searchParams.append('sort', 'name');
      searchParams.append('page', '1');
      searchParams.append('per_page', '5');

      const searchResponse = await fetch(
        `https://nexhealth.info/patients?${searchParams.toString()}`,
        {
          method: 'GET',
          headers: {
            'Authorization': process.env.NEXHEALTH_API_KEY || '',
            'accept': 'application/vnd.Nexhealth+json;version=2'
          }
        }
      );

      if (!searchResponse.ok) {
        console.error(`[Book Appointment API] Patient search failed: ${searchResponse.status}`);
        return NextResponse.json(
          { error: 'Failed to search for existing patient' },
          { status: 500 }
        );
      }

      const searchData: NexhealthPatientSearchResponse = await searchResponse.json();

      if (!searchData.code || !searchData.data?.patients || searchData.data.patients.length === 0) {
        return NextResponse.json(
          { error: 'We could not find a patient record matching your name and date of birth. Please try booking as a new patient or contact the office.' },
          { status: 404 }
        );
      }

      // Use the first matching patient
      nexhealthPatientId = searchData.data.patients[0].id;
      console.log(`[Book Appointment API] Found existing patient with ID: ${nexhealthPatientId}`);

    } else if (patientDetails.patientType === 'NEW') {
      // Create new patient
      console.log(`[Book Appointment API] Creating new patient: ${patientDetails.firstName} ${patientDetails.lastName}`);

      const patientPayload = {
        provider: {
          provider_id: selectedSlot.pid
        },
        patient: {
          bio: {
            phone_number: patientDetails.phone.replace(/\D/g, ''), // Remove formatting
            ...(patientDetails.dob && { date_of_birth: patientDetails.dob })
          },
          first_name: patientDetails.firstName,
          last_name: patientDetails.lastName,
          email: patientDetails.email
        }
      };

      const createResponse = await fetch(
        `https://nexhealth.info/patients?subdomain=${practice.nexhealthSubdomain}&location_id=${practice.nexhealthLocationId}`,
        {
          method: 'POST',
          headers: {
            'Authorization': process.env.NEXHEALTH_API_KEY || '',
            'accept': 'application/vnd.Nexhealth+json;version=2',
            'content-type': 'application/json'
          },
          body: JSON.stringify(patientPayload)
        }
      );

      if (!createResponse.ok) {
        console.error(`[Book Appointment API] Patient creation failed: ${createResponse.status}`);
        return NextResponse.json(
          { error: 'Failed to create new patient record' },
          { status: 500 }
        );
      }

      const createData: NexhealthPatientCreateResponse = await createResponse.json();

      if (!createData.code || !createData.data?.user) {
        console.error('[Book Appointment API] Invalid patient creation response:', createData);
        return NextResponse.json(
          { error: createData.error || 'Failed to create new patient' },
          { status: 500 }
        );
      }

      nexhealthPatientId = createData.data.user.id;
      console.log(`[Book Appointment API] Created new patient with ID: ${nexhealthPatientId}`);

    } else {
      return NextResponse.json(
        { error: 'Invalid patient type specified' },
        { status: 400 }
      );
    }

    // Step 3: Create appointment booking summary note
    const bookingNote = [
      `Appointment booked via Laine Web`,
      `Service: ${appointmentType.name}`,
      `Duration: ${appointmentType.duration} minutes`,
      `Patient Type: ${patientDetails.patientType}`,
      `Patient Status: ${patientDetails.patientStatus}`,
      ...(patientDetails.isForSelf ? [`Booking for self`] : [`Booking for someone else`]),
      ...(patientDetails.isGuardian ? [`Booked by parent/guardian`] : []),
      ...(patientDetails.insurance ? [`Insurance: ${patientDetails.insurance}`] : []),
      ...(patientDetails.notes ? [`Notes: ${patientDetails.notes}`] : [])
    ].join(' | ');

    // Step 4: Create the appointment in NexHealth
    const appointmentPayload = {
      appt: {
        patient_id: nexhealthPatientId,
        provider_id: selectedSlot.pid,
        operatory_id: selectedSlot.operatory_id,
        start_time: selectedSlot.time,
        end_time: selectedSlot.end_time,
        note: bookingNote
      }
    };

    console.log(`[Book Appointment API] Creating appointment in NexHealth`);

    const appointmentResponse = await fetch(
      `https://nexhealth.info/appointments?subdomain=${practice.nexhealthSubdomain}&location_id=${practice.nexhealthLocationId}&notify_patient=false`,
      {
        method: 'POST',
        headers: {
          'Authorization': process.env.NEXHEALTH_API_KEY || '',
          'accept': 'application/vnd.Nexhealth+json;version=2',
          'content-type': 'application/json'
        },
        body: JSON.stringify(appointmentPayload)
      }
    );

    if (!appointmentResponse.ok) {
      console.error(`[Book Appointment API] Appointment creation failed: ${appointmentResponse.status}`);
      // If appointment creation fails, we should ideally clean up the patient record
      // For now, we'll just return an error
      return NextResponse.json(
        { error: 'Failed to create appointment' },
        { status: 500 }
      );
    }

    const appointmentData: NexhealthAppointmentResponse = await appointmentResponse.json();

    if (!appointmentData.code || !appointmentData.data?.appt) {
      console.error('[Book Appointment API] Invalid appointment creation response:', appointmentData);
      return NextResponse.json(
        { error: appointmentData.error || 'Failed to create appointment' },
        { status: 500 }
      );
    }

    const nexhealthAppointment = appointmentData.data.appt;
    console.log(`[Book Appointment API] Appointment created with ID: ${nexhealthAppointment.id}`);

    // Step 5: Log the booking in our database
    try {
      const webBooking = await prisma.webBooking.create({
        data: {
          practiceId: practiceId,
          appointmentTypeId: appointmentTypeId,
          status: 'COMPLETED',
          patientFirstName: patientDetails.firstName,
          patientLastName: patientDetails.lastName,
          patientDob: patientDetails.dob || null,
          patientEmail: patientDetails.email,
          patientPhone: patientDetails.phone,
          patientStatus: patientDetails.patientStatus,
          selectedSlotTime: new Date(selectedSlot.time),
          notes: patientDetails.notes || null,
          nexhealthBookingId: nexhealthAppointment.id.toString(),
          nexhealthPatientId: nexhealthPatientId.toString()
        }
      });

      console.log(`[Book Appointment API] WebBooking record created with ID: ${webBooking.id}`);
    } catch (dbError) {
      console.error('[Book Appointment API] Failed to create WebBooking record:', dbError);
      // Don't fail the entire request if logging fails, since the appointment was created successfully
    }

    // Step 6: Return success response
    return NextResponse.json({
      success: true,
      booking: {
        nexhealthAppointmentId: nexhealthAppointment.id,
        nexhealthPatientId: nexhealthPatientId,
        appointmentDetails: {
          patientName: `${patientDetails.firstName} ${patientDetails.lastName}`,
          appointmentType: appointmentType.name,
          duration: appointmentType.duration,
          startTime: selectedSlot.time,
          endTime: selectedSlot.end_time,
          providerId: selectedSlot.pid,
          operatoryId: selectedSlot.operatory_id
        }
      }
    });

  } catch (error) {
    console.error('[Book Appointment API] Unexpected error:', error);
    return NextResponse.json(
      { error: 'Internal server error during booking process' },
      { status: 500 }
    );
  }
}

================
File: app/api/laine-web/availability/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

interface NexhealthSlot {
  time: string;
  end_time: string;
  operatory_id: number;
}

interface NexhealthProvider {
  lid: number;
  pid: number;
  slots: NexhealthSlot[];
}

interface NexhealthResponse {
  code: boolean;
  data: NexhealthProvider[];
  error?: string;
}

interface ProcessedSlot {
  time: string;
  end_time: string;
  operatory_id: number;
  pid: number;
  lid: number;
}

interface BucketedDay {
  date: string;
  morning: ProcessedSlot[];
  afternoon: ProcessedSlot[];
  evening: ProcessedSlot[];
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { practiceId, nexhealthAppointmentTypeId, mode } = body;

    if (!practiceId || !nexhealthAppointmentTypeId || !mode) {
      return NextResponse.json(
        { error: 'practiceId, nexhealthAppointmentTypeId, and mode are required' },
        { status: 400 }
      );
    }

    if (!['first', 'fullday'].includes(mode)) {
      return NextResponse.json(
        { error: 'mode must be either "first" or "fullday"' },
        { status: 400 }
      );
    }

    console.log(`[Availability API] Fetching availability for appointment type ${nexhealthAppointmentTypeId} in ${mode} mode`);

    // Step 1: Find the appointment type and get provider/operatory configuration
    // This mirrors the logic from scripts/check-appointment-dependencies.js
    const appointmentType = await prisma.appointmentType.findFirst({
      where: { 
        nexhealthAppointmentTypeId: nexhealthAppointmentTypeId 
      },
      include: {
        practice: true,
        acceptedByProviders: {
          include: {
            savedProvider: {
              include: {
                provider: true,
                assignedOperatories: {
                  include: {
                    savedOperatory: true
                  }
                }
              }
            }
          }
        }
      }
    });

    if (!appointmentType) {
      return NextResponse.json(
        { error: 'Appointment type not found' },
        { status: 404 }
      );
    }

    // Step 2: Collect active providers and operatories
    const activeProviders = appointmentType.acceptedByProviders.filter(ap => ap.savedProvider.isActive);
    
    if (activeProviders.length === 0) {
      return NextResponse.json(
        { error: 'No active providers available for this appointment type' },
        { status: 400 }
      );
    }

    // Collect unique provider IDs (pids)
    const pids = Array.from(new Set(
      activeProviders.map(ap => ap.savedProvider.provider.nexhealthProviderId)
    )).filter(pid => pid); // Remove any null/undefined values

    // Collect unique operatory IDs (oids) from active operatories
    const oids = Array.from(new Set(
      activeProviders.flatMap(ap => 
        ap.savedProvider.assignedOperatories
          .filter(ao => ao.savedOperatory.isActive)
          .map(ao => ao.savedOperatory.nexhealthOperatoryId)
      )
    )).filter(oid => oid); // Remove any null/undefined values

    if (pids.length === 0 || oids.length === 0) {
      return NextResponse.json(
        { error: 'No active providers or operatories are configured for this appointment type' },
        { status: 400 }
      );
    }

    console.log(`[Availability API] Found ${pids.length} providers and ${oids.length} operatories`);

    // Step 3: Get practice NexHealth configuration
    const practice = appointmentType.practice;
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json(
        { error: 'Practice NexHealth configuration is incomplete' },
        { status: 400 }
      );
    }

    // Step 4: Build NexHealth API request
    const baseUrl = 'https://nexhealth.info/appointment_slots';
    const params = new URLSearchParams();
    
    params.append('subdomain', practice.nexhealthSubdomain);
    params.append('lids[]', practice.nexhealthLocationId);
    params.append('slot_length', appointmentType.duration.toString());
    params.append('overlapping_operatory_slots', 'false');
    
    // Add provider IDs
    pids.forEach(pid => params.append('pids[]', pid));

    // Add operatory IDs
    oids.forEach(oid => params.append('operatory_ids[]', oid));

    // Set date range based on mode
    const today = new Date().toISOString().split('T')[0];
    if (mode === 'first') {
      params.append('limit', '1');
      params.append('start_date', today);
      params.append('days', '7'); // Search next 7 days for first slot
    } else {
      params.append('start_date', today);
      params.append('days', '7');
    }

    const nexhealthUrl = `${baseUrl}?${params.toString()}`;
    console.log(`[Availability API] Calling NexHealth: ${nexhealthUrl}`);

    const apiToken = process.env.NEXHEALTH_API_KEY;
    if (!apiToken) {
      console.error('[Availability API] Critical Error: NEXHEALTH_API_KEY is not set in the environment.');
      return NextResponse.json(
        { error: 'Server configuration error: Missing API token.' },
        { status: 500 }
      );
    }
    console.log('[Availability API] API Token found. Proceeding to call NexHealth.');

    // Step 5: Call NexHealth API
    const nexhealthResponse = await fetch(nexhealthUrl, {
      headers: {
        'Authorization': apiToken,
        'accept': 'application/vnd.Nexhealth+json;version=2'
      }
    });

    const responseText = await nexhealthResponse.text();
    console.log('[Availability API] Raw NexHealth Response:', responseText);

    if (!nexhealthResponse.ok) {
      console.error(`[Availability API] NexHealth API error: ${nexhealthResponse.status}`);
      return NextResponse.json(
        { error: 'Failed to fetch availability from NexHealth' },
        { status: 500 }
      );
    }

    const nexhealthData: NexhealthResponse = JSON.parse(responseText);

    if (!nexhealthData.code || !nexhealthData.data) {
      console.error('[Availability API] Invalid NexHealth response:', nexhealthData);
      return NextResponse.json(
        { error: nexhealthData.error || 'Invalid response from NexHealth' },
        { status: 500 }
      );
    }

    // Step 6: Process the response based on mode
    const allSlots: ProcessedSlot[] = nexhealthData.data
      .flatMap(provider => 
        provider.slots.map(slot => ({
          time: slot.time,
          end_time: slot.end_time,
          operatory_id: slot.operatory_id,
          pid: provider.pid,
          lid: provider.lid
        }))
      )
      .filter(slot => {
        // Exclude slots that start during the 13:00 hour (1 PM - 1:59 PM)
        const slotHour = new Date(slot.time).getHours();
        return slotHour !== 13;
      });

    console.log(`[Availability API] Found ${allSlots.length} total slots`);

    if (mode === 'first') {
      // Return just the first slot
      const firstSlot = allSlots[0] || null;
      return NextResponse.json({
        success: true,
        mode: 'first',
        firstSlot,
        appointmentType: {
          name: appointmentType.name,
          duration: appointmentType.duration
        }
      });
    }

    // For fullday mode, bucket slots into morning/afternoon/evening for each day
    const bucketedDays: Record<string, BucketedDay> = {};

    allSlots.forEach(slot => {
      const slotDate = new Date(slot.time);
      const dateKey = slotDate.toISOString().split('T')[0];
      const hour = slotDate.getHours();

      if (!bucketedDays[dateKey]) {
        bucketedDays[dateKey] = {
          date: dateKey,
          morning: [],
          afternoon: [],
          evening: []
        };
      }

      if (hour < 12) {
        bucketedDays[dateKey].morning.push(slot);
      } else if (hour < 17) {
        bucketedDays[dateKey].afternoon.push(slot);
      } else {
        bucketedDays[dateKey].evening.push(slot);
      }
    });

    // Convert to array and sort by date
    const sortedDays = Object.values(bucketedDays).sort((a, b) => 
      a.date.localeCompare(b.date)
    );

    return NextResponse.json({
      success: true,
      mode: 'fullday',
      days: sortedDays,
      appointmentType: {
        name: appointmentType.name,
        duration: appointmentType.duration
      },
      totalSlots: allSlots.length
    });

  } catch (error) {
    console.error('[Availability API] Error:', error);
    return NextResponse.json(
      { error: 'Internal server error while fetching availability' },
      { status: 500 }
    );
  }
}




================================================================
End of Codebase
================================================================
