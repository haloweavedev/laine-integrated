This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: lib/tools/*.ts, app/api/vapi/tool-calls/route.ts, prisma/schema.prisma, lib/vapi.ts, lib/nexhealth.ts, **/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    vapi/
      tool-calls/
        route.ts
docs/
  webhook-management.md
lib/
  tools/
    bookAppointment.ts
    checkAvailableSlots.ts
    error-messages.ts
    findAppointmentType.ts
    findPatient.ts
    index.ts
    types.ts
  nexhealth.ts
  vapi.ts
prisma/
  schema.prisma
BOOKING_FLOW_IMPLEMENTATION.md
LLM_FIRST_IMPLEMENTATION_SUMMARY.md
README.md

================================================================
Files
================================================================

================
File: docs/webhook-management.md
================
# NexHealth Webhook Management

This document explains how to manage NexHealth webhook endpoints and subscriptions for the Laine AI Voice Assistant SaaS platform.

## Overview

The webhook management system consists of:
- **Global Webhook Endpoint**: A single endpoint on NexHealth that receives events for all practices
- **Practice Subscriptions**: Individual subscriptions linking practices to specific events
- **Management Script**: CLI tool for setting up and managing webhooks programmatically

## Prerequisites

1. **Environment Variables** (in `.env`):
   ```bash
   NEXHEALTH_API_KEY=your_master_api_key_here
   NEXT_PUBLIC_APP_URL=https://your-app-domain.com
   DATABASE_URL=your_postgresql_connection_string
   ```

2. **Master API Key**: You need the NexHealth master API key (not a practice-specific bearer token) to manage webhook endpoints.

## Quick Start

### 1. Setup Global Webhook Endpoint

First, create the global webhook endpoint that will receive events for all practices:

```bash
# Using npm script (recommended)
pnpm webhook:setup

# Or directly
node scripts/manage-nexhealth-webhooks.js setup-global-endpoint
```

This command:
- ‚úÖ Checks if endpoint already exists in database
- ‚úÖ Creates new endpoint on NexHealth if needed
- ‚úÖ Stores endpoint ID and secret key in database
- ‚úÖ Handles URL changes and endpoint updates
- ‚úÖ Is idempotent (safe to run multiple times)

**Output:**
```
üöÄ Setting up Global NexHealth Webhook Endpoint...
‚úÖ Successfully created and stored Global Webhook Endpoint:
   NexHealth Endpoint ID: 12345
   Target URL: https://your-app.vercel.app/api/nexhealth-webhook
   Secret Key: wh_secret_xyz... (stored securely in database)
```

### 2. Subscribe a Practice to Events

After setting up the global endpoint, subscribe individual practices:

```bash
# Using npm script (recommended)
pnpm webhook:subscribe dentistoffice

# Or directly
node scripts/manage-nexhealth-webhooks.js subscribe-practice dentistoffice
```

This command:
- ‚úÖ Looks up practice by subdomain in your database
- ‚úÖ Subscribes to predefined events (patient_created, appointment_insertion.complete, etc.)
- ‚úÖ Stores subscription details in database
- ‚úÖ Skips already-subscribed events
- ‚úÖ Continues on individual event failures

**Output:**
```
üîó Subscribing practice "dentistoffice" to NexHealth events...
   ‚úÖ Successfully subscribed to Patient.patient_created. NexHealth Subscription ID: 67890
   ‚úÖ Successfully subscribed to Appointment.appointment_insertion.complete. NexHealth Subscription ID: 67891
   üëç Practice "dentistoffice" already subscribed to Appointment.appointment_insertion.failed (ID: 67892).
üéâ Practice "dentistoffice" event subscriptions processed.
   ‚úÖ Successfully subscribed: 2
   üëç Already subscribed: 1
   ‚ùå Failed: 0
```

### 3. List Active Subscriptions

View all webhook subscriptions or filter by practice:

```bash
# List all subscriptions
pnpm webhook:list

# List subscriptions for specific practice
pnpm webhook:list dentistoffice

# Or directly
node scripts/manage-nexhealth-webhooks.js list-subscriptions
node scripts/manage-nexhealth-webhooks.js list-subscriptions dentistoffice
```

**Output:**
```
üìã Listing NexHealth webhook subscriptions...
üìä Found 3 subscription(s):

üè• Practice: dentistoffice
   ‚úÖ Active | Patient.patient_created | NexHealth ID: 67890
   ‚úÖ Active | Appointment.appointment_insertion.complete | NexHealth ID: 67891
   ‚úÖ Active | Appointment.appointment_insertion.failed | NexHealth ID: 67892
```

## Commands Reference

### setup-global-endpoint
Creates and configures the global webhook endpoint for your SaaS platform.

```bash
node scripts/manage-nexhealth-webhooks.js setup-global-endpoint
```

**What it does:**
1. Checks database for existing endpoint configuration
2. Validates target URL matches current `NEXT_PUBLIC_APP_URL`
3. Queries NexHealth for conflicting endpoints
4. Creates new endpoint on NexHealth
5. Stores endpoint ID and secret in `GlobalNexhealthWebhookEndpoint` table

**Idempotency:** Safe to run multiple times. Will skip if already configured correctly.

### subscribe-practice <subdomain>
Subscribes a practice to NexHealth webhook events.

```bash
node scripts/manage-nexhealth-webhooks.js subscribe-practice <subdomain>
```

**Parameters:**
- `<subdomain>`: The NexHealth subdomain for the practice (must exist in your database)

**Subscribed Events:**
- `Patient.patient_created` - New patients added to the practice
- `Patient.patient_updated` - Patient information changes (contact details, demographics, etc.)
- `Appointment.appointment_created` - New appointments detected in EHR (made outside Laine)
- `Appointment.appointment_updated` - Appointment changes (rescheduling, cancellations, modifications)
- `Appointment.appointment_insertion.complete` - New appointments scheduled successfully by Laine
- `Appointment.appointment_insertion.failed` - Failed appointment scheduling attempts by Laine
- `SyncStatus.sync_status_read_change` - EHR read functionality status changes (monitoring)
- `SyncStatus.sync_status_write_change` - EHR write functionality status changes (monitoring)

**What it does:**
1. Validates practice exists in your database
2. Retrieves global endpoint ID from database
3. Creates subscriptions for each event type on NexHealth
4. Stores subscription details in `NexhealthWebhookSubscription` table

### list-subscriptions [subdomain]
Lists all webhook subscriptions, optionally filtered by practice.

```bash
node scripts/manage-nexhealth-webhooks.js list-subscriptions [subdomain]
```

**Parameters:**
- `[subdomain]`: Optional. Filter results to specific practice

## Database Integration

The script integrates with your Prisma database using these models:

### GlobalNexhealthWebhookEndpoint
Stores the global webhook endpoint configuration:
```prisma
model GlobalNexhealthWebhookEndpoint {
  id                  String    @id @default("singleton")
  nexhealthEndpointId String    @unique // NexHealth endpoint ID
  secretKey           String    // Webhook verification secret
  targetUrl           String    // Your webhook handler URL
  isEnabled           Boolean   @default(true)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
}
```

### NexhealthWebhookSubscription
Tracks practice-specific event subscriptions:
```prisma
model NexhealthWebhookSubscription {
  id                          String   @id @default(cuid())
  practiceId                  String
  nexhealthWebhookEndpointId  String   // References global endpoint
  nexhealthSubscriptionId     String   @unique // NexHealth subscription ID
  resourceType                String   // "Patient", "Appointment", etc.
  eventName                   String   // "patient_created", etc.
  isActive                    Boolean  @default(true)
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
}
```

## Webhook Handler Integration

Your webhook handler at `/api/nexhealth-webhook` automatically:
- ‚úÖ Retrieves secret key from database for signature verification
- ‚úÖ Identifies practice by subdomain from webhook payload
- ‚úÖ Processes events according to your business logic
- ‚úÖ Returns appropriate HTTP responses to NexHealth

## Troubleshooting

### "Practice not found" Error
**Problem:** `‚ùå Practice with subdomain "xyz" not found in your database.`

**Solution:** Ensure the practice has been configured in your application first through the practice configuration flow.

### "Global webhook endpoint not configured" Error
**Problem:** `‚ùå Global webhook endpoint not configured in DB. Run "setup-global-endpoint" first.`

**Solution:** Run the setup command:
```bash
pnpm webhook:setup
```

### "NEXHEALTH_API_KEY not found" Error
**Problem:** `‚ùå NEXHEALTH_API_KEY (master key) not found in environment variables.`

**Solution:** Add your NexHealth master API key to `.env`:
```bash
NEXHEALTH_API_KEY=your_master_api_key_here
```

### "Invalid signature" in Webhook Handler
**Problem:** Webhook requests are being rejected with signature verification errors.

**Solution:** 
1. Verify the secret key in database matches what NexHealth has
2. Run `webhook:setup` to refresh the endpoint and secret
3. Check that `NEXT_PUBLIC_APP_URL` is set correctly

## Security Considerations

1. **Master API Key**: Keep your `NEXHEALTH_API_KEY` secure. It has full access to your NexHealth account.

2. **Secret Storage**: Webhook secrets are stored in your database, not environment variables, for better security and rotation capability.

3. **Signature Verification**: All webhook requests are cryptographically verified using HMAC-SHA256.

4. **HTTPS Only**: Webhook endpoints must use HTTPS in production.

## Production Deployment

1. **Set Environment Variables:**
   ```bash
   NEXHEALTH_API_KEY=your_production_master_key
   NEXT_PUBLIC_APP_URL=https://your-production-domain.com
   DATABASE_URL=your_production_postgresql_url
   ```

2. **Setup Global Endpoint:**
   ```bash
   pnpm webhook:setup
   ```

3. **Subscribe Practices:**
   ```bash
   # For each practice
   pnpm webhook:subscribe practice-subdomain-1
   pnpm webhook:subscribe practice-subdomain-2
   # etc.
   ```

4. **Verify Setup:**
   ```bash
   pnpm webhook:list
   ```

## Development vs Production

- **Development**: Use `http://localhost:3000` for `NEXT_PUBLIC_APP_URL`
- **Production**: Use your actual domain (e.g., `https://laine-integrated.vercel.app`)
- **Testing**: Use a separate NexHealth sandbox account if available

The script automatically handles URL changes when you redeploy or change domains.

================
File: lib/tools/error-messages.ts
================
/**
 * Standardized error message templates for patient-facing responses
 * These provide consistent, professional, and helpful messages across all tools
 */

export interface ErrorMessageTemplate {
  code: string;
  message: string;
  category: 'technical' | 'validation' | 'not_found' | 'permission' | 'timeout';
}

export const ERROR_MESSAGES: Record<string, ErrorMessageTemplate> = {
  // Authentication & Permission Errors
  AUTHENTICATION_ERROR: {
    code: 'AUTHENTICATION_ERROR',
    message: "I'm having trouble accessing the system right now. Please contact the office for assistance.",
    category: 'permission'
  },
  
  PERMISSION_ERROR: {
    code: 'PERMISSION_ERROR', 
    message: "I don't have permission to access that information. Please contact the office.",
    category: 'permission'
  },

  // Practice Configuration Errors
  PRACTICE_NOT_FOUND: {
    code: 'PRACTICE_NOT_FOUND',
    message: "I'm having trouble identifying the practice settings. Please contact the office.",
    category: 'technical'
  },

  PRACTICE_NOT_CONFIGURED: {
    code: 'PRACTICE_NOT_CONFIGURED',
    message: "The practice scheduling system isn't fully set up yet. Please contact the office to schedule your appointment.",
    category: 'technical'
  },

  // Patient Lookup Errors
  PATIENT_NOT_FOUND: {
    code: 'PATIENT_NOT_FOUND',
    message: "I couldn't find your information in our system. Could you please verify your name and date of birth, or contact the office directly?",
    category: 'not_found'
  },

  PATIENT_MULTIPLE_MATCHES: {
    code: 'PATIENT_MULTIPLE_MATCHES',
    message: "I found multiple patients with similar information. For your privacy and security, please contact the office directly to schedule your appointment.",
    category: 'validation'
  },

  // Appointment Type Errors
  APPOINTMENT_TYPE_NOT_FOUND: {
    code: 'APPOINTMENT_TYPE_NOT_FOUND',
    message: "I'm not sure what type of appointment you're looking for. Could you describe what you need, or would you like me to list the available services?",
    category: 'not_found'
  },

  APPOINTMENT_TYPE_AMBIGUOUS: {
    code: 'APPOINTMENT_TYPE_AMBIGUOUS', 
    message: "I found several services that might match what you're looking for. Let me help you choose the right one.",
    category: 'validation'
  },

  // Availability & Scheduling Errors
  NO_AVAILABILITY: {
    code: 'NO_AVAILABILITY',
    message: "I don't see any available appointments for that time. Would you like me to check other dates or contact the office for more options?",
    category: 'not_found'
  },

  SCHEDULING_ERROR: {
    code: 'SCHEDULING_ERROR',
    message: "I encountered an issue while checking availability. Please try again or contact the office directly.",
    category: 'technical'
  },

  // Validation Errors
  VALIDATION_ERROR: {
    code: 'VALIDATION_ERROR',
    message: "I received some unexpected information. Could you try rephrasing that?",
    category: 'validation'
  },

  INVALID_DATE: {
    code: 'INVALID_DATE',
    message: "I didn't understand that date. Could you try saying it differently, like 'next Tuesday' or 'December 15th'?",
    category: 'validation'
  },

  DATE_TOO_FAR: {
    code: 'DATE_TOO_FAR',
    message: "I can only check availability up to 3 months in advance. Please choose a date within that range.",
    category: 'validation'
  },

  DATE_IN_PAST: {
    code: 'DATE_IN_PAST',
    message: "That date has already passed. Could you choose a future date for your appointment?",
    category: 'validation'
  },

  // Technical Errors
  SYSTEM_ERROR: {
    code: 'SYSTEM_ERROR',
    message: "I'm experiencing a technical issue right now. Please try again in a moment or contact the office directly.",
    category: 'technical'
  },

  TIMEOUT_ERROR: {
    code: 'TIMEOUT_ERROR',
    message: "That request is taking longer than expected. Please try again or contact the office if the issue continues.",
    category: 'timeout'
  },

  // NexHealth API Errors
  NEXHEALTH_API_ERROR: {
    code: 'NEXHEALTH_API_ERROR',
    message: "I'm having trouble connecting to the scheduling system. Please contact the office to make your appointment.",
    category: 'technical'
  },

  NEXHEALTH_RATE_LIMIT: {
    code: 'NEXHEALTH_RATE_LIMIT',
    message: "The system is busy right now. Please wait a moment and try again, or contact the office directly.",
    category: 'timeout'
  },

  // Generic Fallback
  EXECUTION_ERROR: {
    code: 'EXECUTION_ERROR',
    message: "I encountered an issue while processing your request. Please try again or contact the office for assistance.",
    category: 'technical'
  }
};

/**
 * Get a standardized error message for a given error code
 */
export function getErrorMessage(code: string): ErrorMessageTemplate {
  return ERROR_MESSAGES[code] || ERROR_MESSAGES.EXECUTION_ERROR;
}

/**
 * Get just the patient message for a given error code
 */
export function getPatientMessage(code: string): string {
  return getErrorMessage(code).message;
}

/**
 * Determine error code from an error object
 */
export function getErrorCode(error: unknown): string {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    
    // Authentication & Permission
    if (message.includes('401') || message.includes('unauthorized')) {
      return 'AUTHENTICATION_ERROR';
    }
    if (message.includes('403') || message.includes('forbidden')) {
      return 'PERMISSION_ERROR';
    }
    
    // NexHealth specific
    if (message.includes('nexhealth')) {
      if (message.includes('rate limit') || message.includes('429')) {
        return 'NEXHEALTH_RATE_LIMIT';
      }
      return 'NEXHEALTH_API_ERROR';
    }
    
    // Validation
    if (error.name === 'ZodError' || message.includes('validation')) {
      return 'VALIDATION_ERROR';
    }
    
    // Not found
    if (message.includes('404') || message.includes('not found')) {
      return 'PATIENT_NOT_FOUND';
    }
    
    // Timeout
    if (message.includes('timeout') || message.includes('connection')) {
      return 'TIMEOUT_ERROR';
    }
  }
  
  return 'EXECUTION_ERROR';
}

/**
 * Helper to get both error code and patient message from an error
 */
export function processError(error: unknown): { code: string; message: string } {
  const code = getErrorCode(error);
  const message = getPatientMessage(code);
  return { code, message };
}

================
File: BOOKING_FLOW_IMPLEMENTATION.md
================
# üéØ Complete 4-Tool Appointment Booking Flow Implementation

## üìã Overview

Successfully implemented a complete end-to-end appointment booking system for LAINE AI Voice Assistant with 4 integrated tools that work seamlessly together.

## üõ†Ô∏è Implementation Summary

### ‚úÖ **Phase 1: Tool Analysis & Improvements**
- **Tool 1 - `find_patient_in_ehr`**: ‚úÖ Returns `patient_id` for booking
- **Tool 2 - `find_appointment_type`**: ‚úÖ Returns `appointment_type_id` and `duration_minutes` 
- **Tool 3 - `check_available_slots`**: ‚úÖ Fixed timezone display issue, returns formatted slots
- **Tool 4 - `book_appointment`**: ‚úÖ **NEWLY CREATED** - Books actual appointments

### üîß **Phase 2: Critical Bug Fixes**
- **Timezone Display Bug**: Fixed 6-hour offset error in time formatting
  - **Before**: 8:00 AM Central showed as 2:00 PM 
  - **After**: 8:00 AM Central shows correctly as 8:00 AM
- **Availability Creation**: Successfully created 22 slots for December 23, 2025
- **Error Handling**: Enhanced user-friendly error messages

### üöÄ **Phase 3: Complete Tool Integration**
- Added `book_appointment` tool to `lib/tools/index.ts` 
- Exported `bookAppointmentSchema` for validation
- Integrated with existing `fetchNexhealthAPI` function
- Added comprehensive error handling and logging

## üé≠ Ideal Call Flow

```
üë§ Caller: "I'd like to schedule an appointment."
ü§ñ Laine: "I'd be happy to help! Could you please provide your full name and date of birth?"

üë§ Caller: "My full name is Bob Ross and my date of birth is October 30, 1998."
üîß [Tool 1: find_patient_in_ehr] ‚Üí Returns patient_id: 379724872
ü§ñ Laine: "Great! I found Bob Ross, born 1998-10-30. What type of appointment would you like to schedule?"

üë§ Caller: "Can I come in for a general cleanup?"
üîß [Tool 2: find_appointment_type] ‚Üí Returns appointment_type_id: 997003, duration: 30 mins
ü§ñ Laine: "Perfect! I can schedule you for a General Cleanup which takes 30 minutes. When would you like to come in?"

üë§ Caller: "Can I come in on December twenty-third 2025?"
üîß [Tool 3: check_available_slots] ‚Üí Returns available times
ü§ñ Laine: "Great! I have these times available for Tuesday, December 23, 2025: 8:00 AM, 8:30 AM, 9:00 AM, 9:30 AM, 10:00 AM. Which time would you prefer?"

üë§ Caller: "8:00 AM"
üîß [Tool 4: book_appointment] ‚Üí Creates actual appointment
ü§ñ Laine: "Perfect! I've successfully booked your General Cleanup for Tuesday, December 23, 2025 at 8:00 AM. You should receive a confirmation shortly. Is there anything else I can help you with?"
```

## üìä Data Flow Between Tools

| Tool | Produces | Consumed By | Purpose |
|------|----------|-------------|---------|
| **find_patient_in_ehr** | `patient_id` | **book_appointment** | Patient identification |
| **find_appointment_type** | `appointment_type_id`<br>`duration_minutes` | **check_available_slots**<br>**book_appointment** | Service type & duration |
| **check_available_slots** | `available_slots`<br>`requested_date` | **book_appointment** | Date & available times |
| **book_appointment** | `appointment_id`<br>`confirmation` | *End of flow* | Final booking confirmation |

## üîß Technical Implementation Details

### **Book Appointment Tool** (`lib/tools/bookAppointment.ts`)

**Schema:**
```typescript
{
  selectedTime: string,        // "8:00 AM" from user selection  
  patientId: string,          // From find_patient_in_ehr
  appointmentTypeId: string,  // From find_appointment_type
  requestedDate: string,      // "2025-12-23" format
  durationMinutes: number     // From find_appointment_type
}
```

**NexHealth API Payload:**
```javascript
{
  location_id: 318534,
  patient_id: 379724872,
  provider_id: 377851144,
  appointment_type_id: 997003,
  operatory_id: 159815,
  start_time: "2025-12-23T08:00:00-06:00",
  end_time: "2025-12-23T08:30:00-06:00", 
  source: "laine_ai",
  note: "General Cleanup - Scheduled via LAINE AI Assistant"
}
```

### **Time Parsing Logic**
- Converts patient input ("8:00 AM") to NexHealth format ("2025-12-23T08:00:00-06:00")
- Handles 12-hour to 24-hour conversion
- Calculates end_time using appointment duration
- Uses Central Time timezone (-06:00) to match NexHealth

### **Error Handling**
- **Authentication Errors**: Clear messaging for token issues
- **Slot Conflicts**: Handles time slot no longer available
- **Validation Errors**: User-friendly messages for invalid input
- **API Failures**: Graceful fallback to office contact

## üß™ Testing & Verification

### **Scripts Created:**
1. `scripts/test-booking-tool.js` - Tests time parsing logic
2. `scripts/test-complete-booking-flow.js` - Verifies complete flow
3. `scripts/test-actual-booking.js` - Live API testing (with safety mode)

### **Test Results:**
- ‚úÖ Time parsing: "8:00 AM" ‚Üí "2025-12-23T08:00:00-06:00" 
- ‚úÖ End time calculation: 30 min duration ‚Üí "08:30:00"
- ‚úÖ Booking payload structure matches NexHealth API requirements
- ‚úÖ All tool data flows correctly between steps

## üéØ Success Metrics

### **Before Implementation:**
- ‚ùå User: "Can I come in for a general cleanup on December 23?"
- ‚ùå System: "No slots available" (due to missing availability)

### **After Implementation:**
- ‚úÖ User: "Can I come in for a general cleanup on December 23?"
- ‚úÖ System: "Great! I have these times available: 8:00 AM, 8:30 AM, 9:00 AM..."
- ‚úÖ User: "8:00 AM"
- ‚úÖ System: "Perfect! I've successfully booked your General Cleanup for Tuesday, December 23, 2025 at 8:00 AM."

## üö¶ Deployment Status

### **Ready for Live Testing:**
- ‚úÖ All 4 tools implemented and integrated
- ‚úÖ NexHealth API integration working
- ‚úÖ Timezone display bug fixed  
- ‚úÖ Availability slots created (22 slots for Dec 23)
- ‚úÖ Error handling comprehensive
- ‚úÖ User messaging optimized
- ‚úÖ Call log tracking implemented

### **Next Steps:**
1. üöÄ **Deploy to VAPI** - Push changes live
2. üìû **Live Call Testing** - Test complete flow with real calls
3. üìä **Monitor Performance** - Track booking success rates
4. üîÑ **Iterate Based on Results** - Refine based on real user interactions

## üéâ Key Achievements

1. **Complete Booking Flow**: End-to-end appointment scheduling now works
2. **Timezone Fix**: Critical bug causing wrong time display resolved  
3. **Data Persistence**: Proper flow of data between all 4 tools
4. **User Experience**: Natural conversation flow with clear prompts
5. **Error Recovery**: Graceful handling of edge cases and failures
6. **API Integration**: Robust NexHealth booking implementation
7. **Testing Framework**: Comprehensive test scripts for verification

---

**üéØ Result:** LAINE Voice Assistant can now successfully book appointments from start to finish with a natural, conversational flow that patients will love!

================
File: LLM_FIRST_IMPLEMENTATION_SUMMARY.md
================
# LAINE Voice Assistant - LLM-First Date Processing Implementation

## üß† Architectural Improvement: Manual ‚Üí LLM-First
---

## üîÑ What Changed

### ‚ùå **BEFORE: Manual Regex Approach**
```typescript
// 80+ lines of complex regex patterns and hardcoded mappings
const ordinalPattern = /(\w+)\s+(\d+)\s+(first|second|third|...)/i;
const ordinalMap = { 'twenty third': 23, 'first': 1, ... };
```

### ‚úÖ **AFTER: LLM-First Approach**
```typescript
// Clean, dynamic approach leveraging VAPI's LLM capabilities
function getCurrentDate(): string {
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2, '0');
  const dd = String(today.getDate()).padStart(2, '0');
  return `${yyyy}-${mm}-${dd}`;
}
```

---

## üéØ Key Improvements

### 1. **Dynamic Date Context**
- ‚úÖ Real-time current date: `getCurrentDate()`
- ‚úÖ Human-readable context: `getCurrentDayInfo()`
- ‚úÖ No hardcoded dates or assumptions

### 2. **Enhanced LLM Guidance**
```typescript
.describe(`
Convert the patient's natural language date request to YYYY-MM-DD format.

CURRENT DATE CONTEXT:
- ${getCurrentDayInfo()}
- Current date: ${getCurrentDate()}

EXAMPLES OF CONVERSIONS:
- "December twenty third" ‚Üí "2025-12-23"
- "next Friday" ‚Üí calculate the next Friday from ${getCurrentDate()}
- "tomorrow" ‚Üí calculate tomorrow from ${getCurrentDate()}
...
`)
```

### 3. **Simple Validation Safety Net**
```typescript
.refine((date) => {
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!dateRegex.test(date)) return false;
  const parsedDate = new Date(date);
  return !isNaN(parsedDate.getTime()) && date === parsedDate.toISOString().split('T')[0];
}, "Date must be in YYYY-MM-DD format and be a valid date")
```

---

## üß™ Testing Strategy

### Phase 1: Local Validation ‚úÖ
```bash
node scripts/test-date-normalization.js
```

**Results:**
- ‚úÖ Dynamic date generation working
- ‚úÖ Validation logic functional
- ‚úÖ Context generation accurate
- ‚úÖ Build successful, no lint errors

### Phase 2: Live Testing (After Git Push)

**Natural Language Inputs to Test:**
```javascript
const testInputs = [
  // Ordinal dates
  "December twenty third",
  "January first", 
  "March thirty first",
  
  // Relative dates
  "tomorrow",
  "next Friday", 
  "next Monday",
  "next week",
  
  // Holiday references
  "Christmas",
  "New Year's Day",
  
  // Numeric formats
  "December 23rd",
  "12/23",
  "2024-12-23",
  
  // Edge cases
  "today",
  "this Friday",
  "end of the month"
];
```

### Phase 3: Production Monitoring

**Success Metrics:**
- üìà **Date Recognition Rate**: >95% successful conversions
- üéØ **User Experience**: Natural conversation flow
- üîß **Maintenance**: Zero manual regex updates needed
- üåç **Flexibility**: Handles cultural variations and typos

---

## üöÄ Benefits of LLM-First Approach

### üß† **Intelligence**
- Natural understanding of complex date expressions
- Context-aware calculations (knows today's date)
- Can handle ambiguous input with clarifying questions

### üîß **Maintainability** 
- No more complex regex patterns to maintain
- No hardcoded ordinal mappings
- Self-improving over time without code changes

### üåç **Flexibility**
- Works with different date formats and languages
- Handles typos and variations naturally
- Cultural date references (holidays, etc.)

### üì± **Modern Architecture**
- Leverages VAPI's existing LLM capabilities
- AI-first design principles
- Scalable and future-proof

---

## üîç Implementation Details

### Core Functions

1. **`getCurrentDate()`**: Dynamic date generation
2. **`getCurrentDayInfo()`**: Human-readable context
3. **Schema validation**: Safety net for LLM outputs
4. **Enhanced descriptions**: Comprehensive LLM guidance

### Schema Design Philosophy

```typescript
// BEFORE: Transform ‚Üí Validate
.transform(manualParsingFunction)
.refine(simpleValidation)

// AFTER: Instruct ‚Üí Validate
.describe(comprehensiveInstructions)
.refine(robustValidation)
```

### Error Handling Strategy

- **Invalid Format**: Validation catches non-YYYY-MM-DD
- **Invalid Date**: Date validation ensures real dates
- **Ambiguous Input**: LLM can ask clarifying questions
- **Edge Cases**: Clear instructions for boundary conditions

---

## üéØ Expected Call Quality Impact

### **Date Processing Accuracy**: 6/10 ‚Üí 9/10

**Improvements:**
- ‚úÖ Handles "December twenty third" correctly
- ‚úÖ Processes "tomorrow" and "next Friday" naturally  
- ‚úÖ Understands "Christmas" and holiday references
- ‚úÖ Adapts to different date format preferences
- ‚úÖ Provides clarification when needed

### **Conversation Flow**: 7/10 ‚Üí 9/10

**Natural Interactions:**
- Patient: "I want to come in next Friday"
- LLM: Converts to "2024-12-27" automatically
- System: "Great! Let me check our availability for Friday, December 27th..."

---

## üìã Post-Deployment Testing Checklist

### üß™ **Functional Tests**
- [ ] Test ordinal dates: "twenty third", "first", "thirty first"
- [ ] Test relative dates: "tomorrow", "next Friday", "next week"
- [ ] Test holiday references: "Christmas", "New Year's"
- [ ] Test numeric formats: "December 23rd", "12/23"
- [ ] Test edge cases: "today", "this Friday"

### üîß **Error Handling Tests**
- [ ] Test invalid inputs: "asdfgh", "tomorrow maybe"
- [ ] Test ambiguous dates: "Friday" (which Friday?)
- [ ] Test past dates: "yesterday" (should clarify)
- [ ] Test validation rejection: Non-YYYY-MM-DD outputs

### üìä **Performance Tests**
- [ ] Monitor tool execution time
- [ ] Check LLM response quality
- [ ] Verify context accuracy (current date)
- [ ] Confirm error logging

---

## üöÄ Ready for Live Testing

**Status**: ‚úÖ Implementation Complete  
**Build**: ‚úÖ Successful compilation  
**Linting**: ‚úÖ No errors or warnings  
**Testing**: ‚úÖ Local validation complete  

**Next Steps:**
1. üîÑ Git push to deploy changes
2. üß™ Live testing with natural language inputs
3. üìä Monitor production performance
4. üéØ Validate improved user experience

**Expected Outcome**: Natural, flexible date processing that eliminates manual parsing complexity while improving user experience through VAPI's LLM capabilities.

---

**This represents a significant architectural improvement from manual rule-based parsing to modern AI-first design principles. üöÄ**

================
File: lib/tools/types.ts
================
// lib/tools/types.ts
import { z } from "zod";
import { Practice, AppointmentType, SavedProvider, SavedOperatory } from "@prisma/client";

// Enhanced practice context with scheduling data
export interface PracticeWithSchedulingData extends Practice {
  appointmentTypes: AppointmentType[];
  savedProviders: (SavedProvider & { provider: { id: string; firstName: string | null; lastName: string; nexhealthProviderId: string; } })[];
  savedOperatories: SavedOperatory[];
}

// Tool execution context
export interface ToolExecutionContext {
  practice: PracticeWithSchedulingData;
  vapiCallId: string;
  toolCallId: string;
  assistantId: string;
}

// Standardized tool result format
export interface ToolResult {
  success: boolean;
  message_to_patient: string;
  data?: Record<string, unknown>;
  error_code?: string;
  details?: string;
}

// VAPI tool definition interface
export interface VapiToolFunction {
  name: string;
  description: string;
  parameters: Record<string, unknown>; // JSON schema object
}

export interface VapiToolSchema {
  type: "function";
  async?: boolean;
  function: VapiToolFunction;
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

// Internal tool definition
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface ToolDefinition<T extends z.ZodType<any, any>> {
  name: string;
  description: string;
  schema: T;
  run: (params: { 
    args: z.infer<T>; 
    context: ToolExecutionContext 
  }) => Promise<ToolResult>;
  messages?: {
    start?: string;
    delay?: string;
    success?: string;
    fail?: string;
  };
  async?: boolean;
}

// VAPI webhook payload types
export interface VapiToolCall {
  toolCallId: string;
  name: string;
  arguments: string; // JSON string
}

export interface VapiToolCallsMessage {
  type: "tool-calls";
  timestamp: number;
  call: {
    id: string;
    assistantId: string;
    orgId?: string;
  };
  assistant: {
    id: string;
  };
  toolCallList: VapiToolCall[];
}

export interface VapiServerMessage {
  message: VapiToolCallsMessage;
}

================
File: lib/vapi.ts
================
// VAPI API Client for managing assistants and calls
// Docs: https://docs.vapi.ai

const VAPI_API_BASE_URL = "https://api.vapi.ai";
const VAPI_API_KEY = process.env.VAPI_API_KEY;

if (!VAPI_API_KEY) {
  console.warn("VAPI_API_KEY not configured - VAPI features will not work");
}

// Basic VAPI types based on their API documentation
export interface VapiModel {
  provider: "openai" | "groq" | "anthropic" | "anyscale" | "togetherai";
  model: string; // e.g., "gpt-3.5-turbo", "gpt-4", etc.
  temperature?: number;
  maxTokens?: number;
  messages: Array<{
    role: "system" | "user" | "assistant" | "function";
    content: string;
  }>;
  tools?: VapiTool[];
}

export interface VapiVoice {
  provider: "11labs" | "openai" | "playht" | "lmnt" | "neets" | "rime" | "vapi";
  voiceId: string; // Provider-specific voice ID
  speed?: number;
  stability?: number;
  similarityBoost?: number;
  style?: number;
  useSpeakerBoost?: boolean;
}

export interface VapiTool {
  type: "function";
  async?: boolean;
  function: {
    name: string;
    description: string;
    parameters: Record<string, unknown>; // JSON Schema object
  };
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

export interface VapiAssistant {
  id: string;
  name: string;
  model: VapiModel;
  voice: VapiVoice;
  firstMessage?: string;
  serverUrl?: string;
  serverMessages?: string[];
  silenceTimeoutSeconds?: number;
  maxDurationSeconds?: number;
  backgroundSound?: "off" | "office";
  backchannelingEnabled?: boolean;
  backgroundDenoisingEnabled?: boolean;
  modelOutputInMessagesEnabled?: boolean;
  transportConfigurations?: Record<string, unknown>[];
  createdAt: string;
  updatedAt: string;
}

export interface CreateAssistantDTO {
  name: string;
  model: VapiModel;
  voice: VapiVoice;
  firstMessage?: string;
  serverUrl?: string;
  serverMessages?: string[];
  silenceTimeoutSeconds?: number;
  maxDurationSeconds?: number;
  backgroundSound?: "off" | "office";
  backchannelingEnabled?: boolean;
  backgroundDenoisingEnabled?: boolean;
  modelOutputInMessagesEnabled?: boolean;
  transportConfigurations?: Record<string, unknown>[];
}

export interface UpdateAssistantDTO extends Partial<CreateAssistantDTO> {
  // All fields from CreateAssistantDTO are optional for updates
  // This interface extends Partial<CreateAssistantDTO> to allow partial updates
  _placeholder?: never; // Placeholder to avoid empty interface error
}

async function vapiRequest(
  endpoint: string,
  method: "GET" | "POST" | "PATCH" | "DELETE" = "GET",
  body?: Record<string, unknown>
): Promise<Record<string, unknown>> {
  if (!VAPI_API_KEY) {
    throw new Error("VAPI_API_KEY is not configured");
  }

  const url = `${VAPI_API_BASE_URL}${endpoint}`;
  
  const options: RequestInit = {
    method,
    headers: {
      "Authorization": `Bearer ${VAPI_API_KEY}`,
      "Content-Type": "application/json",
    },
  };

  if (body && method !== "GET") {
    options.body = JSON.stringify(body);
  }

  console.log(`VAPI API: ${method} ${url}`);
  if (body) {
    console.log("VAPI API body:", JSON.stringify(body, null, 2));
  }

  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`VAPI API error (${response.status}):`, errorText);
      throw new Error(`VAPI API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    console.log(`VAPI API response:`, JSON.stringify(data, null, 2));
    return data as Record<string, unknown>;
  } catch (error) {
    console.error("VAPI API request failed:", error);
    throw error;
  }
}

export async function createVapiAssistant(assistantConfig: CreateAssistantDTO): Promise<VapiAssistant> {
  console.log("Creating VAPI assistant:", assistantConfig.name);
  const result = await vapiRequest("/assistant", "POST", assistantConfig as unknown as Record<string, unknown>);
  return result as unknown as VapiAssistant;
}

export async function updateVapiAssistant(
  assistantId: string, 
  assistantConfig: UpdateAssistantDTO
): Promise<VapiAssistant> {
  console.log(`Updating VAPI assistant ${assistantId}`);
  const result = await vapiRequest(`/assistant/${assistantId}`, "PATCH", assistantConfig as unknown as Record<string, unknown>);
  return result as unknown as VapiAssistant;
}

export async function getVapiAssistant(assistantId: string): Promise<VapiAssistant | null> {
  try {
    console.log(`Getting VAPI assistant ${assistantId}`);
    const result = await vapiRequest(`/assistant/${assistantId}`, "GET");
    return result as unknown as VapiAssistant;
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes("404")) {
      console.log(`VAPI assistant ${assistantId} not found`);
      return null;
    }
    throw error;
  }
}

export async function deleteVapiAssistant(assistantId: string): Promise<void> {
  console.log(`Deleting VAPI assistant ${assistantId}`);
  await vapiRequest(`/assistant/${assistantId}`, "DELETE");
}

// Function to verify VAPI webhook requests (if VAPI provides signing)
export async function verifyVapiRequest(): Promise<{ verified: boolean; error?: string }> {
  // TODO: Implement if VAPI provides request signing
  // For now, return true as a placeholder
  console.log("VAPI request verification - not yet implemented");
  return { verified: true };
}

================
File: lib/tools/findAppointmentType.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const findAppointmentTypeSchema = z.object({
  userRequest: z.string().min(1).describe("The patient's description of what they want to come in for (e.g., 'cleanup', 'checkup', 'consultation', 'filling')")
});

const findAppointmentTypeTool: ToolDefinition<typeof findAppointmentTypeSchema> = {
  name: "find_appointment_type",
  description: "Matches the patient's request for service to available appointment types in the practice. Use this after confirming patient identity to determine what type of appointment they need.",
  schema: findAppointmentTypeSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.appointmentTypes || practice.appointmentTypes.length === 0) {
      return {
        success: false,
        error_code: "NO_APPOINTMENT_TYPES",
        message_to_patient: "I don't have any appointment types configured for this practice. Please contact the office directly to schedule."
      };
    }

    try {
      const userRequest = args.userRequest.toLowerCase().trim();
      
      // Create searchable appointment type list
      const availableTypes = practice.appointmentTypes.map(type => ({
        id: type.nexhealthAppointmentTypeId,
        name: type.name,
        duration: type.duration,
        searchTerms: type.name.toLowerCase()
      }));

      console.log(`[findAppointmentType] Looking for "${userRequest}" in types:`, availableTypes.map(t => t.name));

      // Simple matching algorithm - can be enhanced with fuzzy matching
      let bestMatch = null;
      let bestScore = 0;

      for (const type of availableTypes) {
        let score = 0;
        
        // Exact match gets highest score
        if (type.searchTerms.includes(userRequest)) {
          score = 100;
        }
        // Partial word matches
        else {
          const requestWords = userRequest.split(' ');
          const typeWords = type.searchTerms.split(' ');
          
          for (const requestWord of requestWords) {
            for (const typeWord of typeWords) {
              if (typeWord.includes(requestWord) || requestWord.includes(typeWord)) {
                score += 10;
              }
            }
          }
        }

        if (score > bestScore) {
          bestScore = score;
          bestMatch = type;
        }
      }

      if (!bestMatch || bestScore < 5) {
        // No good match found - present options
        const typeOptions = availableTypes
          .map(type => `${type.name} (${type.duration} minutes)`)
          .join(', ');
          
        return {
          success: true,
          message_to_patient: `I'm not sure which appointment type matches "${args.userRequest}". We have these options available: ${typeOptions}. Which one would you like?`,
          data: {
            matched: false,
            available_types: availableTypes,
            user_request: userRequest
          }
        };
      }

      // Good match found - confirm with user
      return {
        success: true,
        message_to_patient: `Perfect! I can schedule you for a ${bestMatch.name} which takes ${bestMatch.duration} minutes. When would you like to come in?`,
        data: {
          matched: true,
          appointment_type_id: bestMatch.id,
          appointment_type_name: bestMatch.name,
          duration_minutes: bestMatch.duration,
          user_request: userRequest
        }
      };

    } catch (error) {
      console.error(`[findAppointmentType] Error:`, error);
      
      return {
        success: false,
        error_code: "APPOINTMENT_TYPE_SEARCH_ERROR",
        message_to_patient: "I had trouble finding appointment types. Please tell me specifically what type of appointment you need.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me find the right appointment type for you...",
    success: "Great! I can help you schedule that appointment.",
    fail: "Let me check what appointment types we have available."
  }
};

export default findAppointmentTypeTool;

================
File: lib/tools/bookAppointment.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import { DateTime } from "luxon";

export const bookAppointmentSchema = z.object({
  selectedTime: z.string()
    .min(1)
    .describe("The specific time the patient selected from the available options (e.g., '8:00 AM', '2:30 PM'). This should match one of the display times from the previous availability check."),
  patientId: z.string()
    .min(1)
    .describe("The patient ID from the find_patient_in_ehr tool call"),
  appointmentTypeId: z.string()
    .min(1)
    .describe("The appointment type ID from the find_appointment_type tool call"),
  requestedDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe("The requested appointment date in YYYY-MM-DD format"),
  durationMinutes: z.number()
    .min(1)
    .describe("The duration of the appointment in minutes from the appointment type")
});

const bookAppointmentTool: ToolDefinition<typeof bookAppointmentSchema> = {
  name: "book_appointment",
  description: "Books the actual appointment after the patient has selected a specific time. Use this after showing available slots and getting the patient's time preference.",
  schema: bookAppointmentSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't book appointments right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "The practice hasn't configured any providers for online scheduling. Please contact the office directly."
      };
    }

    try {
      console.log(`[bookAppointment] Booking appointment for patient ${args.patientId} on ${args.requestedDate} at ${args.selectedTime}`);

      // Validate selected time format
      if (!validateSelectedTime(args.selectedTime)) {
        return {
          success: false,
          error_code: "INVALID_TIME_FORMAT",
          message_to_patient: `The time "${args.selectedTime}" is not in a valid format. Please choose a time like "8:00 AM" or "2:30 PM".`
        };
      }

      // Get practice configuration
      const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
      const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

      if (activeProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "No providers are currently available for booking. Please contact the office."
        };
      }

      if (activeOperatories.length === 0) {
        return {
          success: false,
          error_code: "NO_ACTIVE_OPERATORIES",
          message_to_patient: "No operatories are configured for booking. Please contact the office."
        };
      }

      // Get the first active provider and operatory
      const provider = activeProviders[0];
      const operatory = activeOperatories[0];

      // Convert selected time to proper start_time format
      const { startTime } = parseSelectedTimeToNexHealthFormat(
        args.selectedTime,
        args.requestedDate,
        'America/Chicago' // Default practice timezone - TODO: add to practice model
      );

      // Get appointment type name for notes
      const appointmentType = practice.appointmentTypes?.find(
        at => at.nexhealthAppointmentTypeId === args.appointmentTypeId
      );

      // Prepare booking data (matching working curl structure)
      const bookingData = {
        patient_id: parseInt(args.patientId),
        provider_id: parseInt(provider.provider.nexhealthProviderId),
        appointment_type_id: parseInt(args.appointmentTypeId),
        operatory_id: parseInt(operatory.nexhealthOperatoryId),
        start_time: startTime,
        // Note: Removed end_time and location_id as they should be in URL params
        note: appointmentType ? `${appointmentType.name} - Scheduled via LAINE AI Assistant` : "Scheduled via LAINE AI Assistant"
      };

      console.log(`[bookAppointment] Booking data:`, JSON.stringify(bookingData, null, 2));

      // Make the booking API call with correct URL parameters and body structure
      const bookingResponse = await fetchNexhealthAPI(
        '/appointments',
        practice.nexhealthSubdomain,
        {
          location_id: practice.nexhealthLocationId,
          notify_patient: 'false'
        },
        'POST',
        { appt: bookingData }  // Changed from 'appointment' to 'appt'
      );

      console.log(`[bookAppointment] Booking response:`, JSON.stringify(bookingResponse, null, 2));

      // Check if booking was successful
      if (!bookingResponse || bookingResponse.error || !bookingResponse.data) {
        console.error(`[bookAppointment] Booking failed:`, bookingResponse);
        return {
          success: false,
          error_code: "BOOKING_FAILED",
          message_to_patient: "I'm sorry, I wasn't able to book your appointment. Please contact the office to schedule.",
          details: bookingResponse?.error || "Unknown booking error"
        };
      }

      // Update call log with booking information
      await updateCallLogWithBooking(vapiCallId, bookingResponse.data.id, args.requestedDate, startTime);

      // Format confirmation message
      const appointmentTypeName = appointmentType?.name || "appointment";
      const formattedDate = formatDate(args.requestedDate);
      const formattedTime = args.selectedTime;

      return {
        success: true,
        message_to_patient: `Perfect! I've successfully booked your ${appointmentTypeName} for ${formattedDate} at ${formattedTime}. You should receive a confirmation shortly. Is there anything else I can help you with?`,
        data: {
          appointment_id: bookingResponse.data.id,
          confirmation_number: bookingResponse.data.id,
          appointment_date: args.requestedDate,
          appointment_time: args.selectedTime,
          appointment_type: appointmentTypeName,
          provider_name: provider.provider.firstName + " " + provider.provider.lastName || "Dr. " + provider.provider.lastName,
          location_name: practice.name,
          booking_source: "laine_ai"
        }
      };

    } catch (error) {
      console.error(`[bookAppointment] Error:`, error);
      
      let message = "I'm having trouble booking your appointment right now. Please contact the office to schedule.";
      if (error instanceof Error) {
        if (error.message.includes("401")) {
          message = "There's an authentication issue with the booking system. Please contact the office.";
        } else if (error.message.includes("conflict") || error.message.includes("409")) {
          message = "That time slot is no longer available. Would you like me to check for other available times?";
        }
      }
      
      return {
        success: false,
        error_code: "BOOKING_ERROR",
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me book that appointment for you...",
    success: "Perfect! Your appointment has been confirmed.",
    fail: "I'm having trouble booking your appointment right now."
  }
};

/**
 * Validate that the selected time is in the correct format
 */
function validateSelectedTime(selectedTime: string): boolean {
  // Check if the time matches expected format (e.g., "8:00 AM", "12:30 PM")
  const timePattern = /^(1[0-2]|[1-9]):([0-5][0-9])\s?(AM|PM)$/i;
  return timePattern.test(selectedTime.trim());
}

/**
 * Convert patient's selected time to NexHealth API format with proper timezone handling
 */
function parseSelectedTimeToNexHealthFormat(
  selectedTime: string,
  requestedDate: string,
  practiceTimezone: string = 'America/Chicago'
): { startTime: string } {
  // Parse the selected time and date in the practice's timezone
  const localDateTime = DateTime.fromFormat(
    `${requestedDate} ${selectedTime}`,
    'yyyy-MM-dd h:mm a',
    { zone: practiceTimezone }
  );

  if (!localDateTime.isValid) {
    throw new Error(`Invalid date/time format: ${requestedDate} ${selectedTime}. Error: ${localDateTime.invalidReason}`);
  }

  // Convert to UTC and format for NexHealth API
  const startTime = localDateTime.toUTC().toISO({ suppressMilliseconds: true });

  if (!startTime) {
    throw new Error(`Failed to convert to UTC: ${requestedDate} ${selectedTime}`);
  }

  console.log(`[timezone] Converting ${selectedTime} on ${requestedDate} in ${practiceTimezone} to UTC: ${startTime}`);

  return { startTime };
}

/**
 * Format date for patient-friendly display
 */
function formatDate(dateString: string): string {
  try {
    const date = new Date(dateString + 'T00:00:00');
    return date.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  } catch {
    return dateString;
  }
}

/**
 * Update call log with booking information
 */
async function updateCallLogWithBooking(
  vapiCallId: string,
  appointmentId: string,
  appointmentDate: string,
  appointmentTime: string
) {
  try {
    const { prisma } = await import("@/lib/prisma");
    await prisma.callLog.update({
      where: { vapiCallId },
      data: {
        callStatus: "APPOINTMENT_BOOKED",
        bookedAppointmentNexhealthId: appointmentId,
        summary: `Appointment booked for ${appointmentDate} at ${appointmentTime}`,
        updatedAt: new Date()
      }
    });
  } catch (error) {
    console.error("[bookAppointment] Error updating call log:", error);
  }
}

export default bookAppointmentTool;

================
File: lib/tools/findPatient.ts
================
// lib/tools/findPatient.ts
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

export const findPatientSchema = z.object({
  firstName: z.string().min(1).describe("The first name of the patient"),
  lastName: z.string().min(1).describe("The last name of the patient"),
  dateOfBirth: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD").describe("Patient's date of birth in YYYY-MM-DD format")
});

const findPatientTool: ToolDefinition<typeof findPatientSchema> = {
  name: "find_patient_in_ehr",
  description: "Searches for an existing patient in the Electronic Health Record using first name, last name, and date of birth. Use this before any appointment scheduling to verify patient identity.",
  schema: findPatientSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I'm sorry, I can't access patient records right now. Please contact the office directly."
      };
    }

    try {
      const patientName = `${args.firstName} ${args.lastName}`;
      const searchParams = {
        location_id: practice.nexhealthLocationId,
        name: patientName,
        date_of_birth: args.dateOfBirth,
        inactive: 'false',
        non_patient: 'false',
        page: '1',
        per_page: '5'
      };

      console.log(`[findPatient] Searching for: ${patientName}, DOB: ${args.dateOfBirth}`);
      
      const searchResults = await fetchNexhealthAPI(
        '/patients',
        practice.nexhealthSubdomain,
        searchParams
      );
      
      // Handle different response structures
      let patients = [];
      if (Array.isArray(searchResults)) {
        patients = searchResults;
      } else if (searchResults?.data?.patients) {
        patients = searchResults.data.patients;
      } else if (searchResults?.patients) {
        patients = searchResults.patients;
      } else if (searchResults?.data && Array.isArray(searchResults.data)) {
        patients = searchResults.data;
      }

      console.log(`[findPatient] Found ${patients.length} potential matches`);

      if (patients.length === 0) {
        return {
          success: true,
          message_to_patient: `I couldn't find a patient named ${args.firstName} ${args.lastName} with that date of birth. Would you like me to help you schedule as a new patient, or would you like to try different information?`,
          data: { found_patients: [], patient_exists: false }
        };
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const patient = patients[0] as any; // Take first match
      
      // Store patient context for subsequent tool calls
      await updateCallLogWithPatient(vapiCallId, practice.id, String(patient.id));
      
      return {
        success: true,
        message_to_patient: `Great! I found ${patient.first_name || args.firstName} ${patient.last_name || args.lastName}, born ${patient.bio?.date_of_birth || args.dateOfBirth}. What type of appointment would you like to schedule?`,
        data: {
          found_patients: [{
            id: patient.id,
            firstName: patient.first_name,
            lastName: patient.last_name,
            dob: patient.bio?.date_of_birth || patient.date_of_birth
          }],
          patient_exists: true,
          patient_id: patient.id
        }
      };

    } catch (error) {
      console.error(`[findPatient] Error:`, error);
      
      let message = "I'm having trouble accessing patient records right now. Please try again in a moment.";
      if (error instanceof Error && error.message.includes("401")) {
        message = "There's an authentication issue with the patient system. Please contact support.";
      }
      
      return {
        success: false,
        error_code: "NEXHEALTH_API_ERROR",
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me look that up for you...",
    success: "Perfect! I found your information.",
    fail: "I'm having trouble finding that record. Let me help you with that."
  }
};

async function updateCallLogWithPatient(vapiCallId: string, practiceId: string, patientId: string) {
  try {
    const { prisma } = await import("@/lib/prisma");
    await prisma.callLog.upsert({
      where: { vapiCallId },
      create: {
        vapiCallId,
        practiceId,
        callStatus: "TOOL_IN_PROGRESS",
        nexhealthPatientId: patientId,
        callTimestampStart: new Date()
      },
      update: {
        nexhealthPatientId: patientId,
        updatedAt: new Date()
      }
    });
  } catch (error) {
    console.error("[findPatient] Error updating call log:", error);
  }
}

export default findPatientTool;

================
File: README.md
================
# Laine AI Voice Assistant

AI-powered voice assistant for healthcare practices, integrating NexHealth EHR with VAPI voice AI technology.

## Features

- üéôÔ∏è **VAPI Voice Integration**: AI-powered voice calls with customizable assistants
- üè• **NexHealth EHR Integration**: Patient lookup, appointment management, and data synchronization
- üîó **Webhook Management**: Automated event handling for appointments and patient updates
- üë§ **Practice Management**: Multi-tenant SaaS platform with practice-specific configurations
- üîí **Secure Authentication**: Clerk-based user authentication and practice isolation

## Quick Start

1. **Environment Setup**:
   ```bash
   cp .env.example .env
   # Configure your API keys and database URL
   ```

2. **Database Setup**:
   ```bash
   pnpm install
   pnpm db:push
   ```

3. **Development Server**:
   ```bash
   pnpm dev
   ```

4. **Webhook Configuration** (Production):
   ```bash
   # Setup global webhook endpoint
   pnpm webhook:setup
   
   # Subscribe practices to events
   pnpm webhook:subscribe your-practice-subdomain
   ```

## Documentation

- üìñ [Webhook Management Guide](docs/webhook-management.md) - Complete guide to NexHealth webhook setup
- üõ†Ô∏è [API Documentation](docs/api.md) - API endpoints and integration details

## Technology Stack

- **Frontend**: Next.js 15, React 19, Tailwind CSS
- **Backend**: Next.js API Routes, Prisma ORM
- **Database**: PostgreSQL (Supabase)
- **Authentication**: Clerk
- **Voice AI**: VAPI
- **EHR Integration**: NexHealth API
- **Deployment**: Vercel

## Key Components

### VAPI Assistant Integration
- AI voice assistants with customizable voices and prompts
- Tool calling system for EHR operations
- Call logging and transcript management

### NexHealth Integration  
- Patient search and data retrieval
- Appointment scheduling and management
- Real-time webhook event processing

### Practice Management
- Multi-tenant architecture with practice isolation
- Configurable assistant settings per practice
- Automated practice onboarding workflow

# LAINE Project Context

## **Project Overview**
**LAINE** is an AI voice receptionist SaaS platform for dental practices. It enables dental offices to automate patient interactions, appointment scheduling, and EHR integration through AI voice assistants.

## **Core Functionality**
- **AI Voice Reception**: Patients call and speak with an AI assistant (powered by VAPI)
- **Patient Lookup**: Find existing patients in the practice's EHR system
- **Appointment Scheduling**: Check availability and book appointments
- **EHR Integration**: Connect with NexHealth to access patient records and scheduling
- **Multi-Tenant SaaS**: Each dental practice gets isolated data and configuration

## **Technology Stack**

### **Frontend**
- **Next.js 15+** (App Router)
- **React 19** with TypeScript
- **Tailwind CSS** for styling
- **Clerk** for authentication

### **Backend**
- **Next.js API Routes** 
- **Prisma ORM** with PostgreSQL
- **Supabase** for database hosting

### **External Integrations**
- **VAPI**: AI voice calling platform
- **NexHealth**: Dental practice EHR/scheduling system  
- **Clerk**: User authentication and management

### **Key Dependencies**
- `@clerk/nextjs` - Authentication
- `@prisma/client` - Database ORM
- `zod` - Schema validation
- `sonner` - Toast notifications

## **Architecture Patterns**

### **Multi-Tenant SaaS Design**
- Each dental practice is isolated by `practiceId`
- Users authenticate via Clerk (`clerkUserId`)
- All data operations are practice-scoped

### **Tool-Based AI Framework**
- AI assistant uses "tools" to perform actions
- Tools are TypeScript functions with Zod schemas
- Centralized tool execution via webhook handler

### **API Integration Layer**
- NexHealth API for EHR operations
- VAPI API for voice assistant management
- Token-based authentication with caching

## **Database Schema (Key Models)**

### **Core Models**
```prisma
Practice {
  id: String (Primary Key)
  clerkUserId: String (Unique - links to Clerk user)
  name: String? (Optional practice name)
  nexhealthSubdomain: String? (NexHealth subdomain)
  nexhealthLocationId: String? (NexHealth location ID)
}

PracticeAssistantConfig {
  practiceId: String (FK to Practice)
  vapiAssistantId: String? (VAPI assistant ID)
  voiceProvider: String (voice provider)
  systemPrompt: String (AI instructions)
  firstMessage: String (greeting message)
}
```

### **Scheduling Models**
```prisma
AppointmentType {
  practiceId: String (FK to Practice)
  nexhealthAppointmentTypeId: String (NexHealth ID)
  name: String (e.g., "General Cleanup")
  duration: Int (minutes)
}

Provider {
  practiceId: String (FK to Practice) 
  nexhealthProviderId: String (NexHealth ID)
  firstName: String?
  lastName: String
}

SavedProvider {
  practiceId: String (FK to Practice)
  providerId: String (FK to Provider)
  isDefault: Boolean
  isActive: Boolean
}
```

### **Logging Models**
```prisma
CallLog {
  vapiCallId: String (Unique - from VAPI)
  practiceId: String (FK to Practice)
  callStatus: String (e.g., "IN_PROGRESS", "ENDED")
  transcriptText: String?
  nexhealthPatientId: String? (if patient found)
}

ToolLog {
  practiceId: String (FK to Practice)
  vapiCallId: String? (FK to CallLog)
  toolName: String (e.g., "find_patient_in_ehr")
  toolCallId: String (VAPI tool call ID)
  arguments: String (JSON)
  result: String (JSON)
  success: Boolean
}
```

## **Key API Endpoints**

### **VAPI Integration**
- `POST /api/vapi/tool-calls` - Centralized tool execution webhook
- `POST /api/vapi/webhook` - General VAPI webhooks (call status, transcripts)

### **Practice Configuration**
- `POST /api/practice-config/providers` - Save provider preferences
- `POST /api/practice-config/operatories` - Save operatory preferences
- `POST /api/sync-nexhealth` - Sync data from NexHealth API

### **NexHealth Integration**
- `POST /api/nexhealth-webhook` - Receive NexHealth events
- `POST /api/webhook-subscribe` - Subscribe to NexHealth events

## **AI Tools Framework**

### **Tool Structure**
Each tool is defined with:
```typescript
interface ToolDefinition<T extends z.ZodType> {
  name: string                    // Tool identifier
  description: string             // What the tool does
  schema: T                      // Zod validation schema
  run: (params) => Promise<ToolResult>  // Tool execution logic
  messages?: ToolMessages        // VAPI voice prompts
}
```

### **Current Tools**
1. **`find_patient_in_ehr`** - Search for patients by name and DOB
2. **`find_appointment_type`** - Match patient requests to appointment types
3. **`check_available_slots`** - Find available appointment times

### **Tool Execution Flow**
1. VAPI calls `/api/vapi/tool-calls` webhook
2. Practice identified by assistant ID
3. Tool arguments validated with Zod
4. Tool executes with practice context
5. Results logged to database
6. Response sent back to VAPI

## **Typical User Journey**

### **Practice Setup**
1. Practice owner signs up via Clerk
2. Configure NexHealth subdomain and location ID
3. Sync appointment types and providers from NexHealth
4. Select preferred providers and operatories for scheduling
5. Create and configure VAPI voice assistant

### **Patient Interaction**
1. Patient calls dental office phone number
2. VAPI voice assistant answers
3. Assistant asks for patient name and date of birth
4. `find_patient_in_ehr` tool searches NexHealth EHR
5. If patient found, assistant asks about appointment purpose
6. `find_appointment_type` tool matches request to available types
7. `check_available_slots` tool finds available times
8. Assistant presents options to patient

## **Environment Variables**
```bash
# Database
DATABASE_URL=postgresql://...

# Authentication  
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_...
CLERK_SECRET_KEY=sk_...

# VAPI Integration
VAPI_API_KEY=vapi_...
NEXT_PUBLIC_APP_URL=https://your-domain.com

# NexHealth Integration
NEXHEALTH_API_KEY=nexhealth_...
NEXHEALTH_API_BASE_URL=https://nexhealth.info
```

## **Key File Structure**
```
app/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ vapi/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tool-calls/route.ts     # Centralized tool handler
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ webhook/route.ts        # VAPI general webhooks
‚îÇ   ‚îú‚îÄ‚îÄ practice-config/            # Practice management APIs
‚îÇ   ‚îî‚îÄ‚îÄ nexhealth-webhook/route.ts  # NexHealth event handler
‚îú‚îÄ‚îÄ practice-config/                # Practice configuration UI
‚îî‚îÄ‚îÄ laine/                         # Assistant configuration UI

lib/
‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îú‚îÄ‚îÄ types.ts                   # Tool framework types
‚îÇ   ‚îú‚îÄ‚îÄ index.ts                   # Tool registry
‚îÇ   ‚îú‚îÄ‚îÄ findPatient.ts            # Patient lookup tool
‚îÇ   ‚îú‚îÄ‚îÄ findAppointmentType.ts    # Appointment type matching
‚îÇ   ‚îî‚îÄ‚îÄ checkAvailableSlots.ts    # Availability checking
‚îú‚îÄ‚îÄ nexhealth.ts                  # NexHealth API client
‚îú‚îÄ‚îÄ vapi.ts                       # VAPI API client
‚îî‚îÄ‚îÄ prisma.ts                     # Database client

prisma/
‚îî‚îÄ‚îÄ schema.prisma                  # Database schema
```

## **Development Commands**
```bash
# Development
pnpm dev                          # Start development server
pnpm build                        # Build for production
pnpm lint                         # Run ESLint

# Database
pnpm db:push                      # Push schema changes
pnpm db:list                      # List database contents
pnpm db:clean                     # Clean test data

# Webhooks
pnpm webhook:setup                # Setup NexHealth webhook endpoint
pnpm webhook:subscribe <subdomain> # Subscribe practice to events
pnpm webhook:list                 # List webhook subscriptions
```

## **Common Patterns**

### **Practice Context Injection**
All operations include practice context:
```typescript
const practice = await findPracticeByAssistantId(assistantId);
// All subsequent operations are practice-scoped
```

### **Error Handling**
User-friendly error messages for patients:
```typescript
return {
  success: false,
  error_code: "PATIENT_NOT_FOUND",
  message_to_patient: "I couldn't find that patient. Would you like to try different information?"
};
```

### **Tool Result Format**
Standardized response format:
```typescript
interface ToolResult {
  success: boolean
  message_to_patient: string  // What the AI says to the patient
  data?: Record<string, unknown>  // Structured data
  error_code?: string  // Error classification
}
```

================
File: lib/tools/index.ts
================
import { ToolDefinition, VapiToolSchema, VapiToolFunction } from "./types";
import { zodToJsonSchema } from "zod-to-json-schema";

// Import all tools
import findPatientTool from "./findPatient";
import findAppointmentTypeTool from "./findAppointmentType";
import checkAvailableSlotsTool from "./checkAvailableSlots";
import bookAppointmentTool from "./bookAppointment";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const tools: ToolDefinition<any>[] = [
  findPatientTool,
  findAppointmentTypeTool,
  checkAvailableSlotsTool,
  bookAppointmentTool
];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function getToolByName(name: string): ToolDefinition<any> | undefined {
  return tools.find(t => t.name === name);
}

// This function builds the array for VAPI's `model.tools[]`
export function buildVapiTools(appBaseUrl: string): VapiToolSchema[] {
  console.log(`Building VAPI tools for ${tools.length} registered tools`);
  
  return tools.map(tool => {
    // Generate JSON schema without $schema property
    const schema = zodToJsonSchema(tool.schema, { 
      target: "jsonSchema7", 
      $refStrategy: "none" 
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $schema, ...parameters } = schema;
    
    const vapiToolFunction: VapiToolFunction = {
      name: tool.name,
      description: tool.description,
      parameters
    };
    
    const vapiTool: VapiToolSchema = {
      type: "function",
      async: tool.async ?? false,
      function: vapiToolFunction,
      server: { 
        url: `${appBaseUrl}/api/vapi/tool-calls`
      }
    };

    // Add tool-specific messages if defined
    if (tool.messages) {
      vapiTool.messages = [
        tool.messages.start ? { type: "request-start", content: tool.messages.start } : null,
        tool.messages.delay ? { type: "request-response-delayed", content: tool.messages.delay, timingMilliseconds: 2000 } : null,
        tool.messages.success ? { type: "request-complete", content: tool.messages.success } : null,
        tool.messages.fail ? { type: "request-failed", content: tool.messages.fail } : null,
      ].filter(Boolean) as VapiToolSchema["messages"];
    }
    
    console.log(`Built VAPI tool: ${tool.name} -> ${vapiTool.server.url}`);
    return vapiTool;
  });
}

// Export individual tool schemas for validation
export { findPatientSchema } from "./findPatient";
export { findAppointmentTypeSchema } from "./findAppointmentType";
export { checkAvailableSlotsSchema } from "./checkAvailableSlots";
export { bookAppointmentSchema } from "./bookAppointment";

================
File: lib/nexhealth.ts
================
import { prisma } from "@/lib/prisma";
import { addSeconds } from 'date-fns';

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number; // NexHealth uses 'minutes' not 'duration'
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

interface NexHealthOperatory {
  id: number;
  name: string;
  location_id: number;
  active: boolean;
}

const NEXHEALTH_API_BASE_URL = process.env.NEXHEALTH_API_BASE_URL!;
const MASTER_NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY!; // The master key

const TOKEN_CACHE_ID = "singleton"; // Fixed ID for the single token entry
const TOKEN_EXPIRY_BUFFER_SECONDS = 300; // 5 minutes buffer
const DEFAULT_TOKEN_LIFETIME_SECONDS = 55 * 60; // 55 minutes (safe for 1-hour tokens)

async function fetchNewBearerToken(): Promise<{ accessToken: string; expiresAt: Date }> {
  if (!MASTER_NEXHEALTH_API_KEY) {
    throw new Error("NEXHEALTH_API_KEY is not configured in environment variables.");
  }

  const authUrl = `${NEXHEALTH_API_BASE_URL}/authenticates`;
  console.log("Fetching new NexHealth bearer token...");

  try {
    const response = await fetch(authUrl, {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.Nexhealth+json;version=2',
        // NexHealth expects the raw master key for /authenticates endpoint
        'Authorization': MASTER_NEXHEALTH_API_KEY,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("Failed to fetch NexHealth bearer token:", response.status, errorBody);
      throw new Error(`NexHealth Authentication failed: ${response.status} - ${errorBody}`);
    }

    const result = await response.json();
    
    if (!result.data || !result.data.token) {
      console.error("NexHealth /authenticates response missing token:", result);
      throw new Error("Invalid token response from NexHealth /authenticates");
    }

    const accessToken = result.data.token;
    const now = new Date();
    
    // If NexHealth provides expiry in response, use it. Otherwise, use default lifetime.
    // Most JWT tokens have 1-hour validity, we use 55 minutes to be safe
    let expiresAt: Date;
    
    if (result.data.exp) {
      // If exp is provided as UNIX timestamp (seconds)
      expiresAt = new Date(result.data.exp * 1000);
    } else {
      // Default to 55 minutes from now
      expiresAt = addSeconds(now, DEFAULT_TOKEN_LIFETIME_SECONDS);
    }

    console.log(`New NexHealth token expires at: ${expiresAt.toISOString()}`);

    // Cache the token in database
    await prisma.nexhealthTokenCache.upsert({
      where: { id: TOKEN_CACHE_ID },
      update: { accessToken, expiresAt },
      create: { id: TOKEN_CACHE_ID, accessToken, expiresAt },
    });

    return { accessToken, expiresAt };
  } catch (error) {
    console.error('Error fetching NexHealth bearer token:', error);
    throw error;
  }
}

export async function getNexhealthBearerToken(): Promise<string> {
  try {
    // Check for cached token
    const cachedToken = await prisma.nexhealthTokenCache.findUnique({
      where: { id: TOKEN_CACHE_ID },
    });

    if (cachedToken) {
      const now = new Date();
      const tokenStillValidUntil = addSeconds(now, TOKEN_EXPIRY_BUFFER_SECONDS);
      
      if (cachedToken.expiresAt > tokenStillValidUntil) {
        console.log("Using cached NexHealth bearer token.");
        return cachedToken.accessToken;
      }
      console.log("Cached NexHealth token expired or nearing expiry.");
    } else {
      console.log("No cached NexHealth token found.");
    }

    // Fetch new token if none cached or expired
    const { accessToken } = await fetchNewBearerToken();
    return accessToken;
  } catch (error) {
    console.error('Error getting NexHealth bearer token:', error);
    throw error;
  }
}

// Export the generic API function for use in tools and other modules
export async function fetchNexhealthAPI(
  path: string, // e.g., "/appointment_types"
  subdomain: string, // Practice-specific subdomain
  params?: Record<string, string | number | string[]>,
  method: string = 'GET',
  body?: unknown
) {
  // Get valid bearer token
  const bearerToken = await getNexhealthBearerToken();
  
  const url = new URL(`${NEXHEALTH_API_BASE_URL}${path}`);
  
  // Add subdomain for data API calls (not for /authenticates)
  if (path !== '/authenticates' && !params?.subdomain) {
    url.searchParams.append('subdomain', subdomain);
  }
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v.toString()));
      } else {
        url.searchParams.append(key, value.toString());
      }
    });
  }

  const options: RequestInit = {
    method,
    headers: {
      'Accept': 'application/vnd.Nexhealth+json;version=2',
      'Authorization': `Bearer ${bearerToken}`, // Use bearer token for data APIs
      'Content-Type': 'application/json',
    },
  };

  if (body && method !== 'GET') {
    options.body = JSON.stringify(body);
  }

  console.log(`Fetching from NexHealth: ${method} ${url.toString()} for subdomain ${subdomain}`);

  try {
    const response = await fetch(url.toString(), options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`NexHealth API error (${response.status}):`, errorText);
      
      // If we get 401, the token might be invalid - clear cache and retry once
      if (response.status === 401) {
        console.log("Got 401, clearing token cache and retrying...");
        await prisma.nexhealthTokenCache.deleteMany({
          where: { id: TOKEN_CACHE_ID }
        });
        
        // Retry with fresh token (recursive call - but only once due to cache clear)
        return fetchNexhealthAPI(path, subdomain, params, method, body);
      }
      
      throw new Error(`NexHealth API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('NexHealth API error:', error);
    throw error;
  }
}

export async function getAppointmentTypes(subdomain: string, locationId: string): Promise<NexHealthAppointmentType[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    { location_id: locationId }
  );
  
  console.log("Raw NexHealth appointment_types response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let appointmentTypes = null;
  
  if (Array.isArray(data)) {
    appointmentTypes = data;
  } else if (data?.data?.appointment_types && Array.isArray(data.data.appointment_types)) {
    appointmentTypes = data.data.appointment_types;
  } else if (data?.appointment_types && Array.isArray(data.appointment_types)) {
    appointmentTypes = data.appointment_types;
  } else if (data?.data && Array.isArray(data.data)) {
    appointmentTypes = data.data;
  } else {
    console.warn("Unexpected appointment_types response structure:", data);
    appointmentTypes = [];
  }
  
  console.log(`Parsed ${appointmentTypes.length} appointment types`);
  return appointmentTypes;
}

export async function getProviders(subdomain: string, locationId: string): Promise<NexHealthProvider[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/providers',
    subdomain,
    { location_id: locationId, inactive: 'false' }
  );
  
  console.log("Raw NexHealth providers response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let providers = null;
  
  if (Array.isArray(data)) {
    providers = data;
  } else if (data?.data?.providers && Array.isArray(data.data.providers)) {
    providers = data.data.providers;
  } else if (data?.providers && Array.isArray(data.providers)) {
    providers = data.providers;
  } else if (data?.data && Array.isArray(data.data)) {
    providers = data.data;
  } else {
    console.warn("Unexpected providers response structure:", data);
    providers = [];
  }
  
  console.log(`Parsed ${providers.length} providers`);
  return providers;
}

export async function getOperatories(subdomain: string, locationId: string): Promise<NexHealthOperatory[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/operatories',
    subdomain,
    { location_id: locationId, page: '1', per_page: '50' }
  );
  
  console.log("Raw NexHealth operatories response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let operatories = null;
  
  if (Array.isArray(data)) {
    operatories = data;
  } else if (data?.data?.operatories && Array.isArray(data.data.operatories)) {
    operatories = data.data.operatories;
  } else if (data?.operatories && Array.isArray(data.operatories)) {
    operatories = data.operatories;
  } else if (data?.data && Array.isArray(data.data)) {
    operatories = data.data;
  } else {
    console.warn("Unexpected operatories response structure:", data);
    operatories = [];
  }
  
  console.log(`Parsed ${operatories.length} operatories`);
  return operatories.filter((op: NexHealthOperatory) => op.active !== false);
}

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Practice {
  id                      String @id @default(cuid())
  clerkUserId             String @unique // Links to Clerk User ID
  name                    String?       // Optional practice name entered by user

  // NexHealth specific identifiers for this practice instance
  nexhealthSubdomain      String?       // User-provided NexHealth subdomain
  nexhealthLocationId     String?       // User-provided NexHealth Location ID

  // Webhook synchronization tracking
  webhookLastSyncAt       DateTime?     // Last time webhooks were synchronized

  // VAPI Assistant relationship - moved to separate config table for better modularity
  assistantConfig   PracticeAssistantConfig? // One-to-one relation
  nexhealthWebhookSubscriptions NexhealthWebhookSubscription[] // One-to-many

  appointmentTypes AppointmentType[]
  providers        Provider[]
  callLogs         CallLog[] // For VAPI call logging
  toolLogs         ToolLog[] // For tool execution logging

  // Add new relationships for scheduling preferences
  savedProviders      SavedProvider[]
  savedOperatories    SavedOperatory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A practice is uniquely identified by its Clerk user for our app's purposes.
  // Subdomain + LocationID identify it for NexHealth API calls.
  // If a user could manage multiple NexHealth locations, this model would need adjustment.
  // For now, one Clerk user maps to one set of NexHealth subdomain/locationId.
}

model SavedProvider {
  id                  String @id @default(cuid())
  practiceId          String
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  providerId          String   // References Provider.id from our synced data
  provider            Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  isDefault           Boolean  @default(false) // Mark primary/default provider
  isActive            Boolean  @default(true)  // Allow enabling/disabling
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@unique([practiceId, providerId]) // Prevent duplicate saves
  @@map("saved_providers")
}

model SavedOperatory {
  id                  String @id @default(cuid())
  practiceId          String
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  nexhealthOperatoryId String  // NexHealth operatory ID
  name                String  // Display name for operatory
  isDefault           Boolean @default(false) // Mark primary/default operatory
  isActive            Boolean @default(true)  // Allow enabling/disabling
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@unique([practiceId, nexhealthOperatoryId]) // Prevent duplicate saves
  @@map("saved_operatories")
}

model PracticeAssistantConfig {
  id                  String @id @default(cuid())
  practiceId          String @unique
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  vapiAssistantId     String? @unique // The ID of the assistant on VAPI's platform
  
  // Customizable fields by practice
  voiceProvider       String   @default("11labs") // e.g., "11labs", "openai", "playht"
  voiceId             String   @default("burt")   // e.g., "burt" for 11labs, "alloy" for openai
  // voiceModel is often tied to provider/voiceId, can be added if needed

  systemPrompt        String   @default("You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.")
  firstMessage        String   @default("Hello! This is Laine from your dental office. How can I help you today?")

  // Potentially store other VAPI settings if customization is expanded
  // serverUrl for tool calls will be derived from NEXT_PUBLIC_APP_URL

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

// For storing details about the global NexHealth webhook endpoint managed by the SaaS
model GlobalNexhealthWebhookEndpoint {
  id                  String    @id @default("singleton") // Ensures only one record
  nexhealthEndpointId String    @unique // The ID from NexHealth API after creating the endpoint
  secretKey           String    // The secret key provided by NexHealth for this endpoint
  targetUrl           String    // The URL registered with NexHealth (e.g., https://laine-integrated.vercel.app/api/nexhealth-webhook)
  isEnabled           Boolean   @default(true)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
}

// For tracking which practices are subscribed to which NexHealth events
model NexhealthWebhookSubscription {
  id                          String   @id @default(cuid())
  practiceId                  String
  practice                    Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  nexhealthWebhookEndpointId  String   // Foreign key to the global endpoint ID from NexHealth
  nexhealthSubscriptionId     String   @unique // The ID of this specific subscription from NexHealth API
  resourceType                String   // e.g., "Appointment", "Patient"
  eventName                   String   // e.g., "appointment_insertion.complete", "patient_created"
  isActive                    Boolean  @default(true)

  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt

  @@unique([practiceId, resourceType, eventName]) // A practice should only have one active sub for a specific event
}

// For VAPI call logging, as per blueprint
model CallLog {
  id                            String    @id @default(cuid()) // Or use vapi_call_id as PK if always present early
  vapiCallId                    String    @unique // From VAPI
  practiceId                    String
  practice                      Practice  @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  callTimestampStart            DateTime?
  callStatus                    String?   // e.g., INITIATED, IN_PROGRESS, FORWARDING, ENDED
  transcriptText                String?   @db.Text
  summary                       String?   @db.Text // End of call report summary
  vapiTranscriptUrl             String?   // URL to audio recording

  // Fields for tracking tool usage and outcomes within a call
  detectedIntent                String?
  nexhealthPatientId            String?   // If patient identified/created
  bookedAppointmentNexhealthId  String?   // If appointment booked

  // Enhanced fields as per refactoring plan
  assistantId                   String?   // VAPI assistant ID
  endedReason                   String?   // From end-of-call-report
  callDurationSeconds           Int?      // Duration in seconds
  cost                          Decimal?  // Call cost if available

  toolLogs                      ToolLog[] // One-to-many relationship

  createdAt                     DateTime  @default(now())
  updatedAt                     DateTime  @updatedAt
}

// New model for tracking individual tool executions
model ToolLog {
  id                String    @id @default(cuid())
  practiceId        String
  practice          Practice  @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  vapiCallId        String?   // Optional - tools might be called outside of calls
  callLog           CallLog?  @relation(fields: [vapiCallId], references: [vapiCallId], onDelete: Cascade)
  
  toolName          String    // Name of the tool executed
  toolCallId        String    // VAPI tool call ID
  arguments         String?   @db.Text // JSON string of (redacted) arguments
  result            String?   @db.Text // JSON string of result
  success           Boolean   // Whether execution succeeded
  error             String?   // Error message if failed
  executionTimeMs   Int?      // Execution time in milliseconds

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([practiceId, toolName])
  @@index([vapiCallId])
}

model AppointmentType {
  id                          String @id @default(cuid())
  practiceId                  String
  practice                    Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthAppointmentTypeId  String // ID from NexHealth
  name                        String
  duration                    Int    // Duration in minutes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthAppointmentTypeId])
}

model Provider {
  id                  String @id @default(cuid())
  practiceId          String
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthProviderId String // ID from NexHealth
  firstName           String?
  lastName            String

  // Add new relationship
  savedByPractices    SavedProvider[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthProviderId])
}

model NexhealthTokenCache {
  id          String   @id @default("singleton") // Fixed ID for single token entry
  accessToken String   @db.Text // The bearer token can be long
  expiresAt   DateTime // Timestamp when the token expires
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

================
File: app/api/vapi/tool-calls/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getToolByName } from "@/lib/tools";
import { prisma } from "@/lib/prisma";
import { ToolExecutionContext, ToolDefinition } from "@/lib/tools/types";
import { getErrorCode, getPatientMessage } from "@/lib/tools/error-messages";

// Type for VAPI payload (flexible to handle various structures)
interface VapiPayload {
  message: {
    type: string;
    call: {
      id: string;
      assistantId?: string;
      assistant?: {
        id?: string;
        [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
      };
      [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    assistant?: {
      id?: string;
      [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    toolCallList?: any[]; // eslint-disable-line @typescript-eslint/no-explicit-any
    [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
  };
}

// Enhanced function to extract assistant ID with strict validation
function extractAssistantId(payload: VapiPayload): string {
  const { message } = payload;
  
  console.log("=== Assistant ID Extraction Debug ===");
  console.log("Call object keys:", Object.keys(message.call || {}));
  console.log("Assistant object keys:", Object.keys(message.assistant || {}));
  
  // Check if VAPI is sending assistant ID in different locations
  const assistantId = message.call?.assistantId || 
                     message.assistant?.id ||
                     message.call?.assistant?.id;
  
  if (!assistantId) {
    // For VAPI tool call payloads, assistant ID is often not included
    // This is normal behavior, not a critical error
    console.log("‚ÑπÔ∏è No assistant ID found in VAPI tool call payload (this is normal)");
    console.log("Payload structure:", JSON.stringify({
      call: Object.keys(message.call || {}),
      assistant: Object.keys(message.assistant || {}),
      assistantName: message.assistant?.name || message.call?.assistant?.name
    }, null, 2));
    
    // Use assistant name as fallback (standard for VAPI tool calls)
    const assistantName = message.assistant?.name || message.call?.assistant?.name;
    if (assistantName && assistantName.includes(" - Laine")) {
      console.log("‚úÖ Using assistant name for practice lookup:", assistantName);
      return assistantName; // This will be handled differently in practice lookup
    }
    
    throw new Error("Assistant identification is required for practice lookup");
  }
  
  console.log("‚úÖ Found assistant ID:", assistantId);
  return assistantId;
}

// Simplified practice lookup with strict validation - now handles assistant name fallback
async function findPracticeByAssistantId(assistantIdOrName: string) {
  console.log("=== Practice Lookup Debug ===");
  console.log("Assistant ID or Name:", assistantIdOrName);
  
  try {
    let practice = null;
    
    // First try to find by assistant ID (preferred method)
    const assistantConfig = await prisma.practiceAssistantConfig.findUnique({
      where: { vapiAssistantId: assistantIdOrName },
      include: { 
        practice: true
      }
    });
    
    if (assistantConfig) {
      practice = assistantConfig.practice;
      console.log("‚úÖ Found practice by assistant ID:", practice.id);
    }
    
    // If not found and looks like an assistant name, try to find by Royal Oak or subdomain
    if (!practice && (assistantIdOrName.includes("Laine") || assistantIdOrName.includes("Practice"))) {
      console.log("‚ö†Ô∏è Attempting practice lookup by assistant name:", assistantIdOrName);
      
      const config = await prisma.practiceAssistantConfig.findFirst({
        where: { 
          practice: {
            OR: [
              { name: { contains: "Royal Oak" } },
              { nexhealthSubdomain: "xyz" } // Fallback to known subdomain
            ]
          }
        },
        include: { practice: true }
      });
      
      if (config) {
        practice = config.practice;
        console.log(`‚úÖ Found practice by pattern matching:`, practice.id);
        console.log(`   Pattern used: Looking for Royal Oak or xyz subdomain`);
      }
      
      // If still not found but this looks like a Laine assistant, try fallback to first practice
      if (!practice && (assistantIdOrName.includes("Laine") || assistantIdOrName.includes("Practice"))) {
        console.log("‚ö†Ô∏è No exact match found, trying first available practice as fallback");
        const fallbackConfig = await prisma.practiceAssistantConfig.findFirst({
          include: { practice: true }
        });
        
        if (fallbackConfig) {
          practice = fallbackConfig.practice;
          console.log(`‚úÖ Using fallback practice:`, practice.id);
          console.log(`   Note: This should be temporary - assistant name should be fixed`);
        }
      }
    }
    
    if (!practice) {
      console.log("‚ùå No practice found for assistant ID/name:", assistantIdOrName);
      return null;
    }
    
    console.log("‚úÖ Successfully found practice:", practice.id);
    return await fetchPracticeWithSchedulingData(practice.id);
    
  } catch (error) {
    console.error("‚ùå Error in practice lookup:", error);
    return null;
  }
}

// Separate function to fetch practice with scheduling data
async function fetchPracticeWithSchedulingData(practiceId: string) {
  try {
    const practice = await prisma.practice.findUnique({ 
      where: { id: practiceId },
      include: {
        appointmentTypes: true,
        savedProviders: {
          where: { isActive: true },
          include: {
            provider: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                nexhealthProviderId: true
              }
            }
          }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });
    
    if (!practice) {
      console.error(`‚ùå Practice not found: ${practiceId}`);
      return null;
    }
    
    console.log("‚úÖ Loaded practice with scheduling data:", {
      id: practice.id,
      name: practice.name,
      appointmentTypes: practice.appointmentTypes.length,
      savedProviders: practice.savedProviders.length,
      savedOperatories: practice.savedOperatories.length
    });
    
    return practice;
  } catch (error) {
    console.error("‚ùå Error fetching practice with scheduling data:", error);
    return null;
  }
}

// Enhanced tool name extraction function
function extractToolName(toolCall: any): string | null { // eslint-disable-line @typescript-eslint/no-explicit-any
  // Log the tool call structure for debugging
  console.log("=== Tool Call Structure Debug ===");
  console.log("Tool call keys:", Object.keys(toolCall));
  console.log("Tool call object:", JSON.stringify(toolCall, null, 2));
  
  // Method 1: Check function.name (most common)
  if (toolCall.function && typeof toolCall.function === 'object' && toolCall.function.name) {
    console.log("‚úÖ Found tool name in function.name:", toolCall.function.name);
    return toolCall.function.name;
  }
  
  // Method 2: Check direct name property
  if (toolCall.name && typeof toolCall.name === 'string') {
    console.log("‚úÖ Found tool name in name:", toolCall.name);
    return toolCall.name;
  }
  
  // Method 3: Check if function is a string (edge case)
  if (typeof toolCall.function === 'string') {
    console.log("‚úÖ Found tool name as string in function:", toolCall.function);
    return toolCall.function;
  }
  
  console.error("‚ùå Unable to extract tool name from tool call");
  console.error("Available fields:", {
    hasFunction: !!toolCall.function,
    functionType: typeof toolCall.function,
    functionKeys: toolCall.function ? Object.keys(toolCall.function) : null,
    hasName: !!toolCall.name,
    nameType: typeof toolCall.name
  });
  
  return null;
}

// Enhanced tool call ID extraction function
function extractToolCallId(toolCall: any): string { // eslint-disable-line @typescript-eslint/no-explicit-any
  // Method 1: Check id property
  if (toolCall.id && typeof toolCall.id === 'string') {
    console.log("‚úÖ Found tool call ID in id:", toolCall.id);
    return toolCall.id;
  }
  
  // Method 2: Check toolCallId property
  if (toolCall.toolCallId && typeof toolCall.toolCallId === 'string') {
    console.log("‚úÖ Found tool call ID in toolCallId:", toolCall.toolCallId);
    return toolCall.toolCallId;
  }
  
  // Method 3: Generate fallback ID
  const fallbackId = `fallback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  console.warn("‚ö†Ô∏è No tool call ID found, using fallback:", fallbackId);
  
  return fallbackId;
}

// Enhanced tool call argument extraction
function extractToolCallArguments(toolCall: any): Record<string, unknown> { // eslint-disable-line @typescript-eslint/no-explicit-any
  console.log("=== Tool Call Arguments Extraction ===");
  console.log("Tool call structure:", Object.keys(toolCall));
  
  // Handle multiple possible argument formats from VAPI
  if (typeof toolCall.arguments === 'string') {
    try {
      const parsed = JSON.parse(toolCall.arguments);
      console.log("‚úÖ Parsed arguments from string:", parsed);
      return parsed;
    } catch (error) {
      console.error("‚ùå Failed to parse tool call arguments as JSON string:", error);
      return {};
    }
  }
  
  if (typeof toolCall.arguments === 'object' && toolCall.arguments !== null) {
    console.log("‚úÖ Using arguments object directly:", toolCall.arguments);
    return toolCall.arguments;
  }
  
  // Check if arguments are in toolCall.function.arguments
  if (toolCall.function?.arguments) {
    if (typeof toolCall.function.arguments === 'string') {
      try {
        const parsed = JSON.parse(toolCall.function.arguments);
        console.log("‚úÖ Parsed function arguments from string:", parsed);
        return parsed;
      } catch (error) {
        console.error("‚ùå Failed to parse function arguments as JSON string:", error);
        return {};
      }
    }
    
    if (typeof toolCall.function.arguments === 'object') {
      console.log("‚úÖ Using function arguments object:", toolCall.function.arguments);
      return toolCall.function.arguments;
    }
  }
  
  console.error("‚ùå Unable to extract arguments from tool call:", toolCall);
  return {};
}

async function executeToolSafely(
  // Use more flexible typing to avoid constraint issues
  tool: ToolDefinition<any>, // eslint-disable-line @typescript-eslint/no-explicit-any
  toolCall: any, // eslint-disable-line @typescript-eslint/no-explicit-any 
  context: ToolExecutionContext
) {
  try {
    const parsedArgs = extractToolCallArguments(toolCall);
    const startTime = Date.now();
    
    console.log(`Executing tool: ${tool.name} for practice ${context.practice.id} with args:`, parsedArgs);
    
    // Validate arguments with tool schema
    const validatedArgs = tool.schema.parse(parsedArgs);
    
    const toolResult = await tool.run({
      args: validatedArgs,
      context
    });
    
    const executionTime = Date.now() - startTime;
    
    // Log successful execution
    await logToolExecution(
      context,
      tool.name,
      validatedArgs,
      toolResult,
      true,
      undefined,
      executionTime
    );
    
    return toolResult;
  } catch (error) {
    console.error(`Error executing tool ${tool.name}:`, error);
    
    const errorResult = {
      success: false,
      error_code: getErrorCode(error),
      message_to_patient: getPatientMessage(getErrorCode(error)),
      details: error instanceof Error ? error.message : "Unknown error"
    };
    
    // Log failed execution
    await logToolExecution(
      context,
      tool.name,
      toolCall.arguments || toolCall.function?.arguments || {},
      errorResult,
      false,
      error instanceof Error ? error.message : "Unknown error"
    );
    
    return errorResult;
  }
}

async function logToolExecution(
  context: ToolExecutionContext,
  toolName: string,
  arguments_: unknown,
  result: unknown,
  success: boolean,
  error?: string,
  executionTimeMs?: number
) {
  try {
    await prisma.toolLog.create({
      data: {
        practiceId: context.practice.id,
        vapiCallId: context.vapiCallId,
        toolName,
        toolCallId: context.toolCallId,
        arguments: JSON.stringify(arguments_),
        result: JSON.stringify(result),
        success,
        error,
        executionTimeMs: executionTimeMs || 0
      }
    });
  } catch (logError) {
    console.error("Error logging tool execution:", logError);
  }
}

export async function POST(req: NextRequest) {
  console.log("=== VAPI Centralized Tool Handler ===");
  
  try {
    // TODO: Implement request verification when VAPI provides signing
    
    const payload: VapiPayload = await req.json();
    console.log("VAPI payload:", JSON.stringify(payload, null, 2));
    
    // Validate payload structure
    if (!payload.message || payload.message.type !== "tool-calls") {
      console.error("Invalid payload type:", payload.message?.type);
      return NextResponse.json({ error: "Invalid payload type" }, { status: 400 });
    }
    
    const { message } = payload;
    const vapiCallId = message.call.id;
    
    let assistantId: string;
    let practice: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    
    try {
      assistantId = extractAssistantId(payload);
      practice = await findPracticeByAssistantId(assistantId);
      
      if (!practice) {
        throw new Error(`No practice found for assistant ID/name: ${assistantId}`);
      }
    } catch (error) {
      console.error("Assistant ID extraction or practice lookup failed:", error);
      
      // Create detailed error for debugging
      const debugInfo = {
        error: error instanceof Error ? error.message : "Unknown error",
        callId: vapiCallId,
        assistantName: (message.assistant as any)?.name, // eslint-disable-line @typescript-eslint/no-explicit-any
        availableFields: {
          call: Object.keys(message.call || {}),
          assistant: Object.keys(message.assistant || {})
        }
      };
      
      console.error("Debug info:", JSON.stringify(debugInfo, null, 2));
      
      // Return error results for all tool calls
      const toolCalls = message.toolCallList || message.toolCalls || [];
      const errorResults = toolCalls.map((toolCall: any) => ({ // eslint-disable-line @typescript-eslint/no-explicit-any
        toolCallId: extractToolCallId(toolCall),
        result: JSON.stringify({
          success: false,
          error_code: "ASSISTANT_ID_OR_PRACTICE_ERROR", 
          message_to_patient: "I'm having trouble connecting to your practice's system. Please try again or contact the office directly.",
          debug_info: debugInfo
        })
      }));
      
      return NextResponse.json({ results: errorResults });
    }
    
    // Update call log status
    try {
      await prisma.callLog.upsert({
        where: { vapiCallId },
        create: {
          vapiCallId,
          practiceId: practice.id,
          callStatus: "TOOL_IN_PROGRESS",
          callTimestampStart: new Date()
        },
        update: {
          callStatus: "TOOL_IN_PROGRESS",
          updatedAt: new Date()
        }
      });
    } catch (dbError) {
      console.error("Error updating CallLog:", dbError);
    }
    
    // Process all tool calls
    const results = [];
    
    console.log(`Processing ${(message.toolCallList || []).length} tool call(s)`);
    
    for (let i = 0; i < (message.toolCallList || []).length; i++) {
      const toolCall = (message.toolCallList || [])[i];
      
      console.log(`=== Processing Tool Call ${i + 1}/${(message.toolCallList || []).length} ===`);
     
      // Enhanced tool name extraction
      const toolName = extractToolName(toolCall);
      const toolCallId = extractToolCallId(toolCall);
      
      console.log(`Tool: ${toolName}, ID: ${toolCallId}`);
     
      if (!toolName) {
        console.error(`‚ùå Unable to extract tool name from tool call ${i + 1}`);
        results.push({
          toolCallId,
          result: JSON.stringify({
            success: false,
            error_code: "INVALID_TOOL_CALL",
            message_to_patient: getPatientMessage("VALIDATION_ERROR"),
            debug_info: {
              toolCallIndex: i,
              availableFields: Object.keys(toolCall),
              toolCallStructure: toolCall
            }
          })
        });
        continue;
      }
      
      const tool = getToolByName(toolName);
      
      if (!tool) {
        console.error(`‚ùå Unknown tool: ${toolName}`);
        results.push({
          toolCallId,
          result: JSON.stringify({
            success: false,
            error_code: "SYSTEM_ERROR",
            message_to_patient: getPatientMessage("SYSTEM_ERROR"),
            debug_info: {
              requestedTool: toolName,
              toolCallIndex: i
            }
          })
        });
        continue;
      }
      
      console.log(`‚úÖ Found tool: ${tool.name}`);
      
      // Create execution context
      const context: ToolExecutionContext = {
        practice,
        vapiCallId,
        toolCallId,
        assistantId: assistantId || "unknown"
      };
      
      const toolResult = await executeToolSafely(tool, toolCall, context);
      
      results.push({
        toolCallId,
        result: JSON.stringify(toolResult)
      });
      
      console.log(`‚úÖ Tool ${toolName} completed. Success: ${toolResult.success}`);
    }
    
    console.log("Sending results to VAPI:", JSON.stringify({ results }));
    return NextResponse.json({ results });
     
  } catch (error) {
    console.error("Error in centralized tool handler:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: lib/tools/checkAvailableSlots.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Generate current date dynamically for LLM context
function getCurrentDate(): string {
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2, '0'); // Months are 0-based
  const dd = String(today.getDate()).padStart(2, '0');
  return `${yyyy}-${mm}-${dd}`;
}

// Get current day name for better LLM context
function getCurrentDayInfo(): string {
  const today = new Date();
  const dayName = today.toLocaleDateString('en-US', { weekday: 'long' });
  const monthName = today.toLocaleDateString('en-US', { month: 'long' });
  return `Today is ${dayName}, ${monthName} ${today.getDate()}, ${today.getFullYear()}`;
}

export const checkAvailableSlotsSchema = z.object({
  requestedDate: z.string()
    .min(1)
    .refine((date) => {
      // Simple validation to ensure YYYY-MM-DD format
      const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
      if (!dateRegex.test(date)) {
        return false;
      }
      // Validate it's a real date
      const parsedDate = new Date(date);
      return !isNaN(parsedDate.getTime()) && date === parsedDate.toISOString().split('T')[0];
    }, "Date must be in YYYY-MM-DD format and be a valid date")
    .describe(`
Convert the patient's natural language date request to YYYY-MM-DD format.

CURRENT DATE CONTEXT:
- ${getCurrentDayInfo()}
- Current date: ${getCurrentDate()}

EXAMPLES OF CONVERSIONS:
- "December twenty third" ‚Üí "2025-12-23"
- "December 23rd" ‚Üí "2025-12-23" 
- "next Friday" ‚Üí calculate the next Friday from ${getCurrentDate()}
- "tomorrow" ‚Üí calculate tomorrow from ${getCurrentDate()}
- "Monday" ‚Üí calculate the next Monday from ${getCurrentDate()}
- "next week" ‚Üí calculate a date next week from ${getCurrentDate()}
- "Christmas" ‚Üí "2025-12-25" (if current year) or "2025-12-25" (if Christmas has passed)

IMPORTANT INSTRUCTIONS:
1. Always return dates in YYYY-MM-DD format
2. If year is not specified, assume the next occurrence of that date
3. If the specified date has already passed this year, use next year
4. For relative dates like "tomorrow", "next Friday", calculate from current date: ${getCurrentDate()}
5. If the date is ambiguous or unclear, ask the patient for clarification

Current date for calculations: ${getCurrentDate()}
    `),
  appointmentTypeId: z.string().min(1).describe("The appointment type ID from the previous tool call"),
  days: z.number().min(1).max(7).default(1).describe("Number of days to check (default 1)")
});

const checkAvailableSlotsTool: ToolDefinition<typeof checkAvailableSlotsSchema> = {
  name: "check_available_slots",
  description: "Checks available appointment slots for a specific date and appointment type. Use this after confirming patient identity and appointment type to show available times.",
  schema: checkAvailableSlotsSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't check availability right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "The practice hasn't configured any providers for online scheduling. Please contact the office directly."
      };
    }

    try {
      // Get provider and operatory IDs from practice preferences
      const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
      const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

      if (activeProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "No providers are currently available for online scheduling. Please contact the office."
        };
      }

      console.log(`[checkAvailableSlots] Checking ${args.requestedDate} for appointment type ${args.appointmentTypeId}`);

      // Get provider and operatory arrays
      const providers = activeProviders.map(sp => sp.provider.nexhealthProviderId);
      const operatories = activeOperatories.map(so => so.nexhealthOperatoryId);

      // Build search params object for NexHealth API
      const searchParams: Record<string, string | string[]> = {
        subdomain: practice.nexhealthSubdomain,
        start_date: args.requestedDate,
        days: args.days.toString(),
        appointment_type_id: args.appointmentTypeId,
        'lids[]': [practice.nexhealthLocationId],
        'pids[]': providers
      };

      // Add operatory IDs if configured
      if (operatories.length > 0) {
        searchParams['operatory_ids[]'] = operatories;
      }

      const slotsResponse = await fetchNexhealthAPI(
        '/appointment_slots',
        practice.nexhealthSubdomain,
        searchParams
      );

      console.log(`[checkAvailableSlots] API response:`, JSON.stringify(slotsResponse, null, 2));

      // Parse response
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const availableSlots: any[] = [];
      
      if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
        // Extract all slots from all providers
        for (const providerData of slotsResponse.data) {
          if (providerData.slots && Array.isArray(providerData.slots)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            availableSlots.push(...providerData.slots.map((slot: any) => ({
              ...slot,
              provider_id: providerData.pid,
              location_id: providerData.lid
            })));
          }
        }
      }

      if (availableSlots.length === 0) {
        // No slots found - let's provide more helpful information
        console.log(`[checkAvailableSlots] No slots found for appointment type ${args.appointmentTypeId} on ${args.requestedDate}`);
        
        // Check if this is a systemic issue or specific to this appointment type
        // by testing with a different appointment type that's known to have availability
        let suggestionMessage = `I don't see any available slots for ${formatDate(args.requestedDate)}.`;
        
        // Try to find alternative appointment types that might have availability
        const allAppointmentTypes = practice.appointmentTypes || [];
        if (allAppointmentTypes.length > 1) {
          const currentType = allAppointmentTypes.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId);
          const otherTypes = allAppointmentTypes.filter(at => at.nexhealthAppointmentTypeId !== args.appointmentTypeId);
          
          if (currentType && otherTypes.length > 0) {
            console.log(`[checkAvailableSlots] Current appointment type: ${currentType.name} (${args.appointmentTypeId})`);
            console.log(`[checkAvailableSlots] Other available types:`, otherTypes.map(t => `${t.name} (${t.nexhealthAppointmentTypeId})`));
            suggestionMessage += ` Would you like me to check availability for a different type of appointment, or would you prefer to call the office?`;
          }
        }
        
        // Also suggest checking different dates
        suggestionMessage += ` You can also ask me to check a different date.`;

        return {
          success: true,
          message_to_patient: suggestionMessage,
          data: {
            requested_date: args.requestedDate,
            requested_appointment_type_id: args.appointmentTypeId,
            available_slots: [],
            has_availability: false,
            debug_info: {
              providers_checked: providers.length,
              operatories_checked: operatories.length,
              appointment_type_name: allAppointmentTypes.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || 'Unknown'
            }
          }
        };
      }

      // Format slots for patient-friendly display
      const formattedSlots = availableSlots.slice(0, 8).map((slot, index) => {
        // Parse the time string correctly to preserve the timezone
        const startTime = new Date(slot.time);
        
        // Use the timezone from the original date string for formatting
        const timeString = startTime.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
          timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
        });
        
        return {
          slot_id: `slot_${index}`,
          time: slot.time,
          end_time: slot.end_time,
          display_time: timeString,
          operatory_id: slot.operatory_id,
          provider_id: slot.provider_id,
          location_id: slot.location_id
        };
      });

      const timeOptions = formattedSlots.map(slot => slot.display_time).join(', ');

      return {
        success: true,
        message_to_patient: `Great! I have these times available for ${formatDate(args.requestedDate)}: ${timeOptions}. Which time would you prefer?`,
        data: {
          requested_date: args.requestedDate,
          available_slots: formattedSlots,
          has_availability: true,
          total_slots_found: availableSlots.length
        }
      };

    } catch (error) {
      console.error(`[checkAvailableSlots] Error:`, error);
      
      let message = "I'm having trouble checking availability right now. Please try again or call the office.";
      if (error instanceof Error && error.message.includes("401")) {
        message = "There's an authentication issue with the scheduling system. Please contact support.";
      }
      
      return {
        success: false,
        error_code: "AVAILABILITY_CHECK_ERROR",
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check our availability for you...",
    success: "I found some great options for you!",
    fail: "I'm having trouble checking our schedule right now."
  }
};

function formatDate(dateString: string): string {
  try {
    const date = new Date(dateString + 'T00:00:00');
    return date.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  } catch {
    return dateString;
  }
}

export default checkAvailableSlotsTool;




================================================================
End of Codebase
================================================================
