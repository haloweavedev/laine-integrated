This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app/api/vapi-webhook/route.ts, lib/ai, lib/system-prompt/laine_system_prompt.md, lib/tool-handlers, lib/tools
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    vapi-webhook/
      route.ts
lib/
  ai/
    acknowledgmentGenerator.ts
    appointmentMatcher.ts
    insuranceResponseGenerator.ts
    slotHelper.ts
    slotMatcher.ts
    summaryHelper.ts
  system-prompt/
    laine_system_prompt.md
  tool-handlers/
    checkAvailableSlotsHandler.ts
    findAppointmentTypeHandler.ts
    identifyPatientHandler.ts
    insuranceInfoHandler.ts
    selectAndConfirmSlotHandler.ts
  tools/
    definitions/
      checkAvailableSlotsTool.ts
      findAppointmentTypeTool.ts
      identifyPatientTool.ts
      insuranceInfoTool.ts
      selectAndConfirmSlotTool.ts
    index.ts

================================================================
Files
================================================================

================
File: lib/tool-handlers/identifyPatientHandler.ts
================
import { prisma } from "@/lib/prisma";
import { fetchNexhealthAPI, createPatient } from "@/lib/nexhealth";
import type { HandlerResult, ApiLog } from "@/types/vapi";
import type { ConversationState } from "@/types/laine";
import { mergeState } from '@/lib/utils/state-helpers';

interface IdentifyPatientArgs {
  firstName: string;
  lastName: string;
  dateOfBirth: string;
  phoneNumber: string;
  email: string;
}

interface NexHealthPatient {
  id: number;
  first_name: string;
  last_name: string;
  bio?: {
    date_of_birth?: string;
  };
}

interface NexHealthApiData {
  patients: NexHealthPatient[];
}

interface NexHealthApiResponse {
  data?: NexHealthApiData;
}

interface NexHealthPatientResponse {
  data?: {
    user?: {
      id?: number;
    };
  };
  user?: {
    id?: number;
  };
}

/**
 * Handles the identifyPatient tool call
 * Intelligently searches for existing patients first, then creates new records if needed
 * This consolidates the logic from both findAndConfirmPatient and createPatientRecord
 */
export async function handleIdentifyPatient(
  currentState: ConversationState,
  args: IdentifyPatientArgs,
  toolCallId: string
): Promise<HandlerResult> {
  const apiLog: ApiLog = [];
  
  console.log(`[IdentifyPatientHandler] Processing identification for: "${args.firstName} ${args.lastName}", DOB: "${args.dateOfBirth}"`);

  try {
    if (!currentState.practiceId) {
      return {
        toolResponse: {
          toolCallId,
          error: "Practice configuration not found."
        },
        newState: currentState
      };
    }

    // Get practice details from database
    const practice = await prisma.practice.findUnique({
      where: { id: currentState.practiceId },
      select: {
        nexhealthSubdomain: true,
        nexhealthLocationId: true
      }
    });

    if (!practice?.nexhealthSubdomain || !practice?.nexhealthLocationId) {
      console.error('[IdentifyPatientHandler] Practice missing NexHealth configuration');
      return {
        toolResponse: {
          toolCallId,
          error: "Practice NexHealth configuration incomplete."
        },
        newState: currentState
      };
    }

    console.log(`[IdentifyPatientHandler] Using practice: ${practice.nexhealthSubdomain}`);

    // Step 1: Search for existing patient by name
    const fullName = `${args.firstName} ${args.lastName}`;
    const { data: apiResponse, apiLog: searchApiLog } = await fetchNexhealthAPI(
      '/patients',
      practice.nexhealthSubdomain,
      { 
        location_id: practice.nexhealthLocationId,
        name: fullName
      },
      'GET',
      undefined,
      apiLog
    );

    const response = apiResponse as NexHealthApiResponse;
    const patients = response.data?.patients;

    console.log(`[IdentifyPatientHandler] API search returned ${patients?.length ?? 0} patient(s) with the name "${fullName}".`);

    // Step 2: If patients found, try to match by DOB
    if (Array.isArray(patients) && patients.length > 0) {
      console.log(`[IdentifyPatientHandler] Found ${patients.length} patient(s) with matching name, checking DOB`);

      // Debug logging before DOB comparison
      console.log(`[IdentifyPatientHandler] Searching for DOB: "${args.dateOfBirth}"`);
      patients.forEach((patient, index) => {
        console.log(`[IdentifyPatientHandler] Record ${index} DOB: "${patient.bio?.date_of_birth}"`);
      });

      // Find patient with matching date of birth
      const matchedPatient = patients.find(patient => {
        const recordDob = patient.bio?.date_of_birth;
        return typeof recordDob === 'string' && recordDob.trim() === args.dateOfBirth.trim();
      });

      if (matchedPatient) {
        // Step 3A: Existing patient found and confirmed
        console.log(`[IdentifyPatientHandler] Found existing patient with ID: ${matchedPatient.id}`);

        const newState = mergeState(currentState, {
          patient: {
            id: matchedPatient.id,
            status: 'IDENTIFIED_EXISTING',
            firstName: matchedPatient.first_name,
            lastName: matchedPatient.last_name,
            dob: args.dateOfBirth,
            phone: args.phoneNumber,
            email: args.email,
            isNameConfirmed: true
          }
        });

        return {
          toolResponse: {
            toolCallId,
            result: { 
              success: true, 
              nexhealthPatientId: matchedPatient.id,
              patientName: `${matchedPatient.first_name} ${matchedPatient.last_name}`,
              apiLog: searchApiLog
            },
            message: {
              type: "request-complete",
              role: "assistant",
              content: `Great, I've found and confirmed your record, ${args.firstName}. Now, let's get you scheduled.`
            }
          },
          newState
        };
      } else {
        console.log(`[IdentifyPatientHandler] Found patients with name but no DOB match - proceeding to create new record`);
      }
    }

    // Step 3B: No existing patient found, create new record
    console.log(`[IdentifyPatientHandler] No existing patient found. Creating new record.`);

    // Use hardcoded values for now (these should come from practice configuration)
    const { data: createResponse, apiLog: createApiLog } = await createPatient(
      {
        firstName: args.firstName,
        lastName: args.lastName,
        dateOfBirth: args.dateOfBirth,
        phoneNumber: args.phoneNumber,
        email: args.email
      },
      practice.nexhealthSubdomain,
      parseInt(practice.nexhealthLocationId),
      377851148, // hardcoded providerId - should be configurable
      searchApiLog
    );

    // Extract the patient ID from the response
    const nexHealthResponse = createResponse as NexHealthPatientResponse;
    const newPatientId = nexHealthResponse.data?.user?.id || nexHealthResponse.user?.id;

    if (!newPatientId) {
      console.error('[IdentifyPatientHandler] Patient ID missing from NexHealth create response:', createResponse);
      throw new Error("Patient ID missing from NexHealth response.");
    }

    console.log(`[IdentifyPatientHandler] Successfully created new patient with ID: ${newPatientId}`);

    const newState = mergeState(currentState, {
      patient: {
        id: newPatientId,
        status: 'NEW_DETAILS_COLLECTED',
        firstName: args.firstName,
        lastName: args.lastName,
        dob: args.dateOfBirth,
        phone: args.phoneNumber,
        email: args.email,
        isNameConfirmed: true
      }
    });

    return {
      toolResponse: {
        toolCallId,
        result: { 
          success: true, 
          nexhealthPatientId: newPatientId,
          apiLog: createApiLog
        },
        message: {
          type: "request-complete",
          role: "assistant",
          content: `Thank you! I've successfully created a record for you, ${args.firstName}. Now, let's find an appointment time.`
        }
      },
      newState
    };

  } catch (error) {
    console.error('[IdentifyPatientHandler] Error during patient identification:', error);
    return {
      toolResponse: {
        toolCallId,
        result: { success: false, apiLog },
        message: {
          type: "request-failed",
          role: "assistant", 
          content: "I'm sorry, I ran into a technical problem while processing your information. Let me have our staff call you back to help with your appointment."
        }
      },
      newState: currentState
    };
  }
}

================
File: lib/tools/definitions/identifyPatientTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for identifyPatient
 * This intelligent tool handles both existing patient lookup and new patient creation
 */
export function getIdentifyPatientTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "identifyPatient",
      description: "Identifies an existing patient or creates a new patient record. Use this after collecting the patient's full name, date of birth, and other contact details.",
      parameters: {
        type: "object" as const,
        properties: {
          firstName: { 
            type: "string" as const, 
            description: "The patient's first name." 
          },
          lastName: { 
            type: "string" as const, 
            description: "The patient's last name." 
          },
          dateOfBirth: { 
            type: "string" as const, 
            description: "The patient's date of birth in YYYY-MM-DD format." 
          },
          phoneNumber: { 
            type: "string" as const, 
            description: "The patient's phone number (required for new patients)." 
          },
          email: { 
            type: "string" as const, 
            description: "The patient's email address (required for new patients)." 
          },
        },
        required: ["firstName", "lastName", "dateOfBirth", "phoneNumber", "email"],
      },
    },
    server: { 
      url: `${appBaseUrl}/api/vapi-webhook`,
      timeoutSeconds: 30
    }
  };
}

================
File: lib/tools/definitions/insuranceInfoTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for insuranceInfo
 * This tool answers patient questions about dental insurance acceptance
 */
export function getInsuranceInfoTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "insuranceInfo",
      description: "Answers patient questions about dental insurance acceptance. Use for general questions like 'What insurance do you take?' or specific questions like 'Do you accept Cigna?'",
      parameters: {
        type: "object" as const,
        properties: {
          insuranceName: {
            type: "string" as const,
            description: "The specific name of the insurance plan the user is asking about. Omit this for general questions."
          }
        },
        required: []
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: lib/ai/acknowledgmentGenerator.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";

/**
 * Generates a short, context-aware acknowledgment phrase based on the user's request.
 * Produces empathetic responses for painful/negative requests, encouraging responses 
 * for positive/cosmetic requests, and simple professional acknowledgments for routine requests.
 * @param patientRequest The patient's stated reason for calling or request
 * @returns A promise that resolves to a contextually appropriate acknowledgment string
 */
export async function generateAcknowledgment(patientRequest: string): Promise<string> {
  try {
    const systemPrompt = `You are an expert AI copywriter specializing in creating short, natural-sounding conversational acknowledgments for a dental receptionist. Your response MUST be a single, short phrase and nothing else. Do not add any extra text or pleasantries.

**CRITICAL RULES:**
- **NO FILLER WORDS:** Do not use unnecessary filler words like "Okay" or "Alright" unless they are part of a natural phrase.
- **NO PROCESS NARRATION:** Do not say "Let me check" or "I'll look that up" - just deliver the acknowledgment.

- If the user's request sounds painful or negative (e.g., "broken tooth," "toothache," "crown fell off"), generate an empathetic response.
  - Example for "My crown fell off": "Oh no, that's no fun. Let's get that sorted for you."
- If the user's request is for a cosmetic or positive procedure (e.g., "veneers," "whitening," "Invisalign"), generate an encouraging and positive response.
  - Example for "I want to get my teeth whitened": "That's exciting! A brighter smile is a great goal."
- If the user's request is neutral or routine (e.g., "I need a cleaning," "check-up"), generate a simple, pleasant acknowledgment.
  - Example for "I'd like to schedule a cleaning": "Of course, we can definitely get that scheduled for you."`;

    const messages: CoreMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: patientRequest }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.2,
      maxTokens: 50,
    });

    return text.trim();

  } catch (error) {
    console.error(`[AcknowledgmentGenerator] Error generating acknowledgment for request: "${patientRequest}"`, error);
    return '';
  }
}

================
File: lib/ai/insuranceResponseGenerator.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";

/**
 * Generates a natural, helpful, and context-aware response based on insurance query results.
 * Handles three scenarios: general inquiry, specific inquiry with match, and specific inquiry without match.
 * @param isMatch Whether the specific insurance plan was found in accepted insurances
 * @param queriedInsurance The specific insurance plan the user asked about (null for general inquiries)
 * @param acceptedInsurances Array of insurance plans that the practice accepts
 * @returns A promise that resolves to a natural response string
 */
export async function generateInsuranceResponse(
  isMatch: boolean, 
  queriedInsurance: string | null, 
  acceptedInsurances: string[]
): Promise<string> {
  try {
    const systemPrompt = `You are an AI assistant crafting a response for a dental receptionist. Your tone should be helpful and clear. Based on the scenario, generate a single, fluid response.

**Scenario A: General Inquiry**
The user asked what insurances you accept.
Your task: List the following accepted plans in a natural sentence.
Accepted Plans: {{acceptedInsurances}}
Example: "We accept several major plans, including Cigna, Delta Dental, and MetLife."

**Scenario B: Specific Inquiry - Match Found**
The user asked if you accept a specific insurance, and you do.
Your task: Confirm that you accept their plan.
User's Plan: {{queriedInsurance}}
Example: "Yes, we do accept Cigna! We're in-network with them."

**Scenario C: Specific Inquiry - No Match**
The user asked if you accept a specific insurance, and you do not.
Your task: Deliver a reassuring, empathetic response that doesn't alienate the patient or list other plans.
User's Plan: {{queriedInsurance}}
Example: "It looks like we may be out-of-network with that plan, but we'd still love to take care of you."`;

    let userMessage: string;
    
    if (queriedInsurance === null) {
      // Scenario A: General Inquiry
      userMessage = `The user asked what insurances you accept. List these accepted plans naturally: ${acceptedInsurances.join(', ')}`;
    } else if (isMatch) {
      // Scenario B: Specific Inquiry - Match Found
      userMessage = `The user asked if you accept ${queriedInsurance}. Confirm that you do accept this plan.`;
    } else {
      // Scenario C: Specific Inquiry - No Match
      userMessage = `The user asked if you accept ${queriedInsurance}. You do NOT accept this plan. Deliver a reassuring, empathetic response that doesn't alienate them or list other plans.`;
    }

    const messages: CoreMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userMessage }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.2,
      maxTokens: 150,
    });

    return text.trim();

  } catch (error) {
    console.error(`[InsuranceResponseGenerator] Error generating response for queriedInsurance: "${queriedInsurance}", isMatch: ${isMatch}`, error);
    
    // Safe fallback response
    if (queriedInsurance === null) {
      return acceptedInsurances.length > 0 
        ? `We accept ${acceptedInsurances.join(', ')}.`
        : "I'm sorry, I don't have the list of accepted insurances available right now, but our office staff can certainly help with that.";
    } else if (isMatch) {
      return `Yes, we do accept ${queriedInsurance}!`;
    } else {
      return `It looks like we may be out-of-network with ${queriedInsurance}, but we'd still love to take care of you.`;
    }
  }
}

================
File: lib/tool-handlers/insuranceInfoHandler.ts
================
import { prisma } from '@/lib/prisma';
import { generateInsuranceResponse } from '@/lib/ai/insuranceResponseGenerator';
import type { HandlerResult } from '@/types/vapi';
import type { ConversationState } from '@/types/laine';

interface InsuranceInfoArgs {
  insuranceName?: string;
}

/**
 * Handles the insuranceInfo tool call
 * Fetches practice insurance data and generates appropriate responses for general or specific insurance queries
 * @param currentState Current conversation state
 * @param args Tool arguments containing optional insuranceName
 * @param toolCallId ID of the tool call for response tracking
 * @returns HandlerResult with generated insurance response
 */
export async function handleInsuranceInfo(
  currentState: ConversationState,
  args: InsuranceInfoArgs,
  toolCallId: string
): Promise<HandlerResult> {
  console.log(`[InsuranceInfoHandler] Processing query for insurance: "${args.insuranceName || 'general inquiry'}"`);

  try {
    if (!currentState.practiceId) {
      return {
        toolResponse: {
          toolCallId,
          error: "Practice configuration not found."
        },
        newState: currentState
      };
    }

    // Fetch practice insurance information
    const practice = await prisma.practice.findUnique({
      where: { id: currentState.practiceId },
      select: {
        acceptedInsurances: true
      }
    });

    if (!practice) {
      return {
        toolResponse: {
          toolCallId,
          error: "Practice not found."
        },
        newState: currentState
      };
    }

    // Handle case where no insurance data is available
    if (!practice.acceptedInsurances || practice.acceptedInsurances.trim() === '') {
      return {
        toolResponse: {
          toolCallId,
          result: { success: true },
          message: {
            type: "request-complete",
            role: "assistant",
            content: "I'm sorry, I don't have the list of accepted insurances available right now, but our office staff can certainly help with that."
          }
        },
        newState: currentState
      };
    }

    // Parse the comma-separated string into an array of trimmed strings
    const insurancesArray = practice.acceptedInsurances
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);

    let isMatch = false;
    let queriedInsurance: string | null = null;

    // Check if a specific insurance was queried
    if (args.insuranceName) {
      queriedInsurance = args.insuranceName;
      // Perform case-insensitive search
      isMatch = insurancesArray.some(insurance => 
        insurance.toLowerCase() === args.insuranceName!.toLowerCase()
      );
    }

    // Generate AI-powered response
    const aiResponse = await generateInsuranceResponse(isMatch, queriedInsurance, insurancesArray);

    console.log(`[InsuranceInfoHandler] Generated response for insurance query`);

    return {
      toolResponse: {
        toolCallId,
        result: { success: true },
        message: {
          type: "request-complete",
          role: "assistant",
          content: aiResponse
        }
      },
      newState: currentState
    };

  } catch (error) {
    console.error('[InsuranceInfoHandler] Error processing insurance query:', error);
    return {
      toolResponse: {
        toolCallId,
        error: "I'm sorry, I'm having trouble accessing our insurance information right now. Please contact our office directly for assistance with insurance questions."
      },
      newState: currentState
    };
  }
}

================
File: lib/tools/definitions/findAppointmentTypeTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for findAppointmentType
 * This tool identifies the most suitable dental appointment type based on patient needs
 */
export function getFindAppointmentTypeTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "findAppointmentType",
      description: "Identifies the patient's need (e.g., 'toothache', 'cleaning') and determines the correct appointment type. **This is always the first tool to call in a conversation.**",
      parameters: {
        type: "object" as const,
        properties: {
          patientRequest: {
            type: "string" as const,
            description: "The patient's verbatim description of their reason for calling, their symptoms, or the type of appointment they are requesting. For example, 'I have a toothache', 'I need a cleaning', or 'My crown fell off and I need it re-cemented'."
          }
        },
        required: ["patientRequest"]
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: lib/tools/definitions/selectAndConfirmSlotTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for selectAndBookSlot
 * This tool selects a time slot and, with final user confirmation, books the appointment. This is the final step in the booking process.
 */
export function getSelectAndBookSlotTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "selectAndBookSlot",
      description: "Selects a time slot and, with final user confirmation, books the appointment. This is the final step in the booking process. Call once with user's selection, then again with finalConfirmation=true after they confirm.",
      parameters: {
        type: "object" as const,
        properties: {
          userSelection: {
            type: "string" as const,
            description: "The user's verbal selection of a time slot (e.g., '10 AM', 'the first one', '8:30')"
          },
          finalConfirmation: {
            type: "boolean" as const,
            description: "Set to true only after the user has verbally confirmed the exact time and date."
          }
        },
        required: ["userSelection"]
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: lib/ai/slotMatcher.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";
import type { SlotData } from "@/types/vapi";
import { DateTime } from "luxon";

export async function matchUserSelectionToSlot(
  userSelection: string,
  presentedSlots: SlotData[],
  practiceTimezone: string
): Promise<SlotData | null> {
  try {
    if (!presentedSlots || presentedSlots.length === 0) {
      console.error("[SlotMatcher] No presented slots provided to match against.");
      return null;
    }

    // Create a simplified, numbered list of slots for the AI to parse.
    const formattedSlotsForAI = presentedSlots.map((slot, index) => {
      const time = DateTime.fromISO(slot.time, { zone: practiceTimezone }).toFormat("cccc 'at' h:mm a");
      return `${index + 1}. ${time}`;
    }).join("\n");

    const systemPrompt = `You are a highly accurate AI assistant. Your task is to match a user's verbal selection to one of the provided time slot options.

**CRITICAL RULES:**
1.  **RETURN ONLY THE NUMBER:** Your entire response must be ONLY the number corresponding to the best match (e.g., "1", "2").
2.  **HANDLE AMBIGUITY:** If the user's selection is ambiguous or doesn't clearly match, return "NO_MATCH".
3.  **BE FLEXIBLE:** The user might not say the exact time. "The morning one," "the first one," "the 3:10," or "let's do the later one" are all valid selections. Use the context of the presented slots to find the best fit.
4.  **IGNORE EXTRA WORDS:** The user might say "Yes, the 8:30 is good." Focus on "8:30".

**CONTEXT:**
The user was presented with these numbered options:
${formattedSlotsForAI}

The user then said: "${userSelection}"

Which option number did the user select? (Return ONLY the number or "NO_MATCH")`;

    const messages: CoreMessage[] = [{ role: 'system', content: systemPrompt }];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0, // Set to 0 for maximum predictability
      maxTokens: 10,
    });

    const matchedIndex = parseInt(text.trim(), 10) - 1;

    if (!isNaN(matchedIndex) && matchedIndex >= 0 && matchedIndex < presentedSlots.length) {
      const matchedSlot = presentedSlots[matchedIndex];
      console.log(`[SlotMatcher] Successfully matched "${userSelection}" to slot #${matchedIndex + 1}: ${matchedSlot.time}`);
      return matchedSlot;
    }

    console.log(`[SlotMatcher] No definitive match found for user selection: "${userSelection}". AI response: "${text.trim()}"`);
    return null;

  } catch (error) {
    console.error("[SlotMatcher] Error during AI slot matching:", error);
    return null;
  }
}

================
File: lib/ai/summaryHelper.ts
================
import type { ConversationState } from '@/types/laine';

/**
 * Generates a concise, professional appointment note for dental office staff
 * @param state The full conversation state containing booking details
 * @returns A professional note string for the appointment
 */
export async function generateAppointmentNote(
  state: ConversationState
): Promise<string> {
  const { appointmentTypeName, duration } = state.booking;

  const note = `
Appointment Type: ${appointmentTypeName || 'Not specified'}
Duration: ${duration || 'N/A'} minutes
  `.trim().replace(/^    /gm, ''); // Cleans up indentation

  console.log(`[SummaryHelper] Generated state-driven appointment note: "${note}"`);
  return Promise.resolve(note); // Return as a promise to maintain async signature
}

================
File: lib/tool-handlers/selectAndConfirmSlotHandler.ts
================
import { matchUserSelectionToSlot } from '../ai/slotMatcher';
import { ConversationState } from '../../types/laine';
import { prisma } from '@/lib/prisma';
import { mergeState } from '@/lib/utils/state-helpers';
import { DateTime } from 'luxon';
import { bookNexhealthAppointment } from '@/lib/nexhealth';

interface SelectAndBookSlotArgs {
  userSelection: string;
  finalConfirmation?: boolean;
}

import { HandlerResult } from '../../types/vapi';

export async function handleSelectAndBookSlot(
  currentState: ConversationState,
  toolArguments: SelectAndBookSlotArgs,
  toolCallId: string
): Promise<HandlerResult> {
  console.log('[SelectAndBookSlot] Processing user selection:', toolArguments.userSelection, 'finalConfirmation:', toolArguments.finalConfirmation);

  const { userSelection, finalConfirmation } = toolArguments;

  // Get practice details for timezone and booking configuration
  const practice = await prisma.practice.findUnique({
    where: { id: currentState.practiceId },
    select: { 
      timezone: true,
      nexhealthSubdomain: true,
      nexhealthLocationId: true
    }
  });

  if (!practice) {
    return {
      toolResponse: { toolCallId, error: "Practice configuration not found." },
      newState: currentState
    };
  }

  const practiceTimezone = practice.timezone || 'America/Chicago';
  
  // Check if presentedSlots exists and is not empty
  if (!currentState.booking?.presentedSlots || currentState.booking.presentedSlots.length === 0) {
    console.log('[SelectAndBookSlot] ERROR: No presented slots available');
    return {
      toolResponse: {
        toolCallId,
        error: "I don't see any available time slots to choose from. Let me check availability for you first."
      },
      newState: currentState
    };
  }

  // If we don't have a selected slot yet, we need to match the user's selection
  let matchedSlot = currentState.booking.selectedSlot;

  if (!matchedSlot) {
    // Get the presented slots from current state
    const presentedSlots = currentState.booking.presentedSlots;

    console.log('[SelectAndBookSlot] Matching selection against', presentedSlots.length, 'slots');
    
    // Use AI slot matcher to find the selected slot
    const matchResult = await matchUserSelectionToSlot(
      userSelection,
      presentedSlots,
      practiceTimezone
    );
    
    matchedSlot = matchResult || undefined;

    if (!matchedSlot) {
      console.log('[SelectAndBookSlot] ERROR: Could not match user selection');
      return {
        toolResponse: {
          toolCallId,
          error: "I'm not sure which time slot you're referring to. Could you please be more specific? For example, you could say '10:30 AM' or 'the first option'."
        },
        newState: currentState
      };
    }

    console.log('[SelectAndBookSlot] Successfully matched slot:', matchedSlot);
  }

  // Generate formatted time for use in messages
  const formattedTime = DateTime.fromISO(matchedSlot.time, { zone: practiceTimezone })
                                .toFormat("cccc, MMMM d 'at' h:mm a");

  // Update the state with the selected slot and clear presented slots
  const newStateWithSelection = mergeState(currentState, {
    booking: {
      selectedSlot: matchedSlot,
      presentedSlots: [] // Clear the list of options once selection is made
    }
  });

  // If we DO NOT have final confirmation yet, ask for it.
  if (!finalConfirmation) {
    console.log('[SelectAndBookSlot] Slot selected. Asking for final confirmation.');
    
    // Check if patient has been identified (required for booking)
    if (!currentState.patient.id) {
      // Patient not identified yet - cannot book without patient ID
      const urgentFlowMessage = `Okay, I'd like to reserve that ${formattedTime} slot for you. Before I can book it, I'll need to get your details. Are you a new or an existing patient?`;
      
      console.log('[SelectAndBookSlot] Urgent flow: Patient ID missing, deferring booking until patient identified');
      
      return {
        toolResponse: {
          toolCallId,
          result: { needsConfirmation: true },
          message: {
            type: 'assistant-message',
            role: 'assistant',
            content: urgentFlowMessage
          }
        },
        newState: newStateWithSelection
      };
    }

    const { spokenName } = currentState.booking;
    const confirmationMessage = `Perfect. Just to confirm, I have you down for a ${spokenName || 'appointment'} on ${formattedTime}. Does that all sound correct?`;
    
    return {
      toolResponse: {
        toolCallId,
        result: { needsConfirmation: true },
        message: {
          type: 'assistant-message', 
          role: 'assistant',
          content: confirmationMessage
        }
      },
      newState: newStateWithSelection
    };
  }

  // If we HAVE final confirmation, proceed to book.
  console.log('[SelectAndBookSlot] Final confirmation received. Proceeding to book.');

  if (!currentState.patient.id) {
    return {
      toolResponse: {
        toolCallId,
        error: "Cannot book appointment: Patient ID is required but not found in state."
      },
      newState: newStateWithSelection
    };
  }

  if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
    return {
      toolResponse: {
        toolCallId,
        error: "Practice NexHealth configuration not found for booking."
      },
      newState: newStateWithSelection
    };
  }

  try {
    const bookingResult = await bookNexhealthAppointment(
      practice.nexhealthSubdomain,
      practice.nexhealthLocationId,
      currentState.patient.id,
      matchedSlot,
      newStateWithSelection // Pass the full state for the note
    );

    if (bookingResult.success) {
      console.log(`[SelectAndBookSlot] Successfully booked appointment with ID: ${bookingResult.bookingId}`);
      
      // Update state with confirmed booking ID
      const newStateWithBooking = mergeState(newStateWithSelection, {
        booking: {
          confirmedBookingId: bookingResult.bookingId,
          selectedSlot: undefined, // Clear the selected slot now that it's booked
          heldSlotId: undefined, // Clear any old hold data
          heldSlotExpiresAt: undefined
        },
        lastAction: 'HELD_SLOT' // Update to final action
      });

      const { spokenName } = currentState.booking;
      const successMessage = `You're all set! I've booked your ${spokenName || 'appointment'} for ${formattedTime}. You should receive a confirmation shortly. Is there anything else I can help you with today?`;
      
      return {
        toolResponse: {
          toolCallId,
          result: { success: true, bookingId: bookingResult.bookingId },
          message: {
            type: 'request-complete',
            role: 'assistant',
            content: successMessage
          }
        },
        newState: newStateWithBooking
      };
    } else {
      console.error('[SelectAndBookSlot] Booking failed:', bookingResult.error);
      
      // Clear selected slot from state and suggest re-checking slots
      const newStateWithoutSelection = mergeState(currentState, {
        booking: {
          selectedSlot: undefined,
          presentedSlots: []
        }
      });

      const failureMessage = `I'm so sorry, it looks like that time was just taken while we were speaking. Let me check for other available times for your ${currentState.booking.spokenName || 'appointment'}.`;
      
      return {
        toolResponse: {
          toolCallId,
          result: { success: false, error: bookingResult.error },
          message: {
            type: 'request-failed',
            role: 'assistant', 
            content: failureMessage
          }
        },
        newState: newStateWithoutSelection
      };
    }
  } catch (error) {
    console.error('[SelectAndBookSlot] Unexpected error during booking:', error);
    
    return {
      toolResponse: {
        toolCallId,
        result: { success: false },
        error: "I encountered an unexpected error while booking your appointment. Our staff has been notified and will call you shortly to finalize your appointment."
      },
      newState: newStateWithSelection
    };
  }
}

================
File: lib/tools/definitions/checkAvailableSlotsTool.ts
================
import type { VapiTool } from '@/types/vapi';

/**
 * Get the VAPI tool definition for checkAvailableSlots
 * This tool checks for available appointment slots for a previously identified appointment type
 */
export function getCheckAvailableSlotsTool(appBaseUrl: string): VapiTool {
  return {
    type: "function" as const,
    function: {
      name: "checkAvailableSlots",
      description: "Finds available appointment times. By default, proactively searches for the next available appointments. Call this after the appointment type is known. Only include parameters if the user has specifically expressed preferences.",
      parameters: {
        type: "object" as const,
        properties: {
          preferredDaysOfWeek: {
            type: "string" as const,
            description: "A JSON string array of the user's preferred days of the week. Example: '[\"Monday\", \"Wednesday\"]'. This is collected from the user."
          },
          timeBucket: {
            type: "string" as const,
            description: "The user's general time preference, which must be one of the following values: 'Early', 'Morning', 'Midday', 'Afternoon', 'Evening', 'Late', or 'AllDay'. This is collected from the user."
          },
          requestedDate: {
            type: "string" as const,
            description: "The user's specific requested date, like 'tomorrow', 'next Wednesday', or 'July 10th'. Use this for specific date searches."
          }
        },
        required: []
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi-webhook`,
    }
  };
}

================
File: lib/ai/appointmentMatcher.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import type { CoreMessage } from "ai";

interface ApptTypeInputForMatcher {
  id: string; // nexhealthAppointmentTypeId
  name: string;
  keywords: string | null;
}

export async function matchAppointmentTypeIntent(
  patientQuery: string,
  availableAppointmentTypes: ApptTypeInputForMatcher[]
): Promise<string | null> {
  try {
    console.log(`[AI Matcher] Attempting to match query: "${patientQuery}"`);

    // Check if OpenAI API key is available
    if (!process.env.OPENAI_API_KEY) {
      console.error("[AI Matcher] OPENAI_API_KEY not found in environment variables");
      return null;
    }

    // Format appointment types for the LLM prompt
    const formattedTypesString = availableAppointmentTypes
      .map(type => `ID: ${type.id}, Name: ${type.name}, Keywords: ${type.keywords || "None"}`)
      .join("\n");

    // Construct messages for the generateText call
    const messages: CoreMessage[] = [
      {
        role: "system",
        content: `You are an expert AI assistant for a dental office. Your task is to match a patient's stated reason for calling with the most appropriate dental appointment type from the provided list.
The list includes appointment type IDs, names, and associated keywords.
Respond ONLY with the 'ID' of the best matching appointment type.
If no clear match is found based on the patient's query and the available types/keywords, respond with "NO_MATCH".
Prioritize matches where the patient's query aligns well with the keywords or the name of the appointment type.
Consider common dental terms and patient language.
Example: If patient says "my tooth hurts badly", and an appointment type is "Emergency Exam" with keywords "toothache, pain, urgent", you should match it.
If patient says "I need a cleaning" and type is "Routine Cleaning", match it.
If patient says "I want to discuss veneers" and no cosmetic/veneer appointment type exists, return "NO_MATCH".`
      },
      {
        role: "user",
        content: `Patient's reason for calling: "${patientQuery}"

Available appointment types:
${formattedTypesString}

Which appointment type ID is the best match? (Return ONLY the ID or "NO_MATCH")`
      }
    ];

    // Call OpenAI with the messages
    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.1,
      maxTokens: 50
    });

    console.log(`[AI Matcher] LLM response for matching: "${text}"`);

    // Process the response
    const trimmedResponse = text.trim();
    if (trimmedResponse === "NO_MATCH") {
      return null;
    }

    return trimmedResponse;

  } catch (error) {
    console.error("[AI Matcher] Error during AI call:", error);
    return null;
  }
}

================
File: app/api/vapi-webhook/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

import { handleFindAppointmentType } from '@/lib/tool-handlers/findAppointmentTypeHandler';
import { handleCheckAvailableSlots } from '@/lib/tool-handlers/checkAvailableSlotsHandler';
import { handleSelectAndBookSlot } from '@/lib/tool-handlers/selectAndConfirmSlotHandler';
import { handleInsuranceInfo } from '@/lib/tool-handlers/insuranceInfoHandler';
import { handleIdentifyPatient } from '@/lib/tool-handlers/identifyPatientHandler';
import { Liquid } from 'liquidjs';
import { readFileSync } from 'fs';
import { join } from 'path';
import type { 
  ServerMessageToolCallsPayload, 
  HandlerResult,
  ServerMessageToolCallItem
} from '@/types/vapi';
import type { ConversationState } from '@/types/laine';
import { Prisma } from '@prisma/client';

export async function POST(request: Request) {
  const startTime = Date.now();
  let handlerResult: HandlerResult | undefined;
  let toolCall: ServerMessageToolCallItem | undefined;

  try {
    const body: ServerMessageToolCallsPayload = await request.json();
    const message = body.message;

    if (message?.type !== 'tool-calls') {
      return NextResponse.json({ message: "Ignoring non-tool-call message" });
    }

    // Extract the first tool call and call ID
    toolCall = message.toolCallList?.[0] || message.toolCalls?.[0];
    const callId = message.call.id;

    if (!toolCall || !callId) {
      console.error("[VAPI Webhook] Malformed payload, missing toolCall or callId:", message);
      return NextResponse.json({ 
        results: [{ toolCallId: "unknown", error: "Malformed tool call payload from VAPI." }] 
      }, { status: 200 });
    }

    // Get practice ID for database operations
    const firstPractice = await prisma.practice.findFirst();
    const practiceId = firstPractice?.id ?? "unknown";

    // Ensure callLog exists
    await prisma.callLog.upsert({
      where: { vapiCallId: callId },
      update: { updatedAt: new Date() },
      create: {
        vapiCallId: callId,
        practiceId: practiceId,
        callStatus: "TOOL_INTERACTION_STARTED",
        callTimestampStart: new Date(),
      },
    });

    // State management: retrieve or initialize conversation state
    let state: ConversationState;
    const callLog = await prisma.callLog.findUniqueOrThrow({ where: { vapiCallId: callId } });

    if (callLog.conversationState && typeof callLog.conversationState === 'object' && callLog.conversationState !== null) {
      state = callLog.conversationState as unknown as ConversationState;
      console.log(`[StatefulWebhook] Retrieved state for call: ${callId}`);
    } else {
      // Initialize state with new canonical structure
      state = {
        callId: callId,
        practiceId: practiceId,
        patient: {
          status: 'UNKNOWN',
          isNameConfirmed: false
        },
        insurance: {
          status: 'NOT_CHECKED'
        },
        booking: {
          isUrgent: false,
          presentedSlots: []
        }
      };
      console.log(`[StatefulWebhook] Initialized new canonical state for call: ${callId}`);
    }

    // Get tool name and arguments
    const toolName = toolCall.function.name;
    let toolArguments = toolCall.function.arguments;

    if (typeof toolArguments === 'string') {
      try {
        toolArguments = JSON.parse(toolArguments);
      } catch (e) {
        console.error(`[VAPI Webhook] Failed to parse tool arguments string:`, e);
        return NextResponse.json({ 
          results: [{ toolCallId: toolCall.id, error: `Failed to parse arguments for tool ${toolName}.` }] 
        }, { status: 200 });
      }
    }

    console.log(`[VAPI Webhook] Processing tool: ${toolName} (ID: ${toolCall.id}) for Call: ${callId}`);
    console.log(`[VAPI Webhook] Arguments:`, toolArguments);

    // Create initial tool log entry
    try {
      await prisma.toolLog.create({
        data: {
          practiceId: practiceId,
          vapiCallId: callId,
          toolName: toolName,
          toolCallId: toolCall.id,
          arguments: JSON.stringify(toolArguments),
          stateBefore: JSON.stringify(state),
          success: false, // Default to false, will be updated on success
          createdAt: new Date(startTime),
          updatedAt: new Date(startTime),
        }
      });
      console.log(`[DB Log] Created initial ToolLog for ID: ${toolCall.id}`);
    } catch (logError) {
      console.error('[DB Log] Failed to create initial tool log:', logError);
    }

    console.log('[VAPI Webhook] State before processing:', JSON.stringify(state, null, 2));

    // Tool routing switch statement  
    switch (toolName) {
      case "findAppointmentType": {
        handlerResult = await handleFindAppointmentType(
          state,
          toolArguments as { patientRequest: string; patientStatus?: string },
          toolCall.id
        );
        break;
      }

      case "checkAvailableSlots": {
        handlerResult = await handleCheckAvailableSlots(
          state,
          toolArguments as { preferredDaysOfWeek?: string; timeBucket?: string; requestedDate?: string },
          toolCall.id
        );
        break;
      }

      case "identifyPatient": {
        handlerResult = await handleIdentifyPatient(
          state,
          toolArguments as {
            firstName: string;
            lastName: string;
            dateOfBirth: string;
            phoneNumber: string;
            email: string;
          },
          toolCall.id
        );
        break;
      }

      case "selectAndBookSlot": {
        handlerResult = await handleSelectAndBookSlot(
          state,
          toolArguments as { userSelection: string; finalConfirmation?: boolean },
          toolCall.id
        );
        break;
      }

      case "insuranceInfo": {
        handlerResult = await handleInsuranceInfo(
          state,
          toolArguments as { insuranceName?: string },
          toolCall.id
        );
        break;
      }

      default: {
        console.error(`[VAPI Webhook] Unknown tool: ${toolName}`);
        handlerResult = {
          toolResponse: {
            toolCallId: toolCall.id,
            error: `I'm sorry, I don't know how to handle the "${toolName}" tool. Please try again.`
          },
          newState: state
        };
        break;
      }
    }

    if (!handlerResult) {
      // This case should ideally not be reached if all tools are handled.
      console.error(`[VAPI Webhook] No handler result for tool: ${toolName}`);
      return NextResponse.json({ 
        results: [{ toolCallId: toolCall.id, error: "Internal error: tool handler did not produce a result." }] 
      }, { status: 200 });
    }

    // Tool chaining is no longer needed with the new consolidated selectAndConfirmSlot tool

    console.log('[VAPI Webhook] Final handler result after processing:', JSON.stringify(handlerResult, null, 2));
    
    // Use the exact newState object from the handler's result for all subsequent operations.
    const newState = handlerResult.newState;

    // Atomically save the new, complete state to the database.
    await prisma.callLog.update({
      where: { vapiCallId: callId },
      data: { conversationState: newState as unknown as Prisma.InputJsonValue }
    });
    console.log(`[StatefulWebhook] Persisted state for call: ${callId}`);

    // Render the system prompt using the guaranteed fresh state.
    try {
      const liquid = new Liquid();
      const promptPath = join(process.cwd(), 'lib/system-prompt/laine_system_prompt.md');
      const promptTemplate = readFileSync(promptPath, 'utf-8');
      
      const renderedSystemPrompt = await liquid.parseAndRender(promptTemplate, newState);
      
      console.log(`[State Injection] Successfully rendered system prompt with fresh state`);

      // Construct and return the final response for VAPI
      return NextResponse.json({ 
        results: [handlerResult.toolResponse],
        systemPrompt: renderedSystemPrompt
      });
    } catch (promptError) {
      console.error('[State Injection] Error rendering system prompt:', promptError);
      
      // Fallback to original response without state injection
      return NextResponse.json({ results: [handlerResult.toolResponse] });
    }

  } catch (error) {
    console.error('Error in VAPI webhook:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  } finally {
    if (toolCall?.id && startTime && handlerResult) {
      const executionTimeMs = Date.now() - startTime;
      const isSuccess = !!handlerResult.toolResponse?.message && handlerResult.toolResponse.message.type !== 'request-failed';

      try {
        await prisma.toolLog.updateMany({
          where: { toolCallId: toolCall.id },
          data: {
            result: handlerResult?.toolResponse?.result ? JSON.stringify(handlerResult.toolResponse.result, null, 2) : undefined,
            error: !isSuccess ? JSON.stringify(handlerResult?.toolResponse, null, 2) : undefined,
            success: isSuccess,
            executionTimeMs: executionTimeMs,
            apiResponses: handlerResult?.toolResponse?.result && typeof handlerResult.toolResponse.result === 'object' && 'apiLog' in handlerResult.toolResponse.result ? JSON.stringify(handlerResult.toolResponse.result.apiLog, null, 2) : undefined,
            updatedAt: new Date(),
          }
        });
        console.log(`[DB Log] Finalized ToolLog for ID: ${toolCall.id} with success: ${isSuccess}`);
      } catch (logError) {
        console.error('[DB Log] Failed to finalize tool log:', logError);
      }
    }
  }
}

================
File: lib/tool-handlers/findAppointmentTypeHandler.ts
================
import { prisma } from "@/lib/prisma";
import { matchAppointmentTypeIntent } from "@/lib/ai/appointmentMatcher";

import type { HandlerResult, ApiLog } from "@/types/vapi";
import type { ConversationState } from "@/types/laine";
import { mergeState } from '@/lib/utils/state-helpers';

interface FindAppointmentTypeArgs {
  patientRequest: string;
  patientStatus?: string;
}

export async function handleFindAppointmentType(
  currentState: ConversationState,
  toolArguments: FindAppointmentTypeArgs,
  toolId: string
): Promise<HandlerResult> {
  const { patientRequest, patientStatus } = toolArguments;
  
  // Initialize API log array to capture all external calls
  const apiLog: ApiLog = [];
  
  console.log(`[FindAppointmentTypeHandler] Processing request: "${patientRequest}", patientStatus: "${patientStatus}"`);
  
  // Note: Acknowledgment generation removed for simplified flow
  
  try {
    if (!currentState.practiceId) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Practice configuration not found."
        },
        newState: currentState
      };
    }

    if (!patientRequest) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Missing patientRequest parameter."
        },
        newState: currentState
      };
    }

    console.log(`[FindAppointmentTypeHandler] Using practice: ${currentState.practiceId}`);

    // Fetch appointment types with keywords for this practice (only bookable online)
    const dbAppointmentTypes = await prisma.appointmentType.findMany({
      where: {
        practiceId: currentState.practiceId,
        bookableOnline: true, // Only include appointment types that are active for online booking
        AND: [
          { keywords: { not: null } },
          { keywords: { not: "" } }
        ]
      },
      select: {
        nexhealthAppointmentTypeId: true,
        name: true,
        duration: true,
        keywords: true,
        check_immediate_next_available: true,
        spokenName: true
      }
    });

    if (!dbAppointmentTypes || dbAppointmentTypes.length === 0) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "No suitable appointment types are configured for matching in this practice."
        },
        newState: currentState
      };
    }

    console.log(`[FindAppointmentTypeHandler] Found ${dbAppointmentTypes.length} appointment types with keywords`);

    // Use AI to match the patient request to appointment types
    const matchedApptId = await matchAppointmentTypeIntent(
      patientRequest,
      dbAppointmentTypes.map(at => ({
        id: at.nexhealthAppointmentTypeId,
        name: at.name,
        keywords: at.keywords || "",
      }))
    );

    if (!matchedApptId) {
      console.log(`[FindAppointmentTypeHandler] No appointment type matched for request: "${patientRequest}"`);

      return {
        toolResponse: {
          toolCallId: toolId,
          result: { apiLog: apiLog },
          message: {
            type: "request-failed",
            role: "assistant",
            content: "I understand you're looking for an appointment, but I couldn't determine the exact type of service you need. Could you please be more specific?"
          }
        },
        newState: currentState
      };
    }

    // Find the matched appointment type's details 
    const matchedAppointmentType = dbAppointmentTypes.find(at => 
      at.nexhealthAppointmentTypeId === matchedApptId
    );

    if (!matchedAppointmentType) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Error retrieving appointment type details."
        },
        newState: currentState
      };
    }

    console.log(`[FindAppointmentTypeHandler] Successfully found appointment type: ${matchedAppointmentType.name}`);

    // Create new state with appointment booking details
    const newState = mergeState(currentState, {
              booking: {
        appointmentTypeId: matchedAppointmentType.nexhealthAppointmentTypeId,
        appointmentTypeName: matchedAppointmentType.name,
        spokenName: matchedAppointmentType.spokenName || matchedAppointmentType.name,
        duration: matchedAppointmentType.duration,
        isUrgent: matchedAppointmentType.check_immediate_next_available
      }
    });

    // Log the successful state update for debugging
    console.log('[FindAppointmentTypeHandler] State updated with appointmentTypeId:', newState.booking.appointmentTypeId);
    console.log('[FindAppointmentTypeHandler] Full updated booking state:', JSON.stringify(newState.booking, null, 2));

    // The tool's job is now ONLY to identify the type and update the state.
    // The system prompt will guide the next conversational step.
    // We return a simple success result without a message to ensure the state is saved
    // and let the LLM decide the next step based on the updated state.
    return {
      newState: newState,
      toolResponse: {
        toolCallId: toolId,
        result: {
          success: true,
          appointmentTypeId: matchedAppointmentType.nexhealthAppointmentTypeId,
          appointmentTypeName: matchedAppointmentType.name,
          spokenName: matchedAppointmentType.spokenName || matchedAppointmentType.name,
          duration: matchedAppointmentType.duration,
          isUrgent: matchedAppointmentType.check_immediate_next_available,
          apiLog: apiLog
        }
        // By not including a "message", we allow the LLM to decide the next conversational step
        // based on the updated state and the system prompt's guidance.
      }
    };

  } catch (error) {
    console.error(`[FindAppointmentTypeHandler] Error processing appointment type:`, error);
    return {
      toolResponse: {
        toolCallId: toolId,
        result: { apiLog: apiLog },
        error: "Database error while fetching appointment types."
      },
      newState: currentState
    };
  }
}

================
File: lib/tools/index.ts
================
import type { VapiTool } from '@/types/vapi';
import { getFindAppointmentTypeTool } from './definitions/findAppointmentTypeTool';
import { getIdentifyPatientTool } from './definitions/identifyPatientTool';
import { getCheckAvailableSlotsTool } from './definitions/checkAvailableSlotsTool';
import { getSelectAndBookSlotTool } from './definitions/selectAndConfirmSlotTool';
import { getInsuranceInfoTool } from './definitions/insuranceInfoTool';

/**
 * Central map of all tool definitions
 * Keys are tool names, values are tool-getter functions
 */
export const toolDefinitionMap = {
  findAppointmentType: getFindAppointmentTypeTool,
  identifyPatient: getIdentifyPatientTool,
  checkAvailableSlots: getCheckAvailableSlotsTool,
  selectAndBookSlot: getSelectAndBookSlotTool,
  insuranceInfo: getInsuranceInfoTool,
};

/**
 * Aggregate all individual tool definitions for use when updating the VAPI assistant
 * @param appBaseUrl - The base URL for the application (used in tool server URLs)
 * @returns Array of all available VAPI tool definitions
 */
export function getAllTools(appBaseUrl: string): VapiTool[] {
  const tools: VapiTool[] = Object.values(toolDefinitionMap).map(getToolFn => getToolFn(appBaseUrl));
  return tools;
}

================
File: lib/tool-handlers/checkAvailableSlotsHandler.ts
================
import { prisma } from "@/lib/prisma";
import { normalizeDateWithAI, findAvailableSlots, generateTimeBucketResponse, generateSlotResponse, TIME_BUCKETS, type TimeBucket } from "@/lib/ai/slotHelper";
import { DateTime } from "luxon";
import type { HandlerResult, ApiLog } from "@/types/vapi";
import type { ConversationState } from "@/types/laine";
import { mergeState } from '@/lib/utils/state-helpers';

interface CheckAvailableSlotsArgs {
  preferredDaysOfWeek?: string;
  timeBucket?: string;
  requestedDate?: string;
  searchWindowDays?: number;
}

export async function handleCheckAvailableSlots(
  currentState: ConversationState,
  toolArguments: CheckAvailableSlotsArgs,
  toolId: string
): Promise<HandlerResult> {
  const { requestedDate, timeBucket, preferredDaysOfWeek, searchWindowDays } = toolArguments;
  
  // Initialize API log array to capture all external calls
  const apiLog: ApiLog = [];
  
  console.log(`[CheckAvailableSlotsHandler] Processing with requestedDate: "${requestedDate}", timeBucket: "${timeBucket}", preferredDaysOfWeek: "${preferredDaysOfWeek}", searchWindowDays: ${searchWindowDays}`);
  
  try {
    try {
      if (!currentState.practiceId) {
        return {
          toolResponse: {
            toolCallId: toolId,
            error: "Practice configuration not found."
          },
          newState: currentState
        };
      }

      if (!currentState.booking.appointmentTypeId) {
        return {
          toolResponse: {
            toolCallId: toolId,
            error: "Error: I must know the reason for the visit before checking for appointments. I need to use the findAppointmentType tool first."
          },
          newState: currentState
        };
      }

    // Fetch practice details
    const practice = await prisma.practice.findUnique({
      where: { id: currentState.practiceId },
      select: {
        id: true,
        timezone: true,
        nexhealthSubdomain: true,
        nexhealthLocationId: true,
      }
    });

    if (!practice || !practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: "Practice NexHealth configuration not found."
        },
        newState: currentState
      };
    }

    // 1. UNIFIED DATE DETERMINATION LOGIC (prioritizes proactive "first available" search)
    let searchDate: string | null = null;

    // Priority 0: Handle system-initiated urgent search
    if (searchWindowDays) {
      console.log(`[CheckAvailableSlotsHandler] Proactive urgent search triggered for ${searchWindowDays} days.`);
      searchDate = DateTime.now().setZone(practice.timezone || 'America/Chicago').toFormat('yyyy-MM-dd');
    }
    // Priority 1: Handle explicit user date request
    else if (requestedDate) {
      console.log(`[CheckAvailableSlotsHandler] User provided a specific date: "${requestedDate}". Normalizing...`);
      searchDate = await normalizeDateWithAI(requestedDate, practice.timezone || 'America/Chicago');
      if (!searchDate) {
        return {
          toolResponse: {
            toolCallId: toolId,
            result: `I couldn't quite understand the date "${requestedDate}". Could you try saying it a different way?`
          },
          newState: currentState
        };
      }
      console.log(`[CheckAvailableSlotsHandler] Normalized date to: ${searchDate}`);
    } 
    // Priority 2: Handle preferred days of week
    else if (preferredDaysOfWeek) {
      try {
        const preferredDays = JSON.parse(preferredDaysOfWeek);
        if (Array.isArray(preferredDays) && preferredDays.length > 0) {
          const dayName = preferredDays[0]; // Taking the first preferred day
          const dayIndex = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'].indexOf(dayName.toLowerCase());
          
          if (dayIndex !== -1) {
            let searchDateTime = DateTime.now().setZone(practice.timezone || 'America/Chicago');
            
            // Find the next occurrence of the preferred day
            // If today is the preferred day, we'll still look for next occurrence to avoid booking too last minute
            do {
              searchDateTime = searchDateTime.plus({ days: 1 });
            } while (searchDateTime.weekday % 7 !== dayIndex);
            
            searchDate = searchDateTime.toFormat('yyyy-MM-dd');
            console.log(`[CheckAvailableSlotsHandler] Calculated next ${dayName} as: ${searchDate}`);
          } else {
            console.error(`[CheckAvailableSlotsHandler] Invalid day name: ${dayName}`);
          }
        }
      } catch (e) {
        console.error("[CheckAvailableSlotsHandler] Could not parse preferredDaysOfWeek", e);
      }
    }

    // Priority 3: DEFAULT PROACTIVE PATH - "First Available" search (NEW DEFAULT BEHAVIOR)
    if (!searchDate) {
      console.log(`[CheckAvailableSlotsHandler] No user preference detected. Initiating default 'first available' search.`);
      const nowInPracticeTimezone = DateTime.now().setZone(practice.timezone || 'America/Chicago');
      searchDate = nowInPracticeTimezone.toFormat('yyyy-MM-dd');
      console.log(`[CheckAvailableSlotsHandler] Default 'first available' flow. Search date explicitly set to: ${searchDate} (timezone: ${practice.timezone || 'America/Chicago'})`);
      console.log(`[CheckAvailableSlotsHandler] DateTime debug - now: ${DateTime.now().toISO()}, in timezone: ${nowInPracticeTimezone.toISO()}, formatted: ${searchDate}`);
    }

    // 2. DETERMINE SEARCH WINDOW
    const { isUrgent } = currentState.booking;
    const isImmediateBooking = isUrgent; // Treat isUrgent as isImmediateBooking for now
    let searchDays: number;
    
    if (searchWindowDays) {
      searchDays = searchWindowDays; // Use the system-specified window for urgent proactive search
    } else if (requestedDate) {
      searchDays = 1; // Search only the specific requested date
    } else if (isUrgent || isImmediateBooking) {
      searchDays = 7; // Search 7 days for urgent appointments if no specific date requested
    } else if (!requestedDate && !preferredDaysOfWeek && !timeBucket) {
      // This is the new default "first available" path - search more days for better options
      searchDays = 14; // Expanded search window for proactive first-available flow
      console.log(`[CheckAvailableSlotsHandler] Using expanded 14-day search window for 'first available' flow.`);
    } else {
      searchDays = 3; // Search 3 days for other flows
    }

    // 3. PERFORM THE SEARCH
    const searchResult = await findAvailableSlots(
      currentState.booking.appointmentTypeId,
      {
        id: practice.id,
        nexhealthSubdomain: practice.nexhealthSubdomain!,
        nexhealthLocationId: practice.nexhealthLocationId!,
        timezone: practice.timezone || 'America/Chicago'
      },
      searchDate,
      searchDays,
      timeBucket as TimeBucket
    );

    // 3.5. DETECT DELAYED AVAILABILITY
    let isDelayedAvailability = false;
    if (searchResult.foundSlots.length > 0) {
      const searchDateTime = DateTime.fromISO(searchDate, { zone: practice.timezone || 'America/Chicago' });
      const firstSlotTime = DateTime.fromISO(searchResult.foundSlots[0].time, { zone: practice.timezone || 'America/Chicago' });
      const daysUntilFirstSlot = firstSlotTime.diff(searchDateTime, 'days').days;

      if (daysUntilFirstSlot > 2) {
        isDelayedAvailability = true;
        console.log(`[CheckAvailableSlotsHandler] Delayed availability detected. First slot is ${daysUntilFirstSlot.toFixed(1)} days from search date.`);
      }
    }

    // 4. SLOTS ARE NOW PRE-FILTERED BY findAvailableSlots
    const filteredSlots = searchResult.foundSlots;

    const spokenName = currentState.booking.spokenName || currentState.booking.appointmentTypeName || 'appointment';

    // 4. DECIDE HOW TO RESPOND BASED ON FLOW TYPE
    
    // Decide whether to present specific slots or time buckets
    const shouldPresentSpecificSlots = (isUrgent || isImmediateBooking) || timeBucket;

    if (shouldPresentSpecificSlots) {
      console.log(`[CheckAvailableSlotsHandler] Presenting specific slots. isUrgent: ${isUrgent}, isImmediateBooking: ${isImmediateBooking}, timeBucket provided: ${!!timeBucket}`);

      const aiResponse = await generateSlotResponse(
        searchResult, // searchResult already contains the pre-filtered slots
        spokenName,
        practice.timezone || 'America/Chicago'
      );

      // Create new state with slots data
      const newState = mergeState(currentState, {
        booking: {
          presentedSlots: searchResult.foundSlots
        }
      });

      return {
        newState: newState,
        toolResponse: {
          toolCallId: toolId,
          result: { // Structured data payload
            foundSlots: searchResult.foundSlots,
            nextAvailableDate: searchResult.nextAvailableDate || null,
            isDelayedAvailability: isDelayedAvailability,
            apiLog: apiLog
          },
          message: { // High-fidelity message
            type: "request-complete",
            role: "assistant",
            content: aiResponse // The AI-generated response from generateSlotResponse
          }
        }
      };

    } else {
      // STANDARD FLOW - First pass, present time buckets
      console.log('[CheckAvailableSlotsHandler] Presenting time buckets for standard flow.');
      
      // Generate response with time buckets based on filteredSlots
      const availableBuckets: string[] = [];
      const primaryBuckets = ['Morning', 'Afternoon', 'Evening'] as const;
      
      for (const bucket of primaryBuckets) {
        const bucketRange = TIME_BUCKETS[bucket];
        const [startHour, startMinute] = bucketRange.start.split(':').map(Number);
        const [endHour, endMinute] = bucketRange.end.split(':').map(Number);
        
        const hasSlotInBucket = filteredSlots.some(slot => {
          const slotTime = DateTime.fromISO(slot.time);
          const slotHour = slotTime.hour;
          const slotMinute = slotTime.minute;
          
          const slotTimeInMinutes = slotHour * 60 + slotMinute;
          const startTimeInMinutes = startHour * 60 + startMinute;
          const endTimeInMinutes = endHour * 60 + endMinute;
          
          return slotTimeInMinutes >= startTimeInMinutes && slotTimeInMinutes <= endTimeInMinutes;
        });
        
        if (hasSlotInBucket) {
          availableBuckets.push(bucket);
        }
      }

      console.log(`[CheckAvailableSlotsHandler] Found slots in time buckets: ${availableBuckets.join(', ')}`);

      // Generate the day of week for the response
      const searchDateTime = DateTime.fromISO(searchDate, { zone: practice.timezone || 'America/Chicago' });
      const dayOfWeek = searchDateTime.toFormat('cccc'); // e.g., "Thursday"
      
      // Use the time bucket response generator
      const aiResponse = await generateTimeBucketResponse(
        availableBuckets,
        dayOfWeek,
        spokenName
      );

      console.log(`[CheckAvailableSlotsHandler] Successfully presented ${availableBuckets.length} time bucket options for ${filteredSlots.length} total slots`);

      // Create new state with slots data
      const newState = mergeState(currentState, {
        booking: {
          presentedSlots: filteredSlots
        }
      });

      return {
        newState: newState,
        toolResponse: {
          toolCallId: toolId,
          result: { // Structured data payload
            foundSlots: filteredSlots, // Note: we return all filtered slots here
            nextAvailableDate: searchResult.nextAvailableDate || null,
            isDelayedAvailability: isDelayedAvailability,
            apiLog: apiLog
          },
          message: { // High-fidelity message
            type: "request-complete",
            role: "assistant",
            content: aiResponse // The AI-generated response from generateTimeBucketResponse
          }
        }
      };
    }

    } catch (error) {
      console.error(`[CheckAvailableSlotsHandler] Error during slot search:`, error);
      if (error instanceof Error && error.message.includes("Configuration Error")) {
        // This is a configuration problem, not a lack of availability.
        return {
          toolResponse: {
            toolCallId: toolId,
            error: `There's a configuration issue with the '${currentState.booking.spokenName}' appointment type. I cannot check for slots. Please inform the user that a staff member will call them back to schedule this specific appointment type.`
          },
          newState: currentState
        };
      }
      // Generic fallback error for other issues
      return {
        toolResponse: {
          toolCallId: toolId,
          result: { apiLog: apiLog },
          error: "I encountered a system error while checking for available appointments."
        },
        newState: currentState
      };
    }

  } catch (error) {
    console.error(`[CheckAvailableSlotsHandler] Outer error catching available slots:`, error);
    return {
      toolResponse: {
        toolCallId: toolId,
        result: { apiLog: apiLog },
        error: "Error checking available appointment slots."
      },
      newState: currentState
    };
  }
}

================
File: lib/ai/slotHelper.ts
================
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";
import { DateTime } from "luxon";
import type { CoreMessage } from "ai";

/**
 * Defines the time ranges for different parts of the day.
 * Used to filter appointment slots based on user preference.
 * Note: 'Morning' and 'Afternoon' are broad, while others are more specific.
 * 'Midday' overlaps with both Morning and Afternoon to catch appointments around noon.
 */
export const TIME_BUCKETS = {
  Early:     { start: "05:00", end: "08:30" },
  Morning:   { start: "05:00", end: "12:00" },
  Midday:    { start: "10:00", end: "15:00" },
  Afternoon: { start: "12:00", end: "17:00" },
  Evening:   { start: "15:30", end: "20:00" },
  Late:      { start: "17:00", end: "22:00" },
  AllDay:    { start: "05:00", end: "22:00" }
};

export type TimeBucket = keyof typeof TIME_BUCKETS;

/**
 * Normalize a date query using AI to convert natural language dates into YYYY-MM-DD format
 */
export async function normalizeDateWithAI(
  dateQuery: string, 
  practiceTimezone: string
): Promise<string | null> {
  try {
    const now = DateTime.now().setZone(practiceTimezone);
    const systemPromptContent = `You are a date parsing AI. Your only task is to convert a user's spoken date query into a strict 'YYYY-MM-DD' format. The user is in the 'America/Chicago' timezone.

    Today's date is ${now.toFormat('yyyy-MM-dd')}.

    - Interpret "today" as ${now.toFormat('yyyy-MM-dd')}.
    - Interpret "tomorrow" as ${now.plus({ days: 1 }).toFormat('yyyy-MM-dd')}.
    - If the user provides a date like "July 23rd" and that date has already passed this year, assume they mean next year.
    - If a query is ambiguous or not a date, you MUST return 'INVALID_DATE'.

    Your entire response MUST be ONLY the 'YYYY-MM-DD' string or "INVALID_DATE". Do not add any other words.`;

    const userPromptContent = `User Query: "${dateQuery}"

Normalized Date (YYYY-MM-DD or INVALID_DATE):`;

    const messages: CoreMessage[] = [
      { role: 'system', content: systemPromptContent },
      { role: 'user', content: userPromptContent }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0,
      maxTokens: 50
    });

    const normalizedDate = text.trim();
    
    if (!normalizedDate || normalizedDate === "INVALID_DATE") {
      console.log(`[Date Normalization] Could not parse date: "${dateQuery}"`);
      return null;
    }

    // Validate the returned date format
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(normalizedDate)) {
      console.error(`[Date Normalization] AI returned invalid format: "${normalizedDate}"`);
      return null;
    }

    console.log(`[Date Normalization] Successfully parsed "${dateQuery}"  "${normalizedDate}"`);
    return normalizedDate;
  } catch (error) {
    console.error('[Date Normalization] Error:', error);
    return null;
  }
}

/**
 * Generate a natural spoken message presenting available slots or alternatives
 * @deprecated This function will be removed in a future refactor phase as we move to preference-based scheduling
 */
export async function generateSlotResponseMessage(
  appointmentTypeName: string,
  normalizedDate: string,
  availableSlots: string[],
  timePreference?: string
): Promise<string> {
  try {
    console.log(`[Slot Response] Generating message for ${appointmentTypeName} on ${normalizedDate}, ${availableSlots.length} slots available`);

    // Format the date for natural speech
    const dateObj = DateTime.fromISO(normalizedDate);
    const friendlyDate = dateObj.toFormat('EEEE, MMMM dd'); // e.g., "Monday, December 23"
    
    const timePreferenceText = timePreference ? ` ${timePreference}` : '';
    
    let prompt: string;

    if (availableSlots.length > 0) {
      const slotsList = availableSlots.slice(0, 3).join(', '); // Limit to first 3 slots
      const hasMoreSlots = availableSlots.length > 3;
      
      prompt = `You are Laine, a friendly dental assistant. Generate a natural response offering available appointment slots.

Appointment Type: ${appointmentTypeName}
Date: ${friendlyDate}
Time Preference: ${timePreference || 'none specified'}
Available slots: ${slotsList}${hasMoreSlots ? ' (and more)' : ''}

Create a natural, conversational response that:
1. Confirms the appointment type and date
2. Presents the available time slots (up to 3)
3. Asks if any of those work for the patient
4. Be warm and helpful

Keep it concise and natural. Return only the response text.

Example format: "Great! For your ${appointmentTypeName} on ${friendlyDate}${timePreferenceText}, I have ${slotsList} available. Would any of those work for you?"`;
    } else {
      prompt = `You are Laine, a friendly dental assistant. Generate a natural response when no appointment slots are available.

Appointment Type: ${appointmentTypeName}
Date: ${friendlyDate}
Time Preference: ${timePreference || 'none specified'}

Create a natural, apologetic response that:
1. Acknowledges the specific appointment type and date requested
2. Mentions if there was a time preference
3. Suggests trying a different date or removing time restrictions
4. Be empathetic and helpful

Keep it concise and natural. Return only the response text.

Example format: "I'm sorry, I don't have any available slots for your ${appointmentTypeName} on ${friendlyDate}${timePreferenceText}. Would you like to try a different date, or perhaps I can check for any availability that day without a specific time preference?"`;
    }

    const messages: CoreMessage[] = [
      {
        role: "user",
        content: prompt
      }
    ];

    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages,
      temperature: 0.3,
      maxTokens: 150
    });

    const message = text.trim();
    
    if (!message) {
      // Fallback message
      if (availableSlots.length > 0) {
        const slotsList = availableSlots.slice(0, 3).join(', ');
        return `For your ${appointmentTypeName} on ${friendlyDate}, I have ${slotsList} available. Would any of those work for you?`;
      } else {
        return `I'm sorry, I don't have any available slots for your ${appointmentTypeName} on ${friendlyDate}. Would you like to try a different date?`;
      }
    }

    console.log(`[Slot Response] Generated message: "${message}"`);
    return message;
  } catch (error) {
    console.error('[Slot Response] Error generating message:', error);
    
    // Fallback message
    if (availableSlots.length > 0) {
      const slotsList = availableSlots.slice(0, 3).join(', ');
      return `For your ${appointmentTypeName}, I have ${slotsList} available. Would any of those work for you?`;
    } else {
      return `I'm sorry, I don't have any available slots for your ${appointmentTypeName} on that date. Would you like to try a different date?`;
    }
  }
}

/**
 * Get slot search parameters for a specific appointment type from the database
 * @param appointmentTypeId NexHealth appointment type ID 
 * @param practiceId Practice ID
 * @returns Object with duration, providerIds, and operatoryIds needed for slot search
 */
export async function getSlotSearchParams(
  appointmentTypeId: string,
  practiceId: string
): Promise<{ duration: number; providerIds: string[]; operatoryIds: string[] }> {
  const { prisma } = await import("@/lib/prisma");

  // 1. Fetch the AppointmentType and include all related active providers and their operatories
  const appointmentType = await prisma.appointmentType.findFirst({
    where: {
      nexhealthAppointmentTypeId: appointmentTypeId,
      practiceId: practiceId,
    },
    include: {
      acceptedByProviders: { // This is the join table
        where: {
          savedProvider: {
            isActive: true, // Filter for active providers
          },
        },
        include: {
          savedProvider: {
            include: {
              provider: true, // Get the provider details (for the ID)
              assignedOperatories: { // Get the assigned operatories for this provider
                where: {
                  savedOperatory: {
                    isActive: true, // Filter for active operatories
                  },
                },
                include: {
                  savedOperatory: true, // Get the operatory details (for the ID)
                },
              },
            },
          },
        },
      },
    },
  });

  if (!appointmentType) {
    throw new Error(`Configuration Error: Appointment type with ID ${appointmentTypeId} not found for practice ${practiceId}.`);
  }

  const activeProviders = appointmentType.acceptedByProviders.map(
    (p) => p.savedProvider
  );

  if (activeProviders.length === 0) {
    throw new Error(`Configuration Error: No active providers are configured to accept the appointment type ID ${appointmentTypeId}.`);
  }

  // 2. Collect unique NexHealth provider IDs from the results
  const providerIds = Array.from(
    new Set(activeProviders.map((sp) => sp.provider.nexhealthProviderId))
  );

  // 3. Collect unique NexHealth operatory IDs from all found providers
  const operatoryIds = Array.from(
    new Set(
      activeProviders
        .flatMap((sp) => sp.assignedOperatories)
        .map((assignment) => assignment.savedOperatory.nexhealthOperatoryId)
    )
  );

  if (operatoryIds.length === 0) {
    throw new Error(`Configuration Error: The active providers for appointment type ID ${appointmentTypeId} have no active operatories assigned.`);
  }

  // 4. Return the collected data
  return {
    duration: appointmentType.duration,
    providerIds,
    operatoryIds,
  };
}

// Interface for individual slot data
interface SlotData {
  time: string;
  operatory_id?: number;
  providerId: number;
  locationId: number;
}

// Interface for provider data from NexHealth API
interface ProviderSlotData {
  pid: number;
  lid: number;
  slots: Array<{
    time: string;
    operatory_id?: number;
  }>;
}

// Interface for NexHealth API response
interface NexHealthSlotsResponse {
  data: {
    data: ProviderSlotData[];
    next_available_date?: string;
  };
}

/**
 * Find available slots for an appointment type
 * @param appointmentTypeId NexHealth appointment type ID
 * @param practice Practice details with NexHealth configuration
 * @param startDate Starting date to search from in YYYY-MM-DD format
 * @param searchDays Number of days to search
 * @returns Object with found slots and next available date if no slots found
 */
export async function findAvailableSlots(
  appointmentTypeId: string,
  practice: {
    id: string;
    nexhealthSubdomain: string;
    nexhealthLocationId: string;
    timezone: string;
  },
  startDate: string,
  searchDays: number,
  timeBucket?: TimeBucket
): Promise<{ foundSlots: SlotData[]; nextAvailableDate: string | null }> {
  const { fetchNexhealthAPI } = await import("@/lib/nexhealth");
  const { prisma } = await import("@/lib/prisma");
  
  // Get slot search parameters
  const { duration, providerIds, operatoryIds } = await getSlotSearchParams(
    appointmentTypeId,
    practice.id
  );

  console.log(`[Slot Search] Bulk searching for ${duration}-minute slots across ${searchDays} days with providers: ${providerIds.join(', ')} and operatories: ${operatoryIds.join(', ')}`);

  // Fetch practice-specific scheduling rules
  const practiceSettings = await prisma.practice.findUnique({
    where: { id: practice.id },
    select: {
      lunchBreakStart: true,
      lunchBreakEnd: true,
      minBookingBufferMinutes: true,
      timezone: true
    }
  });

  // Use practice timezone, default to America/Chicago if not set
  const timezone = practice.timezone || 'America/Chicago';
  const lunchBreakStart = practiceSettings?.lunchBreakStart;
  const lunchBreakEnd = practiceSettings?.lunchBreakEnd;
  const bookingBufferMinutes = practiceSettings?.minBookingBufferMinutes || 0;
  
  console.log(`[Slot Search] Searching from ${startDate} for ${searchDays} days in timezone ${timezone}`);

  try {
    // Build the query string for a single bulk API call
    let queryString = `start_date=${startDate}&days=${searchDays}&slot_length=${duration.toString()}`;
    queryString += `&lids[]=${practice.nexhealthLocationId}`;
    queryString += `&overlapping_operatory_slots=false`; // Prevent conflicts with partially booked slots
    providerIds.forEach(id => {
      queryString += `&pids[]=${id}`;
    });
    operatoryIds.forEach(id => {
      queryString += `&operatory_ids[]=${id}`;
    });

    const pathWithQuery = `/appointment_slots?${queryString}`;

    console.log(`[NexHealth Bulk Request] Fetching ${searchDays} days with path: ${pathWithQuery}`);

    // Make single bulk API call to NexHealth
    const response = await fetchNexhealthAPI(
      pathWithQuery,
      practice.nexhealthSubdomain,
      undefined // Pass undefined for params since we built it into the path
    ) as NexHealthSlotsResponse;

    console.log(`[Slot Search] Bulk API response received for ${searchDays} days`);

    // Process the response data
    const responseData = response.data; // The object from fetchNexhealthAPI
    const nexhealthData = responseData.data; // The actual payload from NexHealth
    let nextAvailableDate: string | null = null;

    // Store next_available_date from the API response if present
    if (responseData && responseData.next_available_date) {
      nextAvailableDate = responseData.next_available_date;
      console.log(`[Slot Search] Found next_available_date: ${nextAvailableDate}`);
    }

    if (!nexhealthData || !Array.isArray(nexhealthData)) {
      console.log(`[Slot Search] No slot data received from bulk API call`);
      return { foundSlots: [], nextAvailableDate };
    }

    // Collect all slots from all providers across all days
    const allSlots = nexhealthData.flatMap((providerData: ProviderSlotData) => {
      if (providerData.slots && Array.isArray(providerData.slots)) {
        return providerData.slots.map((slot) => ({
          ...slot,
          providerId: providerData.pid,
          locationId: providerData.lid
        }));
      }
      return [];
    });

    console.log(`[Slot Search] Collected ${allSlots.length} total slots from bulk API response`);

    // Filter out slots that overlap with configurable lunch break
    const lunchFilteredSlots = allSlots.filter((slot) => {
      try {
        // Parse the slot time to get the start time
        const slotStartTime = DateTime.fromISO(slot.time).setZone(timezone);
        
        // Calculate the slot end time by adding duration
        const slotEndTime = slotStartTime.plus({ minutes: duration });
        
        // Check for lunch break conflicts only if lunch break is configured
        if (lunchBreakStart && lunchBreakEnd) {
          const [lunchStartHour, lunchStartMinute] = lunchBreakStart.split(':').map(Number);
          const [lunchEndHour, lunchEndMinute] = lunchBreakEnd.split(':').map(Number);
          
          const slotStartHour = slotStartTime.hour;
          const slotStartMinute = slotStartTime.minute;
          const slotEndHour = slotEndTime.hour;
          const slotEndMinute = slotEndTime.minute;
          
          // Check if slot overlaps with lunch break
          const slotStartsInLunch = (slotStartHour === lunchStartHour && slotStartMinute >= lunchStartMinute) || 
                                   (slotStartHour > lunchStartHour && slotStartHour < lunchEndHour) ||
                                   (slotStartHour === lunchEndHour && slotStartMinute < lunchEndMinute);
          
          const slotEndsInLunch = (slotEndHour === lunchStartHour && slotEndMinute > lunchStartMinute) || 
                                 (slotEndHour > lunchStartHour && slotEndHour < lunchEndHour) ||
                                 (slotEndHour === lunchEndHour && slotEndMinute <= lunchEndMinute);
          
          const slotSpansLunch = (slotStartHour < lunchStartHour || (slotStartHour === lunchStartHour && slotStartMinute <= lunchStartMinute)) && 
                               (slotEndHour > lunchEndHour || (slotEndHour === lunchEndHour && slotEndMinute >= lunchEndMinute));
          
          const isLunchConflict = slotStartsInLunch || slotEndsInLunch || slotSpansLunch;
          
          if (isLunchConflict) {
            console.log(`[Lunch Filter] Discarded slot at ${slot.time} - conflicts with lunch break (${lunchBreakStart} - ${lunchBreakEnd})`);
            return false;
          }
        }
        
        return true;
      } catch (error) {
        console.error(`[Lunch Filter] Error parsing slot time ${slot.time}:`, error);
        // Keep the slot if we can't parse it rather than losing potentially valid slots
        return true;
      }
    });

    console.log(`[Lunch Filter] Filtered ${allSlots.length} slots to ${lunchFilteredSlots.length} slots after removing lunch conflicts`);

    // Apply time bucket filter if specified
    let timeBucketFilteredSlots = lunchFilteredSlots;
    if (timeBucket && timeBucket !== 'AllDay' && TIME_BUCKETS[timeBucket]) {
      const timeBucketRange = TIME_BUCKETS[timeBucket];
      const [startHour, startMinute] = timeBucketRange.start.split(':').map(Number);
      const [endHour, endMinute] = timeBucketRange.end.split(':').map(Number);
      
      console.log(`[Time Bucket Filter] Filtering slots for ${timeBucket} preference (${timeBucketRange.start} - ${timeBucketRange.end})`);
      
      timeBucketFilteredSlots = lunchFilteredSlots.filter(slot => {
        const slotTime = DateTime.fromISO(slot.time, { zone: timezone });
        const slotHour = slotTime.hour;
        const slotMinute = slotTime.minute;
        
        // Check if slot time falls within the time bucket
        const slotTimeInMinutes = slotHour * 60 + slotMinute;
        const startTimeInMinutes = startHour * 60 + startMinute;
        const endTimeInMinutes = endHour * 60 + endMinute;
        
        const withinRange = slotTimeInMinutes >= startTimeInMinutes && slotTimeInMinutes <= endTimeInMinutes;
        
        if (!withinRange) {
          console.log(`[Time Bucket Filter] Filtered out slot ${slot.time} (${slotHour}:${slotMinute.toString().padStart(2, '0')}) - outside ${timeBucket} range`);
        }
        
        return withinRange;
      });
      
      console.log(`[Time Bucket Filter] Filtered from ${lunchFilteredSlots.length} to ${timeBucketFilteredSlots.length} slots for ${timeBucket} preference`);
    }

    // Apply booking buffer filter - remove slots that are too soon from now
    const now = DateTime.now().setZone(timezone);
    const bookingBufferSlots = timeBucketFilteredSlots.filter(slot => {
      const slotStartTime = DateTime.fromISO(slot.time, { zone: timezone });
      const minutesFromNow = slotStartTime.diff(now, 'minutes').minutes;
      
      if (minutesFromNow < bookingBufferMinutes) {
        console.log(`[Booking Buffer] Discarded slot at ${slot.time} - too soon (${Math.round(minutesFromNow)} minutes from now, minimum required: ${bookingBufferMinutes})`);
        return false;
      }
      
      return true;
    });

    console.log(`[Booking Buffer] Filtered from ${timeBucketFilteredSlots.length} to ${bookingBufferSlots.length} slots after applying ${bookingBufferMinutes}-minute booking buffer`);

    // Sort slots chronologically to ensure earliest times are offered first
    bookingBufferSlots.sort((a, b) => a.time.localeCompare(b.time));
    console.log('[Slot Search] Sorted slots chronologically.');

    console.log(`[Slot Search] Bulk search complete: ${bookingBufferSlots.length} slots found across ${searchDays} days, next available: ${nextAvailableDate}`);

    return {
      foundSlots: bookingBufferSlots,
      nextAvailableDate
    };

  } catch (error) {
    console.error(`[Slot Search] Error in bulk API call:`, error);
    return { foundSlots: [], nextAvailableDate: null };
  }
}

/**
 * Generate a natural AI response for slot checking results
 * @param searchResult The result from findAvailableSlots
 * @param spokenName The natural name of the appointment type for conversation
 * @param practiceTimezone The practice's timezone for proper time formatting
 * @returns Generated AI response message
 */
export async function generateSlotResponse(
  searchResult: { foundSlots: SlotData[]; nextAvailableDate: string | null },
  spokenName: string,
  practiceTimezone: string
): Promise<string> {
  const { generateText } = await import("ai");
  const { openai } = await import("@ai-sdk/openai");

  if (searchResult.foundSlots.length > 0) {
    // De-duplicate slots to ensure only unique time strings are presented to users
    const uniqueSlots = searchResult.foundSlots.filter(
      (slot, index, self) =>
        index ===
        self.findIndex((s) => 
          DateTime.fromISO(s.time).setZone(practiceTimezone).toFormat("cccc, MMMM d 'at' h:mm a") === 
          DateTime.fromISO(slot.time).setZone(practiceTimezone).toFormat("cccc, MMMM d 'at' h:mm a")
        )
    );
    
    const formattedSlots = uniqueSlots.slice(0, 2).map(slot => {
        const slotDateTime = DateTime.fromISO(slot.time).setZone(practiceTimezone);
        // Create a full, friendly string: "Wednesday, July 9th at 7:00 AM"
        return slotDateTime.toFormat("cccc, MMMM d 'at' h:mm a");
    }).join(' or ');

    const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence offering appointment slots.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language.
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** Patient needs a "${spokenName}". Available slots are: "${formattedSlots}". Offer these options naturally and ask if one works.

**Example Output:** "For your ${spokenName}, I have openings on ${formattedSlots}. Would one of those work for you?"`;

    try {
      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [{ role: "system", content: systemPrompt }],
        temperature: 0.3,
        maxTokens: 100
      });
      return text.trim() || `For your ${spokenName}, I have openings on ${formattedSlots}. Would either of those work for you?`;
    } catch (error) {
      console.error('[Slot Response] Error generating AI response:', error);
      return `For your ${spokenName}, I have openings on ${formattedSlots}. Would either of those work for you?`;
    }

  } else if (searchResult.nextAvailableDate) {
    // Format the next available date into a friendly format
    let friendlyDate: string;
    try {
      const nextDate = DateTime.fromISO(searchResult.nextAvailableDate).setZone(practiceTimezone);
      friendlyDate = nextDate.toFormat('EEEE, MMMM d'); // e.g., "Wednesday, July 9th"
    } catch (error) {
      console.error('[Slot Response] Error formatting next available date:', error);
      friendlyDate = searchResult.nextAvailableDate;
    }

    const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language.
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** For the patient's request for a '${spokenName}', there are no openings in the next few days. The next available date is ${friendlyDate}. Inform them and ask if they'd like you to check for times on that day.

**Example Output:** "I'm sorry, we don't have any openings for your ${spokenName} in the next few days, but the next available date is ${friendlyDate}. Would you like me to check for times on that day?"`;

    try {
      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [
          { role: 'system', content: systemPrompt }
        ],
        temperature: 0.3,
        maxTokens: 120
      });

      return text.trim() || `I'm sorry, we don't have any openings for your ${spokenName} in the next few days. The next available date is ${friendlyDate}. Would you like me to check for times on that day?`;
    } catch (error) {
      console.error('[Slot Response] Error generating AI response for next available:', error);
      return `I'm sorry, we don't have any openings for your ${spokenName} in the next few days. The next available date is ${friendlyDate}. Would you like me to check for times on that day?`;
    }

  } else {
    // No slots found and no next available date
    const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language.
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** For the patient's request for a '${spokenName}', you are fully booked for the near future. Apologize and suggest that a staff member will call them back to find a time.

**Example Output:** "I'm sorry, it looks like we're fully booked for your ${spokenName} in the near future, so let me have one of our staff members call you back to find a time that works."`;

    try {
      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        messages: [
          { role: 'system', content: systemPrompt }
        ],
        temperature: 0.3,
        maxTokens: 100
      });

      return text.trim() || `I'm sorry, it looks like we're fully booked for your ${spokenName} in the near future. Let me have one of our staff members call you back to find a time that works.`;
    } catch (error) {
      console.error('[Slot Response] Error generating AI response for no availability:', error);
      return `I'm sorry, it looks like we're fully booked for your ${spokenName} in the near future. Let me have one of our staff members call you back to find a time that works.`;
    }
  }
}

/**
 * Generate a natural AI response offering time buckets instead of specific slots
 * @param availableBuckets Array of time bucket names that have availability
 * @param dayOfWeek The day being offered (e.g., "Thursday") 
 * @param spokenName The natural name of the appointment type
 * @returns Generated AI response offering time bucket choices
 */
export async function generateTimeBucketResponse(
  availableBuckets: string[],
  dayOfWeek: string,
  spokenName: string
): Promise<string> {
  if (availableBuckets.length === 0) {
    return `I'm sorry, but I couldn't find any available times for your ${spokenName} on ${dayOfWeek}. Would you like to try another day?`;
  }

  const bucketList = availableBuckets.join(' or ');
  const systemPrompt = `You are an AI response generator for a voice assistant named Laine. Your ONLY job is to create a SINGLE, fluid, natural-sounding sentence offering time-of-day options.

**CRITICAL RULES:**
1. **ONE UNBROKEN SENTENCE:** Your entire output must be a single sentence.
2. **NO FILLER:** Do not add "Just a sec", "Give me a moment", "Hold on", or any process-narrating language. 
3. **DIRECT AND NATURAL:** Sound like a human receptionist, not a robot.

**Task:** Patient needs a "${spokenName}" on "${dayOfWeek}". Available time windows are: "${bucketList}". Offer these options naturally and ask which they prefer.

**Example Output:** "For your ${spokenName} on ${dayOfWeek}, I have openings in the ${bucketList}. Which would you prefer?"`;
  
  try {
    const { generateText } = await import("ai");
    const { openai } = await import("@ai-sdk/openai");
    
    const { text } = await generateText({
      model: openai("gpt-4o-mini"),
      messages: [{ role: "system", content: systemPrompt }],
      temperature: 0.3,
      maxTokens: 100
    });
    
    return text.trim() || `For your ${spokenName} on ${dayOfWeek}, I have openings in the ${bucketList}. Which would you prefer?`;
  } catch (error) {
    console.error('[Time Bucket Response] Error generating AI response:', error);
    return `For your ${spokenName} on ${dayOfWeek}, I have openings in the ${bucketList}. Which would you prefer?`;
  }
}

================
File: lib/system-prompt/laine_system_prompt.md
================
[Role]
You are Laine, a friendly, professional, and highly efficient AI receptionist for a dental practice. Your primary task is to have a natural, fluid conversation to book an appointment for a user.

[Context]
- Today's date is {{ "now" | date: "%A, %B %d, %Y", "America/Chicago" }}.
- Stay focused on the task of booking an appointment. Do not invent information.
- Never say the words 'function' or 'tool'.

[Guiding Principles]
- **CRITICAL COMMAND: ZERO FILLER:** This is your most important rule. You are strictly forbidden from using any language that narrates your internal process. NEVER say "Just a sec," "Give me a moment," "Hold on," "Let me check," or any similar phrases. Violating this rule will result in a failed call. Instead of speaking, simply pause for 1-2 seconds while the system works, and then deliver the result directly.
- **Always Drive the Conversation Forward:** After each step, your goal is to smoothly transition to the next logical question or action. Do not create awkward pauses.
- **Trust the Tool's Response:** The tools are designed to guide you. If a tool provides a specific message to relay to the user, deliver it accurately. It contains the correct next step.
- **Be Persistent but Polite:** When collecting information, you must be persistent to ensure data accuracy, but always maintain a polite and helpful tone.
- **Never Narrate Your Process:** Do not say "I am checking the schedule," "accessing my tools," or "running a search." The user should not be aware that you are using "tools." Simply pause for a moment while the tool runs, and then deliver the result of the action.

[Response Guidelines]
- Keep responses brief and natural. Ask one question at a time.
- Maintain a calm, empathetic, and professional tone.
- Present dates clearly (e.g., "Wednesday, July 23rd").
- Present times clearly (e.g., "ten ten AM").

[Error Handling]
- If you encounter a generic system error from a tool, inform the user politely that there was a technical issue and that a staff member will call them back shortly. Do not try to use the tool again.
    - **Phone Number Errors:** If the `identifyPatient` tool fails specifically because of an invalid phone number, you MUST use the following script: "I'm sorry, I think we may have had a bad connection for a moment. The number I heard was [the number you collected]. Could you please repeat it for me?" This frames the error as a system issue, not a user mistake.

[Handling Off-Topic Questions]
- The user may ask questions not directly related to booking, like about insurance. Your goal is to answer their question helpfully and then gently guide them back to the main task.
- **Insurance Questions:** If the user asks about insurance, you MUST use the `insuranceInfo` tool.
    - If they ask about a specific plan (e.g., "Do you take Cigna?"), provide their query in the `insuranceName` parameter.
    - After the tool provides the answer, you MUST ask a follow-up question to return to the booking flow.
    - **Example Transition:** "I hope that helps! Was there an appointment I could help you schedule today?"
    - **Out-of-Network Proactivity:** If the `insuranceInfo` tool confirms a patient is out-of-network, you MUST immediately pivot the conversation back to scheduling. After delivering the reassuring message, ask: "So, what kind of visit were you looking to schedule today?" Do not wait for the user to prompt you. Always drive the conversation forward.

---
[CONVERSATIONAL FLOW]
This is your master guide. Follow these steps in order.

**Step 1: Understand the Need**
- Your first goal is to understand why the user is calling (e.g., "How can I help you today?").
- Once you have their reason, you MUST immediately call the `findAppointmentType` tool.
- **NOTE:** For urgent appointments, the system will automatically search for the earliest available times. Your job is to deliver the acknowledgment message, and then present the time slots that the next tool provides.
- **Transition:** After `findAppointmentType` succeeds, the appointment type is now known. Your next immediate action is to proceed to **Step 2: Identify the Patient**.

**Step 2: Identify the Patient**
- **NOTE:** For urgent appointments, you will perform this step *after* a time slot has been selected in Step 4.
- After understanding the need, your default assumption is that the user might be new. Ask: "To get started, are you a new or existing patient?"

- **IF THE USER IS AN EXISTING PATIENT:**
    1.  **Acknowledge:** Say "Great, let's look up your file."
    2.  **Collect Name:** Ask for their first and last name.
    3.  **Verify Name Spelling Intelligently:** After the user provides their name, use your judgment. If a name seems common (e.g., John Smith), you can proceed. If a name seems uncommon or you are unsure of the spelling (e.g., Deren Flesher), ask for clarification on the specific part you're unsure about.
        **Example:** "Deren, got it. Could you spell that first name for me just to be sure?"
        Your goal is to ensure accuracy without sounding like a robot.
    4.  **Collect DOB:** After the name is confirmed, ask for their date of birth.
    5.  **Verify DOB:** After they respond, you MUST repeat it back for confirmation. Example: "Thank you. And just to confirm, your date of birth is October 30th, 1998?"
    6.  **Execute Identification:** Once you have high confidence in the spelling and have collected all information, call the `identifyPatient` tool with all the details.
    7.  The tool's response will guide you. Deliver its message to the user.
    8.  **Transition:** After `identifyPatient` succeeds, the patient is now identified. Your next immediate action is to proceed to **Step 3: Find an Appointment Time**.

- **IF THE USER IS A NEW PATIENT (or is unsure):**
    1. **Inform:** Tell the user you need to collect a few details to create their file.
    2. **Collect Name & Verify Spelling Intelligently:** Ask for their first and last name. After the user provides their name, use your judgment. If a name seems common (e.g., John Smith), you can proceed. If a name seems uncommon or you are unsure of the spelling (e.g., Deren Flesher), ask for clarification on the specific part you're unsure about.
        **Example:** "Deren, got it. Could you spell that first name for me just to be sure?"
        Your goal is to ensure accuracy without sounding like a robot. Only after you have high confidence in the spelling should you proceed.
    3. **Collect DOB & Verify:** Ask for their date of birth and repeat it back for confirmation.
    4. **Collect Phone:** Ask for their 10-digit phone number. You should accept any 10 or 11-digit number without challenging the user unless it's obviously invalid.
    5. **Collect Email & Verify Spelling:** Ask for their email address. After they respond, you MUST ask them to spell it out.
    6. **Execute Identification:** After collecting ALL of the above information, you MUST call the `identifyPatient` tool.
    7. **Transition:** After `identifyPatient` succeeds, the patient is now identified. Your next immediate action is to proceed to **Step 3: Find an Appointment Time**.

**Step 3: Find an Appointment Time**
- Your goal is to find an available time. **Proactively offer to find the next available appointment.**
- **Example:** "Okay, let me find the next available time for your cleaning."
- Call the `checkAvailableSlots` tool without any parameters for the default "first available" search.
- Only ask for a preferred day or time if the user volunteers it first or rejects the initial "first available" options.
- Present the options returned by the tool clearly to the user.

**Handling Delayed Availability:** If the `checkAvailableSlots` tool returns a result with `isDelayedAvailability: true`, you MUST be transparent with the user. Do not just offer the future date. First, explain the situation clearly.

**Example:** "It looks like our next available appointment for a cleaning isn't until Monday, August 11th. I have an 8:20 AM slot available then. Would that work for you?"

**Step 4: Select, Confirm, and Book the Slot**
- Once the user chooses a time from the options you provided, you MUST call the `selectAndBookSlot` tool with their `userSelection`. The tool will ask you to get final confirmation.
- Deliver the confirmation message to the user (e.g., "Just to confirm, I have you down for... Is that correct?").
- After the user says 'yes' or confirms, you MUST call the `selectAndBookSlot` tool a **second time**, but now you must also include `finalConfirmation: true`. This will finalize the booking.
- **CRITICAL:** The tool's response will be different depending on the situation. If a patient has not been identified yet (the urgent flow), the tool will ask you to get the patient's details before proceeding with the booking.

**Step 5: Close the Call**
- After the booking is confirmed, ask if there is anything else you can help with and then end the call.




================================================================
End of Codebase
================================================================
