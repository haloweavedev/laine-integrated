This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: scripts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  (auth)/
    sign-in/
      [[...sign-in]]/
        page.tsx
    sign-up/
      [[...sign-up]]/
        page.tsx
  api/
    laine-config/
      recent-tool-logs/
        route.ts
      update/
        route.ts
    nexhealth-webhook/
      route.ts
    practice-config/
      appointment-types/
        [appointmentTypeId]/
          route.ts
        route.ts
      basic/
        route.ts
      check-slots/
        route.ts
      data/
        route.ts
      provider-settings/
        [savedProviderId]/
          route.ts
      providers/
        activate/
          route.ts
      quick-review/
        route.ts
      webhook-status/
        route.ts
      webhook-sync/
        route.ts
    sync-nexhealth/
      route.ts
    vapi/
      tool-calls/
        route.ts
      webhook/
        route.ts
    webhook-subscribe/
      route.ts
  laine/
    laine-practice-client.tsx
    page.tsx
  practice-config/
    AppointmentTypesConfig.tsx
    CheckAppointmentSlotsTool.tsx
    page.tsx
    ProvidersConfig.tsx
    QuickReview.tsx
  test/
    actions.ts
    page.tsx
    test-client.tsx
  tool-calls/
    page.tsx
  globals.css
  layout.tsx
  page.tsx
lib/
  ai/
    summarization.ts
  tools/
    bookAppointment.ts
    checkAvailableSlots.ts
    checkInsuranceParticipation.ts
    createNewPatient.ts
    findAppointmentType.ts
    findPatient.ts
    getPracticeDetails.ts
    getServiceCostEstimate.ts
    index.ts
    types.ts
  utils/
    error-messages.ts
  nexhealth.ts
  prisma.ts
  vapi.ts
  webhook-utils.ts
prisma/
  schema.prisma
.gitignore
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: app/(auth)/sign-in/[[...sign-in]]/page.tsx
================
import { SignIn } from '@clerk/nextjs';

export default function SignInPage() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <SignIn />
    </div>
  );
}

================
File: app/(auth)/sign-up/[[...sign-up]]/page.tsx
================
import { SignUp } from '@clerk/nextjs';

export default function SignUpPage() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <SignUp />
    </div>
  );
}

================
File: app/api/laine-config/recent-tool-logs/route.ts
================
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Get the practice
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      select: { id: true }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Find the most recent vapiCallId that has tool logs for this practice
    const latestCallWithLogs = await prisma.toolLog.findFirst({
      where: { practiceId: practice.id },
      orderBy: { createdAt: 'desc' },
      select: { vapiCallId: true }
    });

    if (!latestCallWithLogs?.vapiCallId) {
      return NextResponse.json({ logs: [] });
    }

    // Fetch all logs for the most recent call with logs
    const recentLogs = await prisma.toolLog.findMany({
      where: {
        practiceId: practice.id,
        vapiCallId: latestCallWithLogs.vapiCallId
      },
      orderBy: { createdAt: 'asc' }, // Show tools in execution order for that call
      select: {
        id: true,
        toolName: true,
        arguments: true,
        result: true,
        success: true,
        error: true,
        executionTimeMs: true,
        createdAt: true,
        toolCallId: true
      }
    });

    // Transform the data to parse JSON strings and make it more client-friendly
    const transformedLogs = recentLogs.map(log => {
      let parsedArguments = null;
      let parsedResult = null;

      try {
        parsedArguments = log.arguments ? JSON.parse(log.arguments) : null;
      } catch (error) {
        console.warn(`Failed to parse arguments for tool log ${log.id}:`, error);
        parsedArguments = log.arguments;
      }

      try {
        parsedResult = log.result ? JSON.parse(log.result) : null;
      } catch (error) {
        console.warn(`Failed to parse result for tool log ${log.id}:`, error);
        parsedResult = log.result;
      }

      return {
        id: log.id,
        toolName: log.toolName,
        arguments: parsedArguments,
        result: parsedResult,
        success: log.success,
        error: log.error,
        executionTimeMs: log.executionTimeMs,
        createdAt: log.createdAt,
        toolCallId: log.toolCallId
      };
    });

    return NextResponse.json({ 
      logs: transformedLogs,
      callId: latestCallWithLogs.vapiCallId,
      totalLogs: transformedLogs.length
    });
  } catch (error) {
    console.error("Error fetching recent tool logs:", error);
    return NextResponse.json(
      { error: `Failed to fetch tool logs: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}

================
File: app/api/laine-config/update/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { updateVapiAssistant } from "@/lib/vapi";
import { buildVapiTools } from "@/lib/tools";

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    const body = await request.json();
    const { voiceProvider, voiceId, systemPrompt, firstMessage } = body;

    if (!voiceProvider || !voiceId || !systemPrompt || !firstMessage) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    // Get the practice with assistant config
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: { assistantConfig: true }
    });

    if (!practice || !practice.assistantConfig?.vapiAssistantId) {
      return NextResponse.json({ error: "Practice or assistant not found" }, { status: 404 });
    }

    const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    const tools = buildVapiTools(appBaseUrl);
    
    // Update VAPI assistant with new configuration
    const updateConfig = {
      model: {
        provider: "openai" as const,
        model: "gpt-4.1-nano-2025-04-14",
        temperature: 0.7,
        messages: [
          {
            role: "system" as const,
            content: systemPrompt
          }
        ],
        tools
      },
      voice: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        provider: voiceProvider as any,
        voiceId: voiceId
      },
      firstMessage: firstMessage
    };

    console.log("Updating VAPI assistant:", practice.assistantConfig.vapiAssistantId);
    await updateVapiAssistant(practice.assistantConfig.vapiAssistantId, updateConfig);
    
    // Update our database
    await prisma.practiceAssistantConfig.update({
      where: { practiceId: practice.id },
      data: {
        voiceProvider,
        voiceId,
        systemPrompt,
        firstMessage,
        updatedAt: new Date()
      }
    });

    console.log(`Successfully updated VAPI assistant for practice ${practice.id}`);
    
    return NextResponse.json({ success: true, message: "Assistant configuration updated successfully" });
  } catch (error) {
    console.error("Error updating VAPI assistant:", error);
    return NextResponse.json(
      { error: `Failed to update assistant: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/providers/activate/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

const activateProviderSchema = z.object({
  providerIds: z.array(z.string()).min(1, "At least one provider ID is required")
});

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const validationResult = activateProviderSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { providerIds } = validationResult.data;

    // Get the practice
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Verify all provider IDs belong to this practice
    const providers = await prisma.provider.findMany({
      where: {
        id: { in: providerIds },
        practiceId: practice.id
      }
    });

    if (providers.length !== providerIds.length) {
      return NextResponse.json({
        error: "Some providers don't belong to this practice"
      }, { status: 400 });
    }

    // Create SavedProvider records for each provider
    const savedProviderPromises = providers.map(provider =>
      prisma.savedProvider.upsert({
        where: {
          practiceId_providerId: {
            practiceId: practice.id,
            providerId: provider.id
          }
        },
        update: {
          isActive: true
        },
        create: {
          practiceId: practice.id,
          providerId: provider.id,
          isActive: true
        }
      })
    );

    const savedProviders = await Promise.all(savedProviderPromises);

    return NextResponse.json({
      success: true,
      message: `Successfully activated ${savedProviders.length} provider(s)`,
      activatedProviders: savedProviders.length
    });

  } catch (error) {
    console.error("Error activating providers:", error);
    return NextResponse.json(
      { error: "Failed to activate providers" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/quick-review/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Execute all queries in parallel for better performance
    const [appointmentsBookedByLaine, activeProvidersCount, appointmentTypesCount] = await Promise.all([
      // Count appointments booked via Laine
      prisma.callLog.count({
        where: {
          practiceId: practice.id,
          bookedAppointmentNexhealthId: {
            not: null
          }
        }
      }),

      // Count active providers
      prisma.savedProvider.count({
        where: {
          practiceId: practice.id,
          isActive: true
        }
      }),

      // Count appointment types created
      prisma.appointmentType.count({
        where: {
          practiceId: practice.id
        }
      })
    ]);

    return NextResponse.json({
      appointmentsBookedByLaine,
      activeProvidersCount,
      appointmentTypesCount
    });

  } catch (error) {
    console.error("Error fetching quick review data:", error);
    return NextResponse.json(
      { error: "Failed to fetch quick review data" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/webhook-status/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      select: {
        id: true,
        name: true,
        webhookLastSyncAt: true,
        webhookLastSuccessfulSyncAt: true,
        webhookSyncErrorMsg: true,
        nexhealthSubdomain: true,
        nexhealthLocationId: true,
        nexhealthWebhookSubscriptions: {
          where: { isActive: true },
          select: {
            resourceType: true,
            eventName: true,
            nexhealthSubscriptionId: true,
            createdAt: true
          }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Determine sync status based on new fields
    let lastSyncStatus: string;

    if (practice.webhookSyncErrorMsg) {
      lastSyncStatus = "ERROR";
    } else if (practice.webhookLastSuccessfulSyncAt) {
      lastSyncStatus = "SYNCED";
    } else if (practice.webhookLastSyncAt) {
      lastSyncStatus = "SYNC_IN_PROGRESS";
    } else {
      lastSyncStatus = "NEVER_SYNCED";
    }

    // Check if practice has basic configuration
    const hasBasicConfig = !!(practice.nexhealthSubdomain && practice.nexhealthLocationId);

    return NextResponse.json({
      lastSyncAttemptAt: practice.webhookLastSyncAt,
      lastSyncSuccessAt: practice.webhookLastSuccessfulSyncAt,
      lastSyncStatus,
      lastSyncErrorMessage: practice.webhookSyncErrorMsg,
      hasBasicConfig,
      activeSubscriptionsCount: practice.nexhealthWebhookSubscriptions.length,
      subscriptions: practice.nexhealthWebhookSubscriptions.map(sub => ({
        resourceType: sub.resourceType,
        eventName: sub.eventName,
        subscribedAt: sub.createdAt
      })),
      subscriptionCounts: {
        appointment: practice.nexhealthWebhookSubscriptions.filter(s => s.resourceType === 'Appointment').length,
        availability: practice.nexhealthWebhookSubscriptions.filter(s => s.resourceType === 'Availability').length,
        patient: practice.nexhealthWebhookSubscriptions.filter(s => s.resourceType === 'Patient').length,
        provider: practice.nexhealthWebhookSubscriptions.filter(s => s.resourceType === 'Provider').length,
        location: practice.nexhealthWebhookSubscriptions.filter(s => s.resourceType === 'Location').length,
      }
    });

  } catch (error) {
    console.error("Error fetching webhook status:", error);
    return NextResponse.json(
      { error: "Failed to fetch webhook status" },
      { status: 500 }
    );
  }
}

================
File: app/api/vapi/webhook/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { verifyVapiRequest } from "@/lib/vapi";
import { prisma } from "@/lib/prisma";

export async function POST(request: NextRequest) {
  console.log("=== VAPI General Webhook Handler ===");
  
  try {
    // Verify the webhook (when VAPI supports request signing)
    const verification = await verifyVapiRequest();
    if (!verification.verified) {
      console.error("VAPI webhook verification failed:", verification.error);
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const payload = await request.json();
    console.log("VAPI webhook payload type:", payload.type);
    console.log("VAPI webhook payload:", JSON.stringify(payload, null, 2));

    // Handle different webhook types
    switch (payload.type) {
      case "status-update":
        await handleStatusUpdate(payload);
        break;
      
      case "end-of-call-report":
        await handleEndOfCallReport(payload);
        break;
      
      case "transcript":
        await handleTranscript(payload);
        break;
      
      default:
        console.log(`Unhandled VAPI webhook type: ${payload.type}`);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error processing VAPI webhook:", error);
    return NextResponse.json(
      { error: "Internal server error" }, 
      { status: 500 }
    );
  }
}

async function handleStatusUpdate(payload: { call?: { id: string; assistantId: string; status: string; startedAt?: string } }) {
  console.log("Handling status update:", payload.call?.status);
  
  try {
    if (!payload.call) {
      console.error("No call data in status update payload");
      return;
    }

    // Find practice by assistant ID
    const practice = await findPracticeByAssistantId(payload.call.assistantId);
    if (!practice) {
      console.error("Practice not found for assistant:", payload.call.assistantId);
      return;
    }

    // Update or create call log
    await prisma.callLog.upsert({
      where: { vapiCallId: payload.call.id },
      create: {
        vapiCallId: payload.call.id,
        practiceId: practice.id,
        assistantId: payload.call.assistantId,
        callTimestampStart: payload.call.startedAt ? new Date(payload.call.startedAt) : null,
        callStatus: payload.call.status,
      },
      update: {
        callStatus: payload.call.status,
        assistantId: payload.call.assistantId,
        updatedAt: new Date()
      }
    });

    console.log(`Updated call status for ${payload.call.id}: ${payload.call.status}`);
  } catch (error) {
    console.error("Error handling status update:", error);
  }
}

async function handleEndOfCallReport(payload: { 
  call?: { 
    id: string; 
    assistantId: string; 
    startedAt?: string; 
    endedAt?: string; 
    endedReason?: string; 
    cost?: string 
  }; 
  summary?: string; 
  transcript?: { url?: string } 
}) {
  console.log("Handling end of call report");
  
  try {
    if (!payload.call) {
      console.error("No call data in end-of-call-report payload");
      return;
    }

    // Find practice by assistant ID
    const practice = await findPracticeByAssistantId(payload.call.assistantId);
    if (!practice) {
      console.error("Practice not found for assistant:", payload.call.assistantId);
      return;
    }

    // Update call log with final details
    await prisma.callLog.upsert({
      where: { vapiCallId: payload.call.id },
      create: {
        vapiCallId: payload.call.id,
        practiceId: practice.id,
        assistantId: payload.call.assistantId,
        callTimestampStart: payload.call.startedAt ? new Date(payload.call.startedAt) : null,
        callStatus: "ENDED",
        endedReason: payload.call.endedReason,
        callDurationSeconds: payload.call.startedAt && payload.call.endedAt 
          ? Math.round((new Date(payload.call.endedAt).getTime() - new Date(payload.call.startedAt).getTime()) / 1000)
          : null,
        cost: payload.call.cost ? parseFloat(payload.call.cost) : null,
        summary: payload.summary,
        vapiTranscriptUrl: payload.transcript?.url,
      },
      update: {
        callStatus: "ENDED",
        endedReason: payload.call.endedReason,
        callDurationSeconds: payload.call.startedAt && payload.call.endedAt 
          ? Math.round((new Date(payload.call.endedAt).getTime() - new Date(payload.call.startedAt).getTime()) / 1000)
          : null,
        cost: payload.call.cost ? parseFloat(payload.call.cost) : null,
        summary: payload.summary,
        vapiTranscriptUrl: payload.transcript?.url,
        updatedAt: new Date()
      }
    });

    console.log(`Updated end of call report for ${payload.call.id}`);
  } catch (error) {
    console.error("Error handling end of call report:", error);
  }
}

async function handleTranscript(payload: { 
  call?: { 
    id: string; 
    assistantId: string; 
    startedAt?: string; 
    status?: string 
  }; 
  transcript?: { text?: string } 
}) {
  console.log("Handling transcript update");
  
  try {
    if (!payload.call) {
      console.error("No call data in transcript payload");
      return;
    }

    // Find practice by assistant ID
    const practice = await findPracticeByAssistantId(payload.call.assistantId);
    if (!practice) {
      console.error("Practice not found for assistant:", payload.call.assistantId);
      return;
    }

    // Update call log with transcript
    await prisma.callLog.upsert({
      where: { vapiCallId: payload.call.id },
      create: {
        vapiCallId: payload.call.id,
        practiceId: practice.id,
        assistantId: payload.call.assistantId,
        callTimestampStart: payload.call.startedAt ? new Date(payload.call.startedAt) : null,
        callStatus: payload.call.status || "IN_PROGRESS",
        transcriptText: payload.transcript?.text,
      },
      update: {
        transcriptText: payload.transcript?.text,
        updatedAt: new Date()
      }
    });

    console.log(`Updated transcript for ${payload.call.id}`);
  } catch (error) {
    console.error("Error handling transcript:", error);
  }
}

async function findPracticeByAssistantId(assistantId: string) {
  if (!assistantId) {
    console.error("No assistant ID provided");
    return null;
  }

  try {
    const assistantConfig = await prisma.practiceAssistantConfig.findUnique({
      where: { vapiAssistantId: assistantId },
      include: { practice: true }
    });

    if (!assistantConfig) {
      console.error(`No practice found for assistant ID: ${assistantId}`);
      return null;
    }

    return assistantConfig.practice;
  } catch (error) {
    console.error("Error finding practice by assistant ID:", error);
    return null;
  }
}

================
File: app/laine/laine-practice-client.tsx
================
"use client";

import { useState, useEffect } from "react";
import { toast } from "sonner";

interface Practice {
  id: string;
  name: string | null;
  assistantConfig: {
    id: string;
    vapiAssistantId: string | null;
    voiceProvider: string;
    voiceId: string;
    systemPrompt: string;
    firstMessage: string;
  } | null;
}

interface ToolResult {
  message_to_patient?: string;
  error_code?: string;
  details?: string;
  success?: boolean;
  data?: Record<string, unknown>;
  [key: string]: unknown;
}

interface ToolLog {
  id: string;
  toolName: string;
  arguments: Record<string, unknown> | null;
  result: ToolResult | null;
  success: boolean;
  error: string | null;
  executionTimeMs: number | null;
  createdAt: string;
  toolCallId: string;
}

interface LainePracticeClientProps {
  practice: Practice;
  hasAssistant: boolean;
  createPracticeAssistant: () => Promise<void>;
}

export function LainePracticeClient({ practice, hasAssistant, createPracticeAssistant }: LainePracticeClientProps) {
  const [voiceProvider, setVoiceProvider] = useState(practice.assistantConfig?.voiceProvider || "vapi");
  const [voiceId, setVoiceId] = useState(practice.assistantConfig?.voiceId || "Elliot");
  const [systemPrompt, setSystemPrompt] = useState(practice.assistantConfig?.systemPrompt || "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.");
  const [firstMessage, setFirstMessage] = useState(practice.assistantConfig?.firstMessage || "Hello! This is Laine from your dental office. How can I help you today?");
  const [isUpdating, setIsUpdating] = useState(false);
  const [toolLogs, setToolLogs] = useState<ToolLog[]>([]);
  const [isLoadingLogs, setIsLoadingLogs] = useState(true);
  const [callId, setCallId] = useState<string | null>(null);

  useEffect(() => {
    const fetchLogs = async () => {
      setIsLoadingLogs(true);
      try {
        const response = await fetch('/api/laine-config/recent-tool-logs');
        if (response.ok) {
          const data = await response.json();
          setToolLogs(data.logs || []);
          setCallId(data.callId || null);
        } else {
          toast.error("Failed to fetch recent tool logs.");
        }
      } catch (error) {
        console.error("Error fetching tool logs:", error);
        toast.error("Error fetching tool logs.");
      } finally {
        setIsLoadingLogs(false);
      }
    };
    fetchLogs();
  }, []);

  const handleUpdateConfig = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsUpdating(true);

    try {
      const response = await fetch('/api/laine-config/update', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          voiceProvider,
          voiceId,
          systemPrompt,
          firstMessage,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update assistant configuration');
      }

      toast.success("Assistant configuration updated successfully!");
    } catch (error) {
      console.error('Error updating assistant configuration:', error);
      toast.error(`Failed to update assistant configuration. ${error instanceof Error ? error.message : 'Please try again.'}`);
    } finally {
      setIsUpdating(false);
    }
  };

  if (!hasAssistant) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">Create Your AI Assistant</h2>
        <p className="text-gray-600 mb-6">
          Create a personalized AI assistant for your practice. Laine will help patients with basic inquiries,
          patient lookups, and appointment scheduling.
        </p>
        
        <form action={createPracticeAssistant}>
          <button
            type="submit"
            className="bg-blue-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-blue-700 transition-colors"
          >
            Create Laine Assistant
          </button>
        </form>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-6">Configure Your AI Assistant</h2>
      
      <form onSubmit={handleUpdateConfig} className="space-y-6">
        <div>
          <label htmlFor="voiceProvider" className="block text-sm font-medium text-gray-700 mb-2">
            Voice Provider
          </label>
          <select
            id="voiceProvider"
            name="voiceProvider"
            value={voiceProvider}
            onChange={(e) => setVoiceProvider(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="vapi">VAPI (Recommended)</option>
            <option value="11labs">ElevenLabs</option>
            <option value="openai">OpenAI</option>
            <option value="playht">PlayHT</option>
          </select>
        </div>

        <div>
          <label htmlFor="voiceId" className="block text-sm font-medium text-gray-700 mb-2">
            Voice ID
          </label>
          <input
            type="text"
            id="voiceId"
            name="voiceId"
            value={voiceId}
            onChange={(e) => setVoiceId(e.target.value)}
            placeholder="e.g., Elliot, Kylie (VAPI), burt (ElevenLabs), alloy (OpenAI)"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <p className="text-sm text-gray-500 mt-1">
            <strong>VAPI:</strong> Elliot, Kylie &nbsp;|&nbsp; 
            <strong>ElevenLabs:</strong> burt &nbsp;|&nbsp; 
            <strong>OpenAI:</strong> alloy, echo, fable, onyx, nova, shimmer
          </p>
        </div>

        <div>
          <label htmlFor="systemPrompt" className="block text-sm font-medium text-gray-700 mb-2">
            System Prompt
          </label>
          <textarea
            id="systemPrompt"
            name="systemPrompt"
            rows={4}
            value={systemPrompt}
            onChange={(e) => setSystemPrompt(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Instructions that define how the AI should behave..."
          />
          <p className="text-sm text-gray-500 mt-1">
            Define how Laine should behave and what it should know about your practice
          </p>
        </div>

        <div>
          <label htmlFor="firstMessage" className="block text-sm font-medium text-gray-700 mb-2">
            First Message
          </label>
          <input
            type="text"
            id="firstMessage"
            name="firstMessage"
            value={firstMessage}
            onChange={(e) => setFirstMessage(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Hello! This is Laine from your dental office..."
          />
          <p className="text-sm text-gray-500 mt-1">
            The first thing Laine says when answering a call
          </p>
        </div>

        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-500">
            Assistant ID: {practice.assistantConfig?.vapiAssistantId}
          </div>
          <button
            type="submit"
            disabled={isUpdating}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isUpdating ? 'Updating...' : 'Update Configuration'}
          </button>
        </div>
      </form>

      <div className="mt-8 p-4 bg-gray-50 rounded-lg">
        <h3 className="font-medium text-gray-900 mb-2">Available Tools (8)</h3>
        <ul className="text-sm text-gray-600 space-y-1 list-disc list-inside">
          <li>find_patient_in_ehr - Searches for existing patients.</li>
          <li>create_new_patient - Creates new patient records (now with optional insurance name).</li>
          <li>find_appointment_type - Matches patient requests to appointment types.</li>
          <li>check_available_slots - Finds available appointment times.</li>
          <li>book_appointment - Books the selected appointment.</li>
          <li>check_insurance_participation - Checks if practice accepts patient&apos;s insurance.</li>
          <li>get_service_cost_estimate - Provides estimated service costs.</li>
          <li>get_practice_details - Retrieves practice address and other details.</li>
        </ul>
      </div>

      {/* Recent Tool Call Activity Section */}
      <div className="mt-8 p-4 bg-blue-50 rounded-lg">
        <h3 className="font-medium text-gray-900 mb-4">Recent Tool Call Activity</h3>
        {isLoadingLogs && (
          <p className="text-sm text-gray-600">Loading recent activity...</p>
        )}
        {!isLoadingLogs && toolLogs.length === 0 && (
          <p className="text-sm text-gray-600">No recent tool call activity found.</p>
        )}
        {!isLoadingLogs && toolLogs.length > 0 && (
          <div className="space-y-4">
            {callId && (
              <p className="text-xs text-gray-500 mb-3">
                Call ID: {callId} • {toolLogs.length} tool{toolLogs.length !== 1 ? 's' : ''} executed
              </p>
            )}
            {toolLogs.map((log) => (
              <div key={log.id} className="p-3 bg-white rounded border border-gray-200">
                <div className="flex justify-between items-start mb-2">
                  <h4 className="font-semibold text-sm text-gray-900">{log.toolName}</h4>
                  <div className="flex items-center space-x-2 text-xs text-gray-500">
                    <span className={`px-2 py-1 rounded ${log.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                      {log.success ? 'Success' : 'Failed'}
                    </span>
                    <span>{new Date(log.createdAt).toLocaleTimeString()}</span>
                    {log.executionTimeMs && <span>{log.executionTimeMs}ms</span>}
                  </div>
                </div>
                
                {/* Arguments */}
                {log.arguments && (
                  <div className="mb-2">
                    <p className="text-xs font-medium text-gray-700 mb-1">Arguments:</p>
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(log.arguments, null, 2)}
                    </pre>
                  </div>
                )}

                {/* Result */}
                {log.result && (
                  <div className="mb-2">
                    <p className="text-xs font-medium text-gray-700 mb-1">Result:</p>
                    {log.result?.message_to_patient && (
                      <p className="text-sm italic text-blue-600 mb-1">
                        To Patient: &quot;{log.result.message_to_patient}&quot;
                      </p>
                    )}
                    {log.result?.error_code && (
                      <p className="text-sm text-red-600 mb-1">
                        Error: {log.result.error_code} - {log.result.details || 'No details'}
                      </p>
                    )}
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(log.result, null, 2)}
                    </pre>
                  </div>
                )}

                {/* Error (if failed) */}
                {log.error && (
                  <div className="text-xs text-red-600 bg-red-50 p-2 rounded">
                    <strong>Error:</strong> {log.error}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: app/practice-config/CheckAppointmentSlotsTool.tsx
================
"use client";

import { useState } from "react";
import { toast } from "sonner";

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  bookableOnline: boolean | null;
  groupCode: string | null;
}

interface Provider {
  id: string;
  nexhealthProviderId: string;
  firstName: string | null;
  lastName: string;
}

interface SavedProvider {
  id: string;
  providerId: string;
  isActive: boolean;
  provider: Provider;
}

interface SavedOperatory {
  id: string;
  nexhealthOperatoryId: string;
  name: string;
  isActive: boolean;
}

interface AppointmentSlot {
  slot_id: string;
  time: string;
  end_time: string;
  display_time: string;
  display_end_time: string;
  display_range: string;
  operatory_id?: number;
  provider_id: number;
  location_id: number;
  provider_info: {
    id: string;
    name: string;
    nexhealthProviderId: string;
  };
  operatory_info: {
    id: string;
    name: string;
    nexhealthOperatoryId: string;
  } | null;
}

interface CheckSlotsResponse {
  success: boolean;
  data: {
    requested_date: string;
    appointment_type: {
      id: string;
      name: string;
      duration: number;
    };
    available_slots: AppointmentSlot[];
    has_availability: boolean;
    total_slots_found: number;
    debug_info: {
      providers_checked: number;
      operatories_checked: number;
      providers_used: Array<{
        id: string;
        name: string;
        nexhealthProviderId: string;
      }>;
      operatories_used: Array<{
        id: string;
        name: string;
        nexhealthOperatoryId: string;
      }>;
    };
  };
}

interface CheckAppointmentSlotsToolProps {
  appointmentTypes: AppointmentType[];
  savedProviders: SavedProvider[];
  savedOperatories: SavedOperatory[];
}

export function CheckAppointmentSlotsTool({
  appointmentTypes,
  savedProviders,
  savedOperatories
}: CheckAppointmentSlotsToolProps) {
  const [selectedAppointmentTypeId, setSelectedAppointmentTypeId] = useState<string>("");
  const [selectedDate, setSelectedDate] = useState<string>("");
  const [selectedProviderIds, setSelectedProviderIds] = useState<string[]>([]);
  const [selectedOperatoryIds, setSelectedOperatoryIds] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [slotsData, setSlotsData] = useState<CheckSlotsResponse["data"] | null>(null);

  // Get today's date in YYYY-MM-DD format
  const today = new Date().toISOString().split('T')[0];

  // Filter active providers and operatories
  const activeProviders = savedProviders.filter(sp => sp.isActive);
  const activeOperatories = savedOperatories.filter(so => so.isActive);

  const handleProviderChange = (savedProviderId: string, checked: boolean) => {
    if (checked) {
      setSelectedProviderIds(prev => [...prev, savedProviderId]);
    } else {
      setSelectedProviderIds(prev => prev.filter(id => id !== savedProviderId));
    }
  };

  const handleOperatoryChange = (operatoryId: string, checked: boolean) => {
    if (checked) {
      setSelectedOperatoryIds(prev => [...prev, operatoryId]);
    } else {
      setSelectedOperatoryIds(prev => prev.filter(id => id !== operatoryId));
    }
  };

  const handleCheckSlots = async () => {
    if (!selectedAppointmentTypeId) {
      toast.error("Please select an appointment type");
      return;
    }

    if (!selectedDate) {
      toast.error("Please select a date");
      return;
    }

    // Validate date is not in the past
    if (selectedDate < today) {
      toast.error("Please select a current or future date");
      return;
    }

    setLoading(true);
    try {
      const requestBody: { 
        appointmentTypeId: string; 
        requestedDate: string; 
        providerIds?: string[]; 
        operatoryIds?: string[] 
      } = {
        appointmentTypeId: selectedAppointmentTypeId,
        requestedDate: selectedDate
      };

      // Only include provider/operatory filters if specifically selected
      if (selectedProviderIds.length > 0) {
        requestBody.providerIds = selectedProviderIds;
      }
      if (selectedOperatoryIds.length > 0) {
        requestBody.operatoryIds = selectedOperatoryIds;
      }

      const response = await fetch('/api/practice-config/check-slots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to check appointment slots');
      }

      const result: CheckSlotsResponse = await response.json();
      setSlotsData(result.data);

      if (result.data.has_availability) {
        toast.success(`Found ${result.data.total_slots_found} available slot(s)!`);
      } else {
        toast.info("No available slots found for the selected date and appointment type");
      }

    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to check appointment slots');
      console.error(error);
      setSlotsData(null);
    } finally {
      setLoading(false);
    }
  };

  const formatDate = (dateString: string): string => {
    try {
      const date = new Date(dateString + 'T00:00:00');
      return date.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    } catch {
      return dateString;
    }
  };

  const getProviderName = (provider: Provider) => {
    return `${provider.firstName || ''} ${provider.lastName}`.trim() || 'Unnamed Provider';
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="mb-6">
        <h2 className="text-xl font-semibold mb-2">Check Appointment Slots</h2>
        <p className="text-gray-600">
          Check availability for specific appointment types and dates. Optional filters for providers and operatories.
        </p>
      </div>

      {/* Form */}
      <form onSubmit={(e) => { e.preventDefault(); handleCheckSlots(); }} className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Appointment Type Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Appointment Type *
            </label>
            <select
              value={selectedAppointmentTypeId}
              onChange={(e) => setSelectedAppointmentTypeId(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            >
              <option value="">Select appointment type</option>
              {appointmentTypes.map((type) => (
                <option key={type.id} value={type.id}>
                  {type.name} ({type.duration} min)
                </option>
              ))}
            </select>
          </div>

          {/* Date Selection */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Date *
            </label>
            <input
              type="date"
              value={selectedDate}
              onChange={(e) => setSelectedDate(e.target.value)}
              min={today}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              required
            />
          </div>
        </div>

        {/* Optional Filters */}
        <div className="border-t pt-6">
          <h3 className="text-lg font-medium text-gray-900 mb-4">Optional Filters</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Provider Filter */}
            <div>
              <h4 className="font-medium text-gray-700 mb-3">Filter by Providers</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {activeProviders.map((savedProvider) => (
                  <label key={savedProvider.id} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={selectedProviderIds.includes(savedProvider.id)}
                      onChange={(e) => handleProviderChange(savedProvider.id, e.target.checked)}
                      className="mr-2"
                    />
                    <span className="text-sm text-gray-700">
                      {getProviderName(savedProvider.provider)}
                    </span>
                  </label>
                ))}
              </div>
              {activeProviders.length === 0 && (
                <p className="text-sm text-gray-500">No active providers available</p>
              )}
            </div>

            {/* Operatory Filter */}
            <div>
              <h4 className="font-medium text-gray-700 mb-3">Filter by Operatories</h4>
              <div className="space-y-2 max-h-40 overflow-y-auto">
                {activeOperatories.map((operatory) => (
                  <label key={operatory.id} className="flex items-center">
                    <input
                      type="checkbox"
                      checked={selectedOperatoryIds.includes(operatory.id)}
                      onChange={(e) => handleOperatoryChange(operatory.id, e.target.checked)}
                      className="mr-2"
                    />
                    <span className="text-sm text-gray-700">
                      {operatory.name}
                    </span>
                  </label>
                ))}
              </div>
              {activeOperatories.length === 0 && (
                <p className="text-sm text-gray-500">No active operatories available</p>
              )}
            </div>
          </div>
        </div>

        {/* Submit Button */}
        <div className="flex justify-center pt-4">
          <button
            type="submit"
            disabled={loading}
            className="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {loading ? 'Checking...' : 'Check Available Slots'}
          </button>
        </div>
      </form>

      {/* Results */}
      {slotsData && (
        <div className="mt-8 border-t pt-6">
          <h3 className="text-lg font-semibold mb-4">
            Results for {formatDate(slotsData.requested_date)} - {slotsData.appointment_type.name}
          </h3>

          {slotsData.has_availability ? (
            <div className="space-y-4">
              <p className="text-green-600 font-medium">
                Found {slotsData.total_slots_found} available slot(s)
              </p>

              {/* Slots List */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {slotsData.available_slots.map((slot) => (
                  <div key={slot.slot_id} className="border border-gray-200 rounded-lg p-4">
                    <div className="font-medium text-blue-600">{slot.display_range}</div>
                    <div className="text-sm text-gray-600 mt-1">
                      Provider: {slot.provider_info.name}
                    </div>
                    {slot.operatory_info && (
                      <div className="text-sm text-gray-600">
                        Operatory: {slot.operatory_info.name}
                      </div>
                    )}
                  </div>
                ))}
              </div>

              {/* Debug Info */}
              <div className="bg-gray-50 rounded-lg p-4 mt-6">
                <h4 className="font-medium text-gray-900 mb-2">Search Summary</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <p>Providers checked: {slotsData.debug_info.providers_checked}</p>
                  <p>Operatories checked: {slotsData.debug_info.operatories_checked}</p>
                </div>
              </div>
            </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-500 mb-4">No available slots found</p>
              <div className="bg-gray-50 rounded-lg p-4">
                <h4 className="font-medium text-gray-900 mb-2">Search Summary</h4>
                <div className="text-sm text-gray-600 space-y-1">
                  <p>Providers checked: {slotsData.debug_info.providers_checked}</p>
                  <p>Operatories checked: {slotsData.debug_info.operatories_checked}</p>
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: app/practice-config/QuickReview.tsx
================
"use client";

import { useState, useEffect } from "react";

interface QuickReviewData {
  appointmentsBookedByLaine: number;
  activeProvidersCount: number;
  appointmentTypesCount: number;
}

export function QuickReview() {
  const [data, setData] = useState<QuickReviewData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchQuickReviewData();
  }, []);

  const fetchQuickReviewData = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('/api/practice-config/quick-review');
      
      if (response.ok) {
        const result = await response.json();
        setData(result);
      } else {
        const errorData = await response.json();
        setError(errorData.error || 'Failed to fetch quick review data');
      }
    } catch (err) {
      setError('Failed to fetch quick review data');
      console.error('Error fetching quick review data:', err);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Quick Review</h2>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {[1, 2, 3].map((i) => (
            <div key={i} className="text-center">
              <div className="h-8 bg-gray-200 rounded animate-pulse mb-2"></div>
              <div className="h-4 bg-gray-100 rounded animate-pulse"></div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4">Quick Review</h2>
        <div className="bg-red-50 border border-red-200 rounded-md p-4">
          <p className="text-red-800 text-sm">{error}</p>
          <button
            onClick={fetchQuickReviewData}
            className="mt-2 text-red-600 hover:text-red-700 text-sm underline"
          >
            Try again
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-xl font-semibold mb-6">Quick Review</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="text-center p-4 bg-blue-50 rounded-lg">
          <div className="text-3xl font-bold text-blue-600 mb-2">
            {data?.appointmentsBookedByLaine || 0}
          </div>
          <div className="text-sm text-blue-800 font-medium">
            Appointments Booked via Laine
          </div>
          <div className="text-xs text-blue-600 mt-1">
            Total appointments scheduled through Laine AI
          </div>
        </div>

        <div className="text-center p-4 bg-green-50 rounded-lg">
          <div className="text-3xl font-bold text-green-600 mb-2">
            {data?.activeProvidersCount || 0}
          </div>
          <div className="text-sm text-green-800 font-medium">
            Active Providers
          </div>
          <div className="text-xs text-green-600 mt-1">
            Providers available for scheduling
          </div>
        </div>

        <div className="text-center p-4 bg-purple-50 rounded-lg">
          <div className="text-3xl font-bold text-purple-600 mb-2">
            {data?.appointmentTypesCount || 0}
          </div>
          <div className="text-sm text-purple-800 font-medium">
            Appointment Types Created
          </div>
          <div className="text-xs text-purple-600 mt-1">
            Total appointment types configured
          </div>
        </div>
      </div>
      
      <div className="mt-4 flex justify-end">
        <button
          onClick={fetchQuickReviewData}
          disabled={loading}
          className="text-blue-600 hover:text-blue-700 disabled:opacity-50 text-sm"
        >
          {loading ? 'Refreshing...' : 'Refresh'}
        </button>
      </div>
    </div>
  );
}

================
File: app/test/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { getAssistantPhoneNumber, getLatestCallLogForPractice, getPracticeAndAssistantId, LatestCallLogData } from "./actions";
import { TestClient } from "./test-client"; // We will create this next

export default async function TestPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  let practiceId: string;
  let vapiAssistantId: string;
  let phoneNumber: string | null = null;
  let latestCallLog: LatestCallLogData | null = null;

  try {
    const assistantInfo = await getPracticeAndAssistantId();
    practiceId = assistantInfo.practiceId;
    vapiAssistantId = assistantInfo.vapiAssistantId;

    phoneNumber = await getAssistantPhoneNumber(vapiAssistantId);
    latestCallLog = await getLatestCallLogForPractice(practiceId);
  } catch (error) {
    // Errors during data fetching (e.g., redirects from actions) will be handled by Next.js
    // If an error is thrown and not a redirect, it will bubble up.
    // For simplicity, we assume redirects handle missing setup.
    // If not redirecting, render an error message or a link to setup.
    if (error instanceof Error && (error as { digest?: string }).digest?.startsWith('NEXT_REDIRECT')) {
      throw error; // Re-throw redirect errors
    }
    console.error("Error fetching data for /test page:", error);
    // Render a fallback or error state if necessary
    return (
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-4">Error Loading Test Page</h1>
        <p>Could not load necessary information. Please ensure your practice and Laine assistant are configured.</p>
        <p>Error: {error instanceof Error ? error.message : "Unknown error"}</p>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6 text-slate-800">Laine Assistant Test Center</h1>
      <TestClient
        vapiAssistantId={vapiAssistantId}
        initialPhoneNumber={phoneNumber}
        initialLatestCallLog={latestCallLog}
      />
    </div>
  );
}

================
File: app/tool-calls/page.tsx
================
import { promises as fs } from 'fs';
import path from 'path';
import { Metadata } from 'next';

// Simple markdown-to-HTML converter
function markdownToHtml(markdown: string): string {
  return markdown
    // Headers
    .replace(/^# (.*$)/gm, '<h1 class="text-3xl font-bold mb-6 text-gray-900">$1</h1>')
    .replace(/^## (.*$)/gm, '<h2 class="text-2xl font-semibold mb-4 mt-8 text-gray-800">$1</h2>')
    .replace(/^### (.*$)/gm, '<h3 class="text-xl font-semibold mb-3 mt-6 text-gray-700">$1</h3>')
    .replace(/^#### (.*$)/gm, '<h4 class="text-lg font-semibold mb-2 mt-4 text-gray-600">$1</h4>')
    
    // Code blocks
    .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre class="bg-gray-100 rounded-lg p-4 mb-4 overflow-x-auto"><code class="text-sm">$2</code></pre>')
    .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-2 py-1 rounded text-sm font-mono">$1</code>')
    
    // Lists
    .replace(/^- (.*$)/gm, '<li class="mb-1">$1</li>')
    .replace(/(<li.*<\/li>\n?)+/g, '<ul class="list-disc pl-6 mb-4">$&</ul>')
    .replace(/^\d+\. (.*$)/gm, '<li class="mb-1">$1</li>')
    
    // Bold and italic
    .replace(/\*\*([^*]+)\*\*/g, '<strong class="font-semibold">$1</strong>')
    .replace(/\*([^*]+)\*/g, '<em class="italic">$1</em>')
    
    // Links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-blue-600 hover:text-blue-800 underline">$1</a>')
    
    // Blockquotes (for the message examples)
    .replace(/^> (.*$)/gm, '<blockquote class="border-l-4 border-blue-500 pl-4 py-2 mb-4 bg-blue-50 italic text-gray-700">$1</blockquote>')
    
    // Horizontal rules
    .replace(/^---$/gm, '<hr class="my-8 border-gray-300">')
    
    // Paragraphs
    .replace(/\n\n/g, '</p><p class="mb-4">')
    .replace(/^(.+)$/gm, '<p class="mb-4">$1</p>')
    
    // Clean up empty paragraphs and fix nested HTML
    .replace(/<p class="mb-4"><\/p>/g, '')
    .replace(/<p class="mb-4">(<h[1-6])/g, '$1')
    .replace(/(<\/h[1-6]>)<\/p>/g, '$1')
    .replace(/<p class="mb-4">(<ul|<ol|<pre|<blockquote|<hr)/g, '$1')
    .replace(/(<\/ul>|<\/ol>|<\/pre>|<\/blockquote>|<hr[^>]*>)<\/p>/g, '$1');
}

export const metadata: Metadata = {
  title: 'Tool Calls System - LAINE Documentation',
  description: 'Comprehensive documentation of the LAINE AI Assistant tool call system and API integration',
};

export default async function ToolCallsPage() {
  try {
    const filePath = path.join(process.cwd(), 'docs', 'tool-calls-system.md');
    const fileContent = await fs.readFile(filePath, 'utf8');
    const htmlContent = markdownToHtml(fileContent);

    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-4xl mx-auto px-6 py-12">
          {/* Header */}
          <div className="mb-8 border-b border-gray-200 pb-6">
            <h1 className="text-4xl font-bold text-gray-900 mb-2">
              Tool Calls System Documentation
            </h1>
            <p className="text-gray-600 text-lg">
              Technical overview of the LAINE AI Assistant tool call architecture, API integration, and workflow management
            </p>
          </div>

          {/* Table of Contents */}
          <div className="mb-12 bg-gray-50 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4 text-gray-800">Quick Navigation</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
              <div>
                <h3 className="font-semibold text-gray-700 mb-2">Core System</h3>
                <ul className="space-y-1 text-gray-600">
                  <li><a href="#webhook-handler-apivapitool-calls" className="hover:text-blue-600">• Webhook Handler</a></li>
                  <li><a href="#tool-system-architecture" className="hover:text-blue-600">• Tool Architecture</a></li>
                  <li><a href="#integration-features" className="hover:text-blue-600">• Integration Features</a></li>
                </ul>
              </div>
              <div>
                <h3 className="font-semibold text-gray-700 mb-2">Tool Categories</h3>
                <ul className="space-y-1 text-gray-600">
                  <li><a href="#1-patient-management-tools" className="hover:text-blue-600">• Patient Management</a></li>
                  <li><a href="#2-appointment-discovery-tools" className="hover:text-blue-600">• Appointment Discovery</a></li>
                  <li><a href="#3-financial-tools" className="hover:text-blue-600">• Financial Tools</a></li>
                  <li><a href="#4-booking--information-tools" className="hover:text-blue-600">• Booking & Information</a></li>
                </ul>
              </div>
            </div>
          </div>

          {/* Main Content */}
          <div 
            className="prose prose-lg max-w-none"
            dangerouslySetInnerHTML={{ __html: htmlContent }}
          />

          {/* Footer */}
          <div className="mt-16 pt-8 border-t border-gray-200">
            <div className="bg-blue-50 rounded-lg p-6">
              <h3 className="text-lg font-semibold text-blue-900 mb-2">
                System Status
              </h3>
              <p className="text-blue-800 mb-3">
                The LAINE tool call system is currently in production with full NexHealth integration.
              </p>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <strong className="text-blue-900">Active Tools:</strong> 8/8
                </div>
                <div>
                  <strong className="text-blue-900">Current Phase:</strong> 1.4 (Universal Dynamic Messages)
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  } catch (error) {
    console.error('Error reading markdown file:', error);
    
    return (
      <div className="min-h-screen bg-white">
        <div className="max-w-4xl mx-auto px-6 py-12">
          <div className="text-center">
            <h1 className="text-3xl font-bold text-gray-900 mb-4">
              Tool Calls Documentation
            </h1>
            <div className="bg-red-50 border border-red-200 rounded-lg p-6">
              <p className="text-red-800">
                Error loading documentation. Please ensure the markdown file exists at docs/tool-calls-system.md
              </p>
            </div>
          </div>
        </div>
      </div>        
    );
  }
}

================
File: lib/prisma.ts
================
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

================
File: lib/webhook-utils.ts
================
import { prisma } from "@/lib/prisma";

const NEXHEALTH_API_BASE_URL = process.env.NEXHEALTH_API_BASE_URL || 'https://nexhealth.info';
const MASTER_NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY;

// Helper function for NexHealth Management API calls
async function callNexhealthManagementApi(path: string, options: {
  method?: string;
  body?: Record<string, unknown>;
  params?: Record<string, string>;
} = {}) {
  const { method = 'GET', body, params } = options;
  
  if (!MASTER_NEXHEALTH_API_KEY) {
    throw new Error('NEXHEALTH_API_KEY (master key) is required for webhook management');
  }

  let url = `${NEXHEALTH_API_BASE_URL}${path}`;
  
  // Add query parameters if provided
  if (params) {
    const searchParams = new URLSearchParams(params);
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': MASTER_NEXHEALTH_API_KEY, // Raw API key, no Bearer prefix
      'Accept': 'application/vnd.Nexhealth+json;version=2', // Required API version header
    },
  };

  if (body && method !== 'GET') {
    requestOptions.body = JSON.stringify(body);
  }

  console.log(`🔗 NexHealth API: ${method} ${url}`);
  if (body) {
    console.log('📤 Request body:', JSON.stringify(body, null, 2));
  }

  try {
    const response = await fetch(url, requestOptions);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`❌ NexHealth API error (${response.status}):`, errorText);
      const error = new Error(`NexHealth API error (${response.status}): ${errorText}`);
      throw error;
    }

    // Handle empty responses (like DELETE operations)
    const responseText = await response.text();
    if (!responseText.trim()) {
      console.log('📥 Response: (empty - operation successful)');
      return { data: null };
    }

    const data = JSON.parse(responseText);
    console.log('📥 Response:', JSON.stringify(data, null, 2));
    return { data };
  } catch (error) {
    console.error('❌ Network error calling NexHealth API:', error);
    throw error;
  }
}

// Subscribe practice to webhook events (imported logic from scripts/manage-nexhealth-webhooks.js)
export async function subscribePracticeToWebhooks(practiceSubdomain: string): Promise<{
  success: boolean;
  message: string;
  successCount: number;
  skipCount: number;
  failCount: number;
}> {
  console.log(`🔗 [WebhookUtils] Subscribing practice "${practiceSubdomain}" to NexHealth events...`);

  try {
    // 1. Get global webhook endpoint ID from our DB
    const globalEndpoint = await prisma.globalNexhealthWebhookEndpoint.findUnique({ 
      where: { id: "singleton" } 
    });
    
    if (!globalEndpoint || !globalEndpoint.nexhealthEndpointId) {
      throw new Error('Global webhook endpoint not configured in DB. Contact support.');
    }
    
    const globalNexhealthEndpointId = globalEndpoint.nexhealthEndpointId;

    // 2. Find the practice in our DB by subdomain to get its ID
    const practice = await prisma.practice.findFirst({ 
      where: { nexhealthSubdomain: practiceSubdomain } 
    });
    
    if (!practice) {
      throw new Error(`Practice with subdomain "${practiceSubdomain}" not found in database`);
    }

    // 3. Define events to subscribe to
    const eventsToSubscribe = [
      // Patient events
      { resourceType: "Patient", eventName: "patient_created" },
      { resourceType: "Patient", eventName: "patient_updated" },
      
      // Appointment events  
      { resourceType: "Appointment", eventName: "appointment_created" },
      { resourceType: "Appointment", eventName: "appointment_updated" },
      
      // Sync status events (for system monitoring)
      { resourceType: "SyncStatus", eventName: "sync_status_read_change" },
      { resourceType: "SyncStatus", eventName: "sync_status_write_change" },
    ];

    let successCount = 0;
    let skipCount = 0;
    let failCount = 0;

    for (const event of eventsToSubscribe) {
      // Check if already subscribed in our DB
      const existingDbSub = await prisma.nexhealthWebhookSubscription.findUnique({
        where: {
          practiceId_resourceType_eventName: {
            practiceId: practice.id,
            resourceType: event.resourceType,
            eventName: event.eventName,
          },
        },
      });

      if (existingDbSub && existingDbSub.isActive) {
        console.log(`   👍 Already subscribed to ${event.resourceType}.${event.eventName}`);
        skipCount++;
        continue;
      }

      console.log(`   Subscribing to ${event.resourceType}.${event.eventName}...`);
      
      try {
        const subscriptionResponse = await callNexhealthManagementApi(
          `/webhook_endpoints/${globalNexhealthEndpointId}/webhook_subscriptions`,
          {
            method: 'POST',
            body: { resource_type: event.resourceType, event: event.eventName, active: true },
            params: { subdomain: practice.nexhealthSubdomain || '' }
          }
        );

        const nexhealthSubscriptionId = String(subscriptionResponse.data.data.id);

        // Store subscription in our DB
        await prisma.nexhealthWebhookSubscription.upsert({
          where: {
            practiceId_resourceType_eventName: {
              practiceId: practice.id,
              resourceType: event.resourceType,
              eventName: event.eventName,
            },
          },
          create: {
            practiceId: practice.id,
            nexhealthWebhookEndpointId: globalNexhealthEndpointId,
            nexhealthSubscriptionId: nexhealthSubscriptionId,
            resourceType: event.resourceType,
            eventName: event.eventName,
            isActive: true,
          },
          update: {
            nexhealthSubscriptionId: nexhealthSubscriptionId,
            isActive: true,
            updatedAt: new Date(),
          }
        });
        
        console.log(`   ✅ Successfully subscribed to ${event.resourceType}.${event.eventName}`);
        successCount++;
      } catch (error) {
        console.error(`   ❌ Failed to subscribe to ${event.resourceType}.${event.eventName}:`, error);
        failCount++;
      }
    }
    
    const total = eventsToSubscribe.length;
    console.log(`🎉 Practice "${practiceSubdomain}" webhook processing complete:`);
    console.log(`   ✅ Success: ${successCount}, 👍 Skipped: ${skipCount}, ❌ Failed: ${failCount}`);
    
    return {
      success: failCount === 0,
      message: `Processed ${total} events: ${successCount} successful, ${skipCount} already subscribed, ${failCount} failed`,
      successCount,
      skipCount,
      failCount
    };

  } catch (error) {
    console.error(`❌ [WebhookUtils] Error subscribing practice "${practiceSubdomain}":`, error);
    return {
      success: false,
      message: error instanceof Error ? error.message : "Unknown error during webhook subscription",
      successCount: 0,
      skipCount: 0,
      failCount: 0
    };
  }
}

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: postcss.config.mjs
================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: app/api/practice-config/appointment-types/[appointmentTypeId]/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { 
  updateNexhealthAppointmentType, 
  deleteNexhealthAppointmentType 
} from "@/lib/nexhealth";
import { z } from "zod";

interface RouteParams {
  appointmentTypeId: string;
}

const updateAppointmentTypeSchema = z.object({
  name: z.string().min(1, "Name must be a non-empty string").optional(),
  minutes: z.number().positive("Minutes must be a positive number").optional(),
  bookableOnline: z.boolean().optional(),
  groupCode: z.string().nullable().optional()
});

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { appointmentTypeId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to update appointment types"
      }, { status: 400 });
    }

    // Fetch the local appointment type record to get the NexHealth ID
    const localAppointmentType = await prisma.appointmentType.findFirst({
      where: {
        id: appointmentTypeId,
        practiceId: practice.id
      }
    });

    if (!localAppointmentType) {
      return NextResponse.json({
        error: "Appointment type not found"
      }, { status: 404 });
    }

    const body = await req.json();

    // Validate input using Zod
    const validationResult = updateAppointmentTypeSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { name, minutes, bookableOnline, groupCode } = validationResult.data;

    // Build update data object with only provided fields for NexHealth
    const nexhealthUpdateData: {
      name?: string;
      minutes?: number;
      bookable_online?: boolean;
    } = {};

    if (name !== undefined) {
      nexhealthUpdateData.name = name.trim();
    }

    if (minutes !== undefined) {
      nexhealthUpdateData.minutes = minutes;
    }

    if (bookableOnline !== undefined) {
      nexhealthUpdateData.bookable_online = bookableOnline;
    }

    try {
      // Build local update data (includes groupCode which is Laine-specific)
      const localUpdateData: {
        name?: string;
        duration?: number;
        bookableOnline?: boolean;
        groupCode?: string | null;
        parentType?: string;
        parentId?: string;
        lastSyncError?: null;
      } = {};

      // Update appointment type in NexHealth (only if there are NexHealth-relevant fields)
      if (Object.keys(nexhealthUpdateData).length > 0) {
        const nexhealthResponse = await updateNexhealthAppointmentType(
          practice.nexhealthSubdomain,
          localAppointmentType.nexhealthAppointmentTypeId,
          practice.nexhealthLocationId,
          nexhealthUpdateData
        );

        // Update local data with NexHealth response
        if (nexhealthResponse.name !== localAppointmentType.name) {
          localUpdateData.name = nexhealthResponse.name;
        }
        if (nexhealthResponse.minutes !== localAppointmentType.duration) {
          localUpdateData.duration = nexhealthResponse.minutes;
        }
        if (nexhealthResponse.bookable_online !== localAppointmentType.bookableOnline) {
          localUpdateData.bookableOnline = nexhealthResponse.bookable_online;
        }
        if (nexhealthResponse.parent_type !== localAppointmentType.parentType) {
          localUpdateData.parentType = nexhealthResponse.parent_type;
        }
        if (nexhealthResponse.parent_id.toString() !== localAppointmentType.parentId) {
          localUpdateData.parentId = nexhealthResponse.parent_id.toString();
        }
      }

      // Add groupCode update if provided (Laine-specific field)
      if (groupCode !== undefined) {
        localUpdateData.groupCode = groupCode;
      }

      // Clear any previous sync errors if we made changes
      if (Object.keys(localUpdateData).length > 0) {
        localUpdateData.lastSyncError = null;
      }

      // Update appointment type in local database
      const updatedLocalAppointmentType = await prisma.appointmentType.update({
        where: { id: appointmentTypeId },
        data: localUpdateData
      });

      return NextResponse.json({
        success: true,
        appointmentType: updatedLocalAppointmentType
      });

    } catch (nexhealthError) {
      console.error("Error updating appointment type in NexHealth:", nexhealthError);
      
      // If only groupCode was being updated and NexHealth call failed, still update locally
      if (Object.keys(nexhealthUpdateData).length === 0 && groupCode !== undefined) {
        const updatedLocalAppointmentType = await prisma.appointmentType.update({
          where: { id: appointmentTypeId },
          data: { groupCode }
        });

        return NextResponse.json({
          success: true,
          appointmentType: updatedLocalAppointmentType
        });
      }

      // Update local record with error for NexHealth-related fields
      await prisma.appointmentType.update({
        where: { id: appointmentTypeId },
        data: {
          lastSyncError: nexhealthError instanceof Error ? nexhealthError.message : 'Unknown NexHealth error'
        }
      });

      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to update appointment type in NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error updating appointment type:", error);
    return NextResponse.json(
      { error: "Failed to update appointment type" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { appointmentTypeId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to delete appointment types"
      }, { status: 400 });
    }

    // Fetch the local appointment type record to get the NexHealth ID
    const localAppointmentType = await prisma.appointmentType.findFirst({
      where: {
        id: appointmentTypeId,
        practiceId: practice.id
      }
    });

    if (!localAppointmentType) {
      return NextResponse.json({
        error: "Appointment type not found"
      }, { status: 404 });
    }

    try {
      // Delete appointment type from NexHealth
      await deleteNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        localAppointmentType.nexhealthAppointmentTypeId,
        practice.nexhealthLocationId
      );

      // Delete appointment type from local database
      await prisma.appointmentType.delete({
        where: { id: appointmentTypeId }
      });

      return NextResponse.json({
        success: true,
        message: "Appointment type deleted successfully"
      });

    } catch (nexhealthError) {
      console.error("Error deleting appointment type from NexHealth:", nexhealthError);
      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to delete appointment type from NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error deleting appointment type:", error);
    return NextResponse.json(
      { error: "Failed to delete appointment type" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/appointment-types/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { createNexhealthAppointmentType } from "@/lib/nexhealth";
import { z } from "zod";

const createAppointmentTypeSchema = z.object({
  name: z.string().min(1, "Name is required and must be a non-empty string"),
  minutes: z.number().positive("Minutes must be a positive number"),
  bookableOnline: z.boolean().optional().default(true),
  groupCode: z.string().nullable().optional()
});

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: {
          orderBy: { name: 'asc' }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Simply return existing appointment types without automatic sync
    return NextResponse.json({
      success: true,
      appointmentTypes: practice.appointmentTypes
    });

  } catch (error) {
    console.error("Error fetching appointment types:", error);
    return NextResponse.json(
      { error: "Failed to fetch appointment types" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to create appointment types"
      }, { status: 400 });
    }

    const body = await req.json();

    // Validate input using Zod
    const validationResult = createAppointmentTypeSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { name, minutes, bookableOnline, groupCode } = validationResult.data;

    try {
      // Create appointment type in NexHealth (groupCode is Laine-specific, not sent to NexHealth)
      const nexhealthResponse = await createNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        practice.nexhealthLocationId,
        {
          name: name.trim(),
          minutes,
          bookable_online: bookableOnline,
          parent_type: "Location",
          parent_id: practice.nexhealthLocationId
        }
      );

      // Create appointment type in local database with groupCode
      const localAppointmentType = await prisma.appointmentType.create({
        data: {
          practiceId: practice.id,
          nexhealthAppointmentTypeId: nexhealthResponse.id.toString(),
          name: nexhealthResponse.name,
          duration: nexhealthResponse.minutes,
          bookableOnline: nexhealthResponse.bookable_online,
          groupCode, // Store the Laine-specific group code
          parentType: nexhealthResponse.parent_type,
          parentId: nexhealthResponse.parent_id.toString()
        }
      });

      return NextResponse.json({
        success: true,
        appointmentType: localAppointmentType
      });

    } catch (nexhealthError) {
      console.error("Error creating appointment type in NexHealth:", nexhealthError);
      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to create appointment type in NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error creating appointment type:", error);
    return NextResponse.json(
      { error: "Failed to create appointment type" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/provider-settings/[savedProviderId]/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

interface RouteParams {
  savedProviderId: string;
}

const updateProviderSettingsSchema = z.object({
  acceptedAppointmentTypeIds: z.array(z.string()).optional(),
  defaultAppointmentTypeId: z.string().nullable().optional(),
  defaultOperatoryId: z.string().nullable().optional(),
  assignedOperatoryIds: z.array(z.string()).optional() // NEW: Multiple operatories
});

export async function GET(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { savedProviderId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Fetch the saved provider with all related data
    const savedProvider = await prisma.savedProvider.findFirst({
      where: {
        id: savedProviderId,
        practiceId: practice.id
      },
      include: {
        provider: {
          select: {
            id: true,
            nexhealthProviderId: true,
            firstName: true,
            lastName: true
          }
        },
        defaultAppointmentType: {
          select: {
            id: true,
            name: true,
            nexhealthAppointmentTypeId: true,
            duration: true,
            groupCode: true
          }
        },
        defaultOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        },
        acceptedAppointmentTypes: {
          include: {
            appointmentType: {
              select: {
                id: true,
                name: true,
                nexhealthAppointmentTypeId: true,
                duration: true,
                groupCode: true
              }
            }
          }
        },
        assignedOperatories: {
          include: {
            savedOperatory: {
              select: {
                id: true,
                name: true,
                nexhealthOperatoryId: true
              }
            }
          }
        }
      }
    });

    if (!savedProvider) {
      return NextResponse.json({ 
        error: "Provider not found or doesn't belong to this practice" 
      }, { status: 404 });
    }

    // Format the response
    const response = {
      id: savedProvider.id,
      provider: savedProvider.provider,
      isActive: savedProvider.isActive,
      defaultAppointmentType: savedProvider.defaultAppointmentType,
      defaultOperatory: savedProvider.defaultOperatory,
      acceptedAppointmentTypes: savedProvider.acceptedAppointmentTypes.map((relation: { appointmentType: { id: string; name: string; nexhealthAppointmentTypeId: string; duration: number; groupCode: string | null } }) => relation.appointmentType),
      assignedOperatories: savedProvider.assignedOperatories?.map((assignment: { savedOperatory: { id: string; name: string; nexhealthOperatoryId: string } }) => assignment.savedOperatory) || [],
      createdAt: savedProvider.createdAt,
      updatedAt: savedProvider.updatedAt
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error("Error fetching provider settings:", error);
    return NextResponse.json(
      { error: "Failed to fetch provider settings" },
      { status: 500 }
    );
  }
}

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { savedProviderId } = await params;
    const body = await req.json();

    console.log('🔍 Provider Settings Save Request:', {
      savedProviderId,
      body,
      bodyKeys: Object.keys(body),
      bodyTypes: Object.keys(body).map(key => `${key}: ${typeof body[key]}`)
    });

    // Validate input
    const validationResult = updateProviderSettingsSchema.safeParse(body);
    if (!validationResult.success) {
      console.error('❌ Validation failed:', validationResult.error.issues);
      return NextResponse.json({
        error: "Validation failed",
        issues: validationResult.error.issues.map(issue => ({
          path: issue.path.join('.'),
          message: issue.message,
          code: issue.code
        }))
      }, { status: 400 });
    }

    const { acceptedAppointmentTypeIds, defaultAppointmentTypeId, defaultOperatoryId, assignedOperatoryIds } = validationResult.data;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Verify the saved provider belongs to this practice
    const savedProvider = await prisma.savedProvider.findFirst({
      where: {
        id: savedProviderId,
        practiceId: practice.id
      }
    });

    if (!savedProvider) {
      return NextResponse.json({ 
        error: "Provider not found or doesn't belong to this practice" 
      }, { status: 404 });
    }

    // Validate appointment type IDs belong to practice if provided
    if (acceptedAppointmentTypeIds && acceptedAppointmentTypeIds.length > 0) {
      const validAppointmentTypes = await prisma.appointmentType.findMany({
        where: {
          id: { in: acceptedAppointmentTypeIds },
          practiceId: practice.id
        }
      });

      if (validAppointmentTypes.length !== acceptedAppointmentTypeIds.length) {
        return NextResponse.json({
          error: "Some appointment types don't belong to this practice"
        }, { status: 400 });
      }
    }

    // Validate default appointment type belongs to practice if provided
    if (defaultAppointmentTypeId) {
      const defaultAppointmentType = await prisma.appointmentType.findFirst({
        where: {
          id: defaultAppointmentTypeId,
          practiceId: practice.id
        }
      });

      if (!defaultAppointmentType) {
        return NextResponse.json({
          error: "Default appointment type doesn't belong to this practice"
        }, { status: 400 });
      }
    }

    // Validate default operatory belongs to practice if provided
    if (defaultOperatoryId) {
      const defaultOperatory = await prisma.savedOperatory.findFirst({
        where: {
          id: defaultOperatoryId,
          practiceId: practice.id,
          isActive: true
        }
      });

      if (!defaultOperatory) {
        return NextResponse.json({
          error: "Default operatory doesn't belong to this practice or is not active"
        }, { status: 400 });
      }
    }

    // Validate assigned operatory IDs belong to practice if provided
    if (assignedOperatoryIds && assignedOperatoryIds.length > 0) {
      const validOperatories = await prisma.savedOperatory.findMany({
        where: {
          id: { in: assignedOperatoryIds },
          practiceId: practice.id,
          isActive: true
        }
      });

      if (validOperatories.length !== assignedOperatoryIds.length) {
        return NextResponse.json({
          error: "Some operatories don't belong to this practice or are not active"
        }, { status: 400 });
      }
    }

    // Use transaction to ensure atomicity
    await prisma.$transaction(async (tx) => {
      // Update the SavedProvider record with defaults
      const updated = await tx.savedProvider.update({
        where: { id: savedProviderId },
        data: {
          defaultAppointmentTypeId: defaultAppointmentTypeId !== undefined ? defaultAppointmentTypeId : undefined,
          defaultOperatoryId: defaultOperatoryId !== undefined ? defaultOperatoryId : undefined
        }
      });

      // Manage accepted appointment types if provided
      if (acceptedAppointmentTypeIds !== undefined) {
        // Delete existing associations
        await tx.providerAcceptedAppointmentType.deleteMany({
          where: { savedProviderId }
        });

        // Create new associations if any provided
        if (acceptedAppointmentTypeIds.length > 0) {
          await tx.providerAcceptedAppointmentType.createMany({
            data: acceptedAppointmentTypeIds.map(appointmentTypeId => ({
              savedProviderId,
              appointmentTypeId
            }))
          });
        }
      }

      // Manage assigned operatories if provided
      if (assignedOperatoryIds !== undefined) {
        // Delete existing operatory assignments
        await tx.providerOperatoryAssignment.deleteMany({
          where: { savedProviderId }
        });

        // Create new operatory assignments if any provided
        if (assignedOperatoryIds.length > 0) {
          await tx.providerOperatoryAssignment.createMany({
            data: assignedOperatoryIds.map(savedOperatoryId => ({
              savedProviderId,
              savedOperatoryId
            }))
          });
        }
      }

      return updated;
    });

    // Fetch the updated provider with all related data for response
    const responseData = await prisma.savedProvider.findUnique({
      where: { id: savedProviderId },
      include: {
        provider: {
          select: {
            id: true,
            nexhealthProviderId: true,
            firstName: true,
            lastName: true
          }
        },
        defaultAppointmentType: {
          select: {
            id: true,
            name: true,
            nexhealthAppointmentTypeId: true,
            duration: true,
            groupCode: true
          }
        },
        defaultOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        },
        acceptedAppointmentTypes: {
          include: {
            appointmentType: {
              select: {
                id: true,
                name: true,
                nexhealthAppointmentTypeId: true,
                duration: true,
                groupCode: true
              }
            }
          }
        },
        assignedOperatories: {
          include: {
            savedOperatory: {
              select: {
                id: true,
                name: true,
                nexhealthOperatoryId: true
              }
            }
          }
        }
      }
    });

    return NextResponse.json({
      success: true,
      provider: {
        ...responseData,
        acceptedAppointmentTypes: responseData?.acceptedAppointmentTypes.map(relation => relation.appointmentType)
      }
    });

  } catch (error) {
    console.error("Error updating provider settings:", error);
    return NextResponse.json(
      { error: "Failed to update provider settings" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/webhook-sync/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { subscribePracticeToWebhooks } from "@/lib/webhook-utils";

export async function POST(req: NextRequest) {
  console.log("=== Webhook Sync API ===");
  
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { subdomain } = await req.json();
    
    if (!subdomain) {
      return NextResponse.json({ error: "Subdomain is required" }, { status: 400 });
    }

    // Verify the practice belongs to this user
    const practice = await prisma.practice.findFirst({
      where: {
        clerkUserId: userId,
        nexhealthSubdomain: subdomain
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    console.log(`[WebhookSync] Syncing webhooks for practice: ${practice.id} (${subdomain})`);

    // Subscribe to webhooks using the new utility
    const result = await subscribePracticeToWebhooks(subdomain);

    // Update the webhook sync timestamp in the database
    await prisma.practice.update({
      where: { id: practice.id },
      data: {
        webhookLastSyncAt: new Date()
      }
    });

    // Fetch updated webhook subscriptions
    const updatedPractice = await prisma.practice.findUnique({
      where: { id: practice.id },
      include: {
        nexhealthWebhookSubscriptions: true
      }
    });

    return NextResponse.json({
      success: result.success,
      message: result.message,
      details: {
        successCount: result.successCount,
        skipCount: result.skipCount,
        failCount: result.failCount
      },
      webhookSubscriptions: updatedPractice?.nexhealthWebhookSubscriptions || [],
      lastSyncTime: new Date().toISOString()
    });

  } catch (error) {
    console.error("Error in webhook sync API:", error);
    return NextResponse.json({
      success: false,
      message: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error"
    }, { status: 500 });
  }
}

================
File: app/api/webhook-subscribe/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";

async function callNexhealthManagementApi(path: string, options: { method?: string; body?: Record<string, unknown>; params?: Record<string, string> } = {}) {
  const { method = 'GET', body, params } = options;
  
  const NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY;
  if (!NEXHEALTH_API_KEY) {
    throw new Error('NEXHEALTH_API_KEY is required for webhook management');
  }

  const NEXHEALTH_API_BASE_URL = 'https://nexhealth.info';
  let url = `${NEXHEALTH_API_BASE_URL}${path}`;
  
  if (params) {
    const searchParams = new URLSearchParams(params);
    url += `?${searchParams.toString()}`;
  }

  const requestOptions: RequestInit = {
    method,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': NEXHEALTH_API_KEY,
      'Accept': 'application/vnd.Nexhealth+json;version=2',
    },
  };

  if (body && method !== 'GET') {
    requestOptions.body = JSON.stringify(body);
  }

  const response = await fetch(url, requestOptions);
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`NexHealth API error (${response.status}): ${errorText}`);
  }

  const responseText = await response.text();
  if (!responseText.trim()) {
    return { data: null };
  }

  const data = JSON.parse(responseText);
  return { data };
}

export async function POST() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
    });

    if (!practice || !practice.nexhealthSubdomain) {
      return NextResponse.json({ error: "Practice not found or subdomain not configured" }, { status: 400 });
    }

    // Get global webhook endpoint
    const globalEndpoint = await prisma.globalNexhealthWebhookEndpoint.findUnique({
      where: { id: "singleton" }
    });

    if (!globalEndpoint) {
      return NextResponse.json({ error: "Global webhook endpoint not configured. Contact support." }, { status: 500 });
    }

    // Define events to subscribe to
    const eventsToSubscribe = [
      { resourceType: "Patient", eventName: "patient_created" },
      { resourceType: "Patient", eventName: "patient_updated" },
      { resourceType: "Appointment", eventName: "appointment_created" },
      { resourceType: "Appointment", eventName: "appointment_updated" },
      { resourceType: "SyncStatus", eventName: "sync_status_read_change" },
      { resourceType: "SyncStatus", eventName: "sync_status_write_change" },
    ];

    let successCount = 0;
    let skipCount = 0;
    const errors: string[] = [];

    for (const event of eventsToSubscribe) {
      // Check if already subscribed
      const existing = await prisma.nexhealthWebhookSubscription.findUnique({
        where: {
          practiceId_resourceType_eventName: {
            practiceId: practice.id,
            resourceType: event.resourceType,
            eventName: event.eventName,
          },
        },
      });

      if (existing && existing.isActive) {
        skipCount++;
        continue;
      }

      try {
        const subscriptionResponse = await callNexhealthManagementApi(
          `/webhook_endpoints/${globalEndpoint.nexhealthEndpointId}/webhook_subscriptions`,
          {
            method: 'POST',
            body: { resource_type: event.resourceType, event: event.eventName, active: true },
            params: { subdomain: practice.nexhealthSubdomain }
          }
        );

        const nexhealthSubscriptionId = String(subscriptionResponse.data.data.id);

        await prisma.nexhealthWebhookSubscription.upsert({
          where: {
            practiceId_resourceType_eventName: {
              practiceId: practice.id,
              resourceType: event.resourceType,
              eventName: event.eventName,
            },
          },
          create: {
            practiceId: practice.id,
            nexhealthWebhookEndpointId: globalEndpoint.nexhealthEndpointId,
            nexhealthSubscriptionId: nexhealthSubscriptionId,
            resourceType: event.resourceType,
            eventName: event.eventName,
            isActive: true,
          },
          update: {
            nexhealthSubscriptionId: nexhealthSubscriptionId,
            isActive: true,
            updatedAt: new Date(),
          }
        });

        successCount++;
      } catch (error) {
        console.error(`Failed to subscribe to ${event.resourceType}.${event.eventName}:`, error);
        errors.push(`${event.resourceType}.${event.eventName}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return NextResponse.json({ 
      success: true, 
      subscriptionsCount: successCount,
      skippedCount: skipCount,
      totalEvents: eventsToSubscribe.length,
      errors: errors.length > 0 ? errors : undefined
    });

  } catch (error) {
    console.error("Error subscribing to webhooks:", error);
    return NextResponse.json({ 
      error: `Failed to subscribe to webhooks: ${error instanceof Error ? error.message : 'Unknown error'}` 
    }, { status: 500 });
  }
}

================
File: app/practice-config/AppointmentTypesConfig.tsx
================
"use client";

import { useState } from "react";
import { toast } from "sonner";

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  bookableOnline: boolean | null;
  groupCode: string | null;
  createdAt: string;
  updatedAt: string;
}

interface AppointmentTypesConfigProps {
  initialAppointmentTypes: AppointmentType[];
  onUpdate: () => void;
}

interface FormData {
  name: string;
  minutes: number;
  bookableOnline: boolean;
  groupCode: string;
}

export function AppointmentTypesConfig({ 
  initialAppointmentTypes, 
  onUpdate 
}: AppointmentTypesConfigProps) {
  const [appointmentTypes] = useState<AppointmentType[]>(initialAppointmentTypes);
  const [syncLoading, setSyncLoading] = useState(false);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [editingType, setEditingType] = useState<AppointmentType | null>(null);
  const [deletingType, setDeletingType] = useState<AppointmentType | null>(null);
  const [formLoading, setFormLoading] = useState(false);
  const [formData, setFormData] = useState<FormData>({
    name: '',
    minutes: 30,
    bookableOnline: true,
    groupCode: ''
  });

  const resetForm = () => {
    setFormData({
      name: '',
      minutes: 30,
      bookableOnline: true,
      groupCode: ''
    });
  };

  const handleSyncWithNexHealth = async () => {
    setSyncLoading(true);
    try {
      const response = await fetch('/api/sync-nexhealth', {
        method: 'POST'
      });

      if (response.ok) {
        toast.success('Appointment types synced with NexHealth successfully!');
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Sync failed: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error syncing with NexHealth:', error);
      toast.error('Failed to sync with NexHealth');
    } finally {
      setSyncLoading(false);
    }
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();
    setFormLoading(true);
    
    try {
      const response = await fetch('/api/practice-config/appointment-types', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,
          minutes: formData.minutes,
          bookableOnline: formData.bookableOnline,
          groupCode: formData.groupCode || null
        })
      });

      if (response.ok) {
        toast.success('Appointment type created successfully!');
        setShowCreateModal(false);
        resetForm();
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Failed to create: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error creating appointment type:', error);
      toast.error('Failed to create appointment type');
    } finally {
      setFormLoading(false);
    }
  };

  const handleEdit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editingType) return;
    
    setFormLoading(true);
    
    try {
      const response = await fetch(`/api/practice-config/appointment-types/${editingType.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,
          minutes: formData.minutes,
          bookableOnline: formData.bookableOnline,
          groupCode: formData.groupCode || null
        })
      });

      if (response.ok) {
        toast.success('Appointment type updated successfully!');
        setShowEditModal(false);
        setEditingType(null);
        resetForm();
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Failed to update: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error updating appointment type:', error);
      toast.error('Failed to update appointment type');
    } finally {
      setFormLoading(false);
    }
  };

  const handleDelete = async () => {
    if (!deletingType) return;
    
    setFormLoading(true);
    
    try {
      const response = await fetch(`/api/practice-config/appointment-types/${deletingType.id}`, {
        method: 'DELETE'
      });

      if (response.ok) {
        toast.success('Appointment type deleted successfully!');
        setShowDeleteModal(false);
        setDeletingType(null);
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Failed to delete: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error deleting appointment type:', error);
      toast.error('Failed to delete appointment type');
    } finally {
      setFormLoading(false);
    }
  };

  const openEditModal = (type: AppointmentType) => {
    setEditingType(type);
    setFormData({
      name: type.name,
      minutes: type.duration,
      bookableOnline: type.bookableOnline ?? true,
      groupCode: type.groupCode || ''
    });
    setShowEditModal(true);
  };

  const openDeleteModal = (type: AppointmentType) => {
    setDeletingType(type);
    setShowDeleteModal(true);
  };

  const closeModals = () => {
    setShowCreateModal(false);
    setShowEditModal(false);
    setShowDeleteModal(false);
    setEditingType(null);
    setDeletingType(null);
    resetForm();
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-semibold">Appointment Types Configuration</h2>
        <div className="flex gap-3">
          <button
            onClick={() => {
              resetForm();
              setShowCreateModal(true);
            }}
            className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
          >
            Add New Type
          </button>
          <button
            onClick={handleSyncWithNexHealth}
            disabled={syncLoading}
            className="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {syncLoading ? 'Syncing...' : 'Sync with NexHealth'}
          </button>
        </div>
      </div>

      {/* Appointment Types Table */}
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Name
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Duration
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Group Code
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Bookable Online
              </th>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Actions
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {appointmentTypes.map((type) => (
              <tr key={type.id}>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  {type.name}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {type.duration} minutes
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {type.groupCode || '-'}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                    type.bookableOnline 
                      ? 'bg-green-100 text-green-800' 
                      : 'bg-red-100 text-red-800'
                  }`}>
                    {type.bookableOnline ? 'Yes' : 'No'}
                  </span>
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2">
                  <button
                    onClick={() => openEditModal(type)}
                    className="text-blue-600 hover:text-blue-900"
                  >
                    Edit
                  </button>
                  <button
                    onClick={() => openDeleteModal(type)}
                    className="text-red-600 hover:text-red-900"
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>

        {appointmentTypes.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            No appointment types configured. Add a new type or sync with NexHealth to import them.
          </div>
        )}
      </div>

      {/* Create Modal */}
      {showCreateModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-semibold mb-4">Add New Appointment Type</h3>
            <form onSubmit={handleCreate}>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Name *
                  </label>
                  <input
                    type="text"
                    required
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Duration (minutes) *
                  </label>
                  <select
                    required
                    value={formData.minutes}
                    onChange={(e) => setFormData({ ...formData, minutes: parseInt(e.target.value) })}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value={15}>15 minutes</option>
                    <option value={30}>30 minutes</option>
                    <option value={45}>45 minutes</option>
                    <option value={60}>60 minutes</option>
                    <option value={75}>75 minutes</option>
                    <option value={90}>90 minutes</option>
                    <option value={105}>105 minutes</option>
                    <option value={120}>120 minutes</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Group Code
                  </label>
                  <input
                    type="text"
                    value={formData.groupCode}
                    onChange={(e) => setFormData({ ...formData, groupCode: e.target.value })}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    id="bookableOnline"
                    checked={formData.bookableOnline}
                    onChange={(e) => setFormData({ ...formData, bookableOnline: e.target.checked })}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label htmlFor="bookableOnline" className="ml-2 block text-sm text-gray-700">
                    Bookable Online
                  </label>
                </div>
              </div>
              <div className="flex justify-end gap-3 mt-6">
                <button
                  type="button"
                  onClick={closeModals}
                  className="px-4 py-2 text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={formLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
                >
                  {formLoading ? 'Creating...' : 'Create'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Edit Modal */}
      {showEditModal && editingType && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-semibold mb-4">Edit Appointment Type</h3>
            <form onSubmit={handleEdit}>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Name *
                  </label>
                  <input
                    type="text"
                    required
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Duration (minutes) *
                  </label>
                  <select
                    required
                    value={formData.minutes}
                    onChange={(e) => setFormData({ ...formData, minutes: parseInt(e.target.value) })}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  >
                    <option value={15}>15 minutes</option>
                    <option value={30}>30 minutes</option>
                    <option value={45}>45 minutes</option>
                    <option value={60}>60 minutes</option>
                    <option value={75}>75 minutes</option>
                    <option value={90}>90 minutes</option>
                    <option value={105}>105 minutes</option>
                    <option value={120}>120 minutes</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Group Code
                  </label>
                  <input
                    type="text"
                    value={formData.groupCode}
                    onChange={(e) => setFormData({ ...formData, groupCode: e.target.value })}
                    className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    id="editBookableOnline"
                    checked={formData.bookableOnline}
                    onChange={(e) => setFormData({ ...formData, bookableOnline: e.target.checked })}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label htmlFor="editBookableOnline" className="ml-2 block text-sm text-gray-700">
                    Bookable Online
                  </label>
                </div>
              </div>
              <div className="flex justify-end gap-3 mt-6">
                <button
                  type="button"
                  onClick={closeModals}
                  className="px-4 py-2 text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={formLoading}
                  className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
                >
                  {formLoading ? 'Updating...' : 'Update'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Delete Confirmation Modal */}
      {showDeleteModal && deletingType && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-semibold mb-4">Delete Appointment Type</h3>
            <p className="text-gray-600 mb-6">
              Are you sure you want to delete &quot;{deletingType.name}&quot;? This action cannot be undone and will also remove it from NexHealth.
            </p>
            <div className="flex justify-end gap-3">
              <button
                onClick={closeModals}
                className="px-4 py-2 text-gray-700 bg-gray-200 rounded-md hover:bg-gray-300"
              >
                Cancel
              </button>
              <button
                onClick={handleDelete}
                disabled={formLoading}
                className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 disabled:opacity-50"
              >
                {formLoading ? 'Deleting...' : 'Delete'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: app/test/actions.ts
================
"use server";

import { prisma } from "@/lib/prisma";
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export interface LatestCallLogData {
  vapiCallId: string;
  transcriptText: string | null;
  recordingUrl: string | null; // Ensure this field exists or is mapped correctly in CallLog
  endedReason: string | null;
  callStatus: string | null;
  summary: string | null;
  createdAt: Date;
}

export async function getAssistantPhoneNumber(assistantId: string): Promise<string | null> {
  if (!process.env.VAPI_API_KEY) {
    console.error("VAPI_API_KEY (private key) not set for fetching phone number.");
    return null;
  }
  
  const url = `https://api.vapi.ai/phone-number?assistantId=${encodeURIComponent(assistantId)}`;
  console.log(`[getAssistantPhoneNumber] Fetching URL: ${url}`);

  try {
    const response = await fetch(url, {
      method: 'GET', // Explicitly set GET, though it's default
      headers: { 
        'Authorization': `Bearer ${process.env.VAPI_API_KEY}`,
        // Don't include Content-Type for GET requests
      }
      // Ensure no 'body' property is present for a GET request
    });

    if (!response.ok) {
      const errorBodyText = await response.text();
      console.error(`[getAssistantPhoneNumber] Failed to fetch phone numbers from Vapi. Status: ${response.status}, Body: ${errorBodyText}`);
      
      // Log the specific error message from Vapi if it's JSON
      try {
        const errorJson = JSON.parse(errorBodyText);
        console.error("[getAssistantPhoneNumber] Vapi error JSON:", errorJson);
      } catch {
        // Not JSON, already logged as text
      }
      
      // If the assistantId filter fails, try fetching all phone numbers and filter client-side
      if (response.status === 400 && errorBodyText.includes('assistantId')) {
        console.log("[getAssistantPhoneNumber] assistantId query parameter failed, trying fallback approach...");
        return await getPhoneNumberFallback(assistantId);
      }
      
      return null;
    }

    const data = await response.json();
    console.log("[getAssistantPhoneNumber] Vapi response data:", data);

    if (Array.isArray(data) && data.length > 0 && data[0].number) {
      console.log(`[getAssistantPhoneNumber] Found phone number: ${data[0].number}`);
      return data[0].number;
    } else if (Array.isArray(data) && data.length === 0) {
      console.log(`[getAssistantPhoneNumber] No phone numbers found associated with assistantId: ${assistantId}`);
      return null;
    } else {
      console.warn(`[getAssistantPhoneNumber] Unexpected data structure from Vapi:`, data);
      return null;
    }
  } catch (error) {
    console.error("[getAssistantPhoneNumber] Error fetching assistant phone number from Vapi:", error);
    return null;
  }
}

// Fallback function to fetch all phone numbers and filter by assistant ID
async function getPhoneNumberFallback(assistantId: string): Promise<string | null> {
  console.log(`[getPhoneNumberFallback] Fetching all phone numbers and filtering for assistantId: ${assistantId}`);
  
  try {
    const response = await fetch('https://api.vapi.ai/phone-number', {
      method: 'GET',
      headers: { 
        'Authorization': `Bearer ${process.env.VAPI_API_KEY}`,
      }
    });

    if (!response.ok) {
      const errorBodyText = await response.text();
      console.error(`[getPhoneNumberFallback] Failed to fetch all phone numbers from Vapi. Status: ${response.status}, Body: ${errorBodyText}`);
      return null;
    }

    const data = await response.json();
    console.log("[getPhoneNumberFallback] All phone numbers response:", data);

    if (Array.isArray(data)) {
      // Look for a phone number object that has the matching assistant ID
      const matchingPhone = data.find(phoneObj => {
        // The structure might vary, check common paths
        return phoneObj.assistantId === assistantId || 
               phoneObj.assistant?.id === assistantId ||
               phoneObj.assistant === assistantId;
      });
      
      if (matchingPhone && matchingPhone.number) {
        console.log(`[getPhoneNumberFallback] Found matching phone number: ${matchingPhone.number}`);
        return matchingPhone.number;
      } else {
        console.log(`[getPhoneNumberFallback] No phone number found for assistantId: ${assistantId}`);
        return null;
      }
    } else {
      console.warn("[getPhoneNumberFallback] Unexpected response structure from all phone numbers API:", data);
      return null;
    }
  } catch (error) {
    console.error("[getPhoneNumberFallback] Error in fallback phone number fetch:", error);
    return null;
  }
}

export async function getLatestCallLogForPractice(practiceId: string): Promise<LatestCallLogData | null> {
  try {
    const latestCallLog = await prisma.callLog.findFirst({
      where: { practiceId: practiceId },
      orderBy: { createdAt: 'desc' },
      select: {
        vapiCallId: true,
        transcriptText: true,
        vapiTranscriptUrl: true, // Assuming this stores the recording URL. If not, adjust.
                                 // Let's rename to recordingUrl for clarity if it's audio.
        endedReason: true,
        callStatus: true,
        summary: true,
        createdAt: true
      }
    });

    if (latestCallLog) {
      return {
        ...latestCallLog,
        // If vapiTranscriptUrl is indeed the recording URL, map it here for clarity
        // or ensure the schema/population logic is correct.
        // For now, let's assume it's correct and the client will use it.
        // If it's not, we'll need to adjust how 'recordingUrl' is populated.
        // For the purpose of this prompt, let's assume vapiTranscriptUrl IS the recordingUrl.
        recordingUrl: latestCallLog.vapiTranscriptUrl 
      };
    }
    return null;
  } catch (error) {
    console.error("Error fetching latest call log:", error);
    return null;
  }
}

export async function getPracticeAndAssistantId() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in"); // Or handle as an error
  }

  const practiceWithConfig = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practiceWithConfig) {
    // This case should ideally redirect to a setup page if practice doesn't exist
    console.warn(`No practice found for clerkUserId: ${userId}. Redirecting to /practice-config.`);
    redirect("/practice-config");
  }
  if (!practiceWithConfig.assistantConfig?.vapiAssistantId) {
    console.warn(`No Vapi assistant configured for practiceId: ${practiceWithConfig.id}. Redirecting to /laine.`);
    redirect('/laine');
  }
  
  return {
    practiceId: practiceWithConfig.id,
    vapiAssistantId: practiceWithConfig.assistantConfig.vapiAssistantId,
  };
}

================
File: app/test/test-client.tsx
================
"use client";

import Vapi from "@vapi-ai/web"; // Import Vapi
import { useEffect, useState, useRef } from "react";
import type { LatestCallLogData } from "./actions";

interface TestClientProps {
  vapiAssistantId: string;
  initialPhoneNumber: string | null;
  initialLatestCallLog: LatestCallLogData | null;
}

export function TestClient({ vapiAssistantId, initialPhoneNumber, initialLatestCallLog }: TestClientProps) {
  const [isCalling, setIsCalling] = useState(false);
  const [liveTranscript, setLiveTranscript] = useState<Array<{speaker: string, text: string}>>([]);
  const [callStatus, setCallStatus] = useState("Idle");
  const [phoneNumber] = useState(initialPhoneNumber);
  const [latestCallLog] = useState(initialLatestCallLog);
  
  const vapiRef = useRef<Vapi | null>(null); // Initialize vapiRef

  useEffect(() => {
    if (!process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY) {
      console.error("NEXT_PUBLIC_VAPI_PUBLIC_KEY is not set.");
      setCallStatus("Error: Vapi Public Key not configured.");
      return;
    }
    const vapiInstance = new Vapi(process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY);
    vapiRef.current = vapiInstance;

    vapiInstance.on('call-start', () => {
      console.log('Vapi call started');
      setIsCalling(true);
      setCallStatus("In Progress...");
      setLiveTranscript([]); // Clear previous transcript
    });

    vapiInstance.on('call-end', () => {
      console.log('Vapi call ended');
      setIsCalling(false);
      setCallStatus("Call Ended. Refresh to see updated log.");
      // Consider adding a server action call here to immediately fetch the latest call log
      // and update `setLatestCallLog`. For now, user needs to refresh page.
    });

    vapiInstance.on('error', (e) => {
      console.error('Vapi SDK error:', e);
      setIsCalling(false);
      setCallStatus(`Error: ${e?.message || 'Unknown Vapi error'}`);
    });

    vapiInstance.on('message', (message) => {
      // console.log('Vapi message:', message); // For debugging all messages
      if (message.type === 'transcript') {
        const role = message.role === 'assistant' ? 'Laine' : 'User';
        if (message.transcriptType === 'final') {
          setLiveTranscript(prev => [...prev, { speaker: role, text: message.transcript }]);
        }
      }
      if (message.type === 'status-update' && message.status) {
         // Example: "ringing", "in-progress", "forwarding", "ended"
        setCallStatus(message.status.charAt(0).toUpperCase() + message.status.slice(1));
      }
      // Add more message handlers if needed (e.g., 'speech-start', 'speech-end')
    });
    
    return () => {
      // Cleanup: stop call and remove listeners if component unmounts
      if (vapiRef.current) {
        vapiRef.current.stop();
      }
      vapiInstance.removeAllListeners();
    };
  }, []); // Empty dependency array ensures this runs once on mount

  const handleStartCall = () => {
    if (vapiRef.current && vapiAssistantId) {
      setCallStatus("Starting call...");
      vapiRef.current.start(vapiAssistantId);
    }
  };

  const handleStopCall = () => {
    if (vapiRef.current) {
      setCallStatus("Stopping call...");
      vapiRef.current.stop();
    }
  };

  // Function to interpret endedReason for success/fail
  const getCallOutcome = (log: LatestCallLogData | null) => {
    if (!log || !log.endedReason) return "Status Unknown";
    if (log.endedReason.toLowerCase().includes("error") || log.endedReason.toLowerCase().includes("failed")) {
      return `Failed: ${log.endedReason}`;
    }
    if (["assistant-ended-call", "customer-ended-call", "hangup"].includes(log.endedReason.toLowerCase())) {
      return `Call completed (${log.endedReason})`;
    }
    return `Ended: ${log.endedReason}`;
  };
  
  const handleRefreshLatestCall = async () => {
    // Placeholder: In a real app, you might call a server action to re-fetch
    // For now, this button won't do anything until we implement re-fetching if needed.
    alert("Re-fetching latest call log - not yet implemented in this phase. Call data updates after a new call ends and page reloads or via live updates if implemented.");
  };

  const handlePhoneCall = () => {
    window.open('tel:+19203927291', '_self');
  };

  return (
    <div className="space-y-8">
      {/* Phone Call Component */}
      <div className="bg-gradient-to-r from-blue-600 to-purple-600 p-6 rounded-xl shadow-lg">
        <div className="flex items-center justify-center space-x-4">
          <div className="flex items-center space-x-3">
            <div className="bg-white/20 p-3 rounded-full">
              <span className="text-2xl">📞</span>
            </div>
            <div>
              <h3 className="text-xl font-semibold text-white mb-1">Talk to Laine on the Phone</h3>
              <p className="text-blue-100 text-sm">Experience our AI dental assistant over the phone</p>
            </div>
          </div>
          <button
            onClick={handlePhoneCall}
            className="bg-white text-blue-600 hover:bg-blue-50 px-6 py-3 rounded-lg font-semibold transition-all duration-200 hover:scale-105 shadow-md"
          >
            <div className="flex items-center space-x-2">
              <span className="text-lg">📱</span>
              <span>+1 (920) 392-7291</span>
            </div>
          </button>
        </div>
      </div>

      <div className="bg-white p-6 rounded-lg shadow-md">
        <h2 className="text-xl font-semibold mb-4 text-slate-700">Test Your Laine Assistant</h2>
        <p className="text-sm text-gray-600 mb-1">Assistant ID: <span className="font-mono text-blue-600">{vapiAssistantId}</span></p>
        {phoneNumber && (
          <p className="text-sm text-gray-600 mb-4">
            Or, Call Laine at: <strong className="text-blue-600">{phoneNumber}</strong>
          </p>
        )}

        {/* Web Call Module Placeholder */}
        <div className="mt-4 space-x-2">
          <button 
            onClick={handleStartCall} 
            disabled={isCalling || callStatus.startsWith("Error:")}
            className="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isCalling ? "Calling..." : "Start Web Call"}
          </button>
          <button
            onClick={handleStopCall} 
            disabled={!isCalling}
            className="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Stop Web Call
          </button>
        </div>
        <p className="mt-2 text-sm text-gray-500">Call Status: <span className="font-semibold">{callStatus}</span></p>
        
        <div className="mt-4 p-4 bg-gray-50 rounded-md border border-gray-200 max-h-60 overflow-y-auto">
          <h3 className="text-md font-semibold text-gray-700 mb-2">Live Transcript:</h3>
          {liveTranscript.length === 0 && <p className="text-xs text-gray-500 italic">Transcript will appear here...</p>}
          {liveTranscript.map((entry, index) => (
             <p key={index} className="text-xs text-gray-800 mb-1">
               <strong className={entry.speaker === 'Laine' ? 'text-blue-600' : 'text-green-600'}>{entry.speaker}:</strong> {entry.text}
             </p>
          ))}
        </div>
      </div>

      {/* Latest Call Info */}
      <div className="bg-white p-6 rounded-lg shadow-md">
        <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-semibold text-slate-700">Latest Call Information</h3>
            <button 
                onClick={handleRefreshLatestCall}
                className="px-3 py-1 text-xs bg-blue-500 text-white rounded-md hover:bg-blue-600"
            >
                Refresh
            </button>
        </div>
        {latestCallLog ? (
          <div className="space-y-3">
            <p className="text-sm">
              <strong>Call Time:</strong> {new Date(latestCallLog.createdAt).toLocaleString()}
            </p>
            <p className="text-sm">
              <strong>Outcome:</strong> {getCallOutcome(latestCallLog)}
            </p>
            {latestCallLog.recordingUrl && (
              <div>
                <strong className="text-sm">Recording:</strong>
                <audio src={latestCallLog.recordingUrl} controls className="w-full mt-1" />
              </div>
            )}
            {latestCallLog.transcriptText && (
              <div>
                <strong className="text-sm">Full Transcript:</strong>
                <pre className="mt-1 text-xs bg-gray-50 p-3 rounded-md border border-gray-200 max-h-48 overflow-y-auto whitespace-pre-wrap">
                  {latestCallLog.transcriptText}
                </pre>
              </div>
            )}
            {latestCallLog.summary && (
                <div>
                    <strong className="text-sm">Vapi Summary:</strong>
                    <p className="mt-1 text-xs bg-gray-50 p-3 rounded-md border border-gray-200 whitespace-pre-wrap">
                        {latestCallLog.summary}
                    </p>
                </div>
            )}
          </div>
        ) : (
          <p className="text-sm text-gray-500 italic">No call history found for this practice.</p>
        )}
      </div>
    </div>
  );
}

================
File: lib/ai/summarization.ts
================
import { generateText, CoreMessage } from 'ai';
import { openai } from '@ai-sdk/openai';

export async function generateCallSummaryForNote(transcript: string): Promise<string> {
  if (!transcript || transcript.trim() === "") {
    console.warn("[Summarization] Empty transcript provided, returning default note.");
    return "Call booked via Laine AI. No detailed transcript summary available.";
  }

  // Ensure OPENAI_API_KEY is available
  if (!process.env.OPENAI_API_KEY) {
    console.error("[Summarization] OPENAI_API_KEY is not set. Cannot generate summary.");
    throw new Error("OpenAI API key not configured for summarization.");
  }

  const messages: CoreMessage[] = [
    {
      role: 'system',
      content: `You are an expert summarization AI for a dental office. 
      Your task is to summarize the following call transcript into a concise note for the appointment record. 
      The note should be factual and directly relevant for the dental staff.
      Focus on:
      1. Patient's primary reason for the call/appointment.
      2. Key symptoms or requests mentioned by the patient.
      3. Any specific treatments discussed or agreed upon.
      4. Relevant patient history if mentioned (e.g., "new patient", "returning for follow-up").
      Keep the summary very brief and professional, ideally under 50-75 words.
      Start the summary directly without introductory phrases like "The patient called to..." or "Summary:".
      Example: "New patient, toothache in lower right molar for 3 days, sensitive to cold. Discussed limited exam and X-ray."
      `,
    },
    {
      role: 'user',
      content: `Call Transcript:\n"""\n${transcript}\n"""`,
    },
  ];

  try {
    const { text, finishReason, usage } = await generateText({
      model: openai('gpt-4o-mini'), // Using GPT-4o as specified
      messages,
      temperature: 0.3, // Lower temperature for more factual summary
      maxTokens: 330,   // Max tokens for the summary itself
    });
    console.log(`[Summarization] Summary generated. Finish reason: ${finishReason}, Usage: ${JSON.stringify(usage)}`);
    return text.trim();
  } catch (error) {
    console.error("[Summarization] Error generating call summary with OpenAI:", error);
    // Fallback to a simpler note if summarization fails
    return "Call booked via Laine AI. AI summary generation encountered an issue.";
  }
}

================
File: lib/vapi.ts
================
// VAPI API Client for managing assistants and calls
// Docs: https://docs.vapi.ai

const VAPI_API_BASE_URL = "https://api.vapi.ai";
const VAPI_API_KEY = process.env.VAPI_API_KEY;

if (!VAPI_API_KEY) {
  console.warn("VAPI_API_KEY not configured - VAPI features will not work");
}

// Basic VAPI types based on their API documentation
export interface VapiModel {
  provider: "openai" | "groq" | "anthropic" | "anyscale" | "togetherai";
  model: string; // e.g., "gpt-3.5-turbo", "gpt-4", etc.
  temperature?: number;
  maxTokens?: number;
  messages: Array<{
    role: "system" | "user" | "assistant" | "function";
    content: string;
  }>;
  tools?: VapiTool[];
}

export interface VapiVoice {
  provider: "11labs" | "openai" | "playht" | "lmnt" | "neets" | "rime" | "vapi";
  voiceId: string; // Provider-specific voice ID
  speed?: number;
  stability?: number;
  similarityBoost?: number;
  style?: number;
  useSpeakerBoost?: boolean;
}

export interface VapiTool {
  type: "function";
  async?: boolean;
  function: {
    name: string;
    description: string;
    parameters: Record<string, unknown>; // JSON Schema object
  };
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

export interface VapiAssistant {
  id: string;
  name: string;
  model: VapiModel;
  voice: VapiVoice;
  firstMessage?: string;
  serverUrl?: string;
  serverMessages?: string[];
  silenceTimeoutSeconds?: number;
  maxDurationSeconds?: number;
  backgroundSound?: "off" | "office";
  backchannelingEnabled?: boolean;
  backgroundDenoisingEnabled?: boolean;
  modelOutputInMessagesEnabled?: boolean;
  transportConfigurations?: Record<string, unknown>[];
  createdAt: string;
  updatedAt: string;
}

export interface CreateAssistantDTO {
  name: string;
  model: VapiModel;
  voice: VapiVoice;
  firstMessage?: string;
  serverUrl?: string;
  serverMessages?: string[];
  silenceTimeoutSeconds?: number;
  maxDurationSeconds?: number;
  backgroundSound?: "off" | "office";
  backchannelingEnabled?: boolean;
  backgroundDenoisingEnabled?: boolean;
  modelOutputInMessagesEnabled?: boolean;
  transportConfigurations?: Record<string, unknown>[];
}

export interface UpdateAssistantDTO extends Partial<CreateAssistantDTO> {
  // All fields from CreateAssistantDTO are optional for updates
  // This interface extends Partial<CreateAssistantDTO> to allow partial updates
  _placeholder?: never; // Placeholder to avoid empty interface error
}

async function vapiRequest(
  endpoint: string,
  method: "GET" | "POST" | "PATCH" | "DELETE" = "GET",
  body?: Record<string, unknown>
): Promise<Record<string, unknown>> {
  if (!VAPI_API_KEY) {
    throw new Error("VAPI_API_KEY is not configured");
  }

  const url = `${VAPI_API_BASE_URL}${endpoint}`;
  
  const options: RequestInit = {
    method,
    headers: {
      "Authorization": `Bearer ${VAPI_API_KEY}`,
      "Content-Type": "application/json",
    },
  };

  if (body && method !== "GET") {
    options.body = JSON.stringify(body);
  }

  console.log(`VAPI API: ${method} ${url}`);
  if (body) {
    console.log("VAPI API body:", JSON.stringify(body, null, 2));
  }

  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`VAPI API error (${response.status}):`, errorText);
      throw new Error(`VAPI API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    console.log(`VAPI API response:`, JSON.stringify(data, null, 2));
    return data as Record<string, unknown>;
  } catch (error) {
    console.error("VAPI API request failed:", error);
    throw error;
  }
}

export async function createVapiAssistant(assistantConfig: CreateAssistantDTO): Promise<VapiAssistant> {
  console.log("Creating VAPI assistant:", assistantConfig.name);
  const result = await vapiRequest("/assistant", "POST", assistantConfig as unknown as Record<string, unknown>);
  return result as unknown as VapiAssistant;
}

export async function updateVapiAssistant(
  assistantId: string, 
  assistantConfig: UpdateAssistantDTO
): Promise<VapiAssistant> {
  console.log(`Updating VAPI assistant ${assistantId}`);
  const result = await vapiRequest(`/assistant/${assistantId}`, "PATCH", assistantConfig as unknown as Record<string, unknown>);
  return result as unknown as VapiAssistant;
}

export async function getVapiAssistant(assistantId: string): Promise<VapiAssistant | null> {
  try {
    console.log(`Getting VAPI assistant ${assistantId}`);
    const result = await vapiRequest(`/assistant/${assistantId}`, "GET");
    return result as unknown as VapiAssistant;
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes("404")) {
      console.log(`VAPI assistant ${assistantId} not found`);
      return null;
    }
    throw error;
  }
}

export async function deleteVapiAssistant(assistantId: string): Promise<void> {
  console.log(`Deleting VAPI assistant ${assistantId}`);
  await vapiRequest(`/assistant/${assistantId}`, "DELETE");
}

// Function to verify VAPI webhook requests (if VAPI provides signing)
export async function verifyVapiRequest(): Promise<{ verified: boolean; error?: string }> {
  // TODO: Implement if VAPI provides request signing
  // For now, return true as a placeholder
  console.log("VAPI request verification - not yet implemented");
  return { verified: true };
}

================
File: middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isProtectedRoute = createRouteMatcher([
  '/practice-config(.*)',
  '/laine(.*)',
  '/test(.*)',
]);

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) {
    await auth.protect();
  }
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};

================
File: app/api/practice-config/data/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({ 
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: {
          select: {
            id: true,
            nexhealthAppointmentTypeId: true,
            name: true,
            duration: true,
            bookableOnline: true,
            groupCode: true,
            createdAt: true,
            updatedAt: true
          }
        },
        providers: {
          select: {
            id: true,
            nexhealthProviderId: true,
            firstName: true,
            lastName: true
          }
        },
        savedProviders: {
          select: {
            id: true,
            providerId: true,
            isActive: true,
            provider: {
              select: {
                id: true,
                nexhealthProviderId: true,
                firstName: true,
                lastName: true
              }
            }
          },
          where: { isActive: true }
        },
        savedOperatories: {
          select: {
            id: true,
            nexhealthOperatoryId: true,
            name: true,
            isActive: true
          },
          where: { isActive: true }
        }
      }
    });

    // Check if global webhook endpoint is configured
    const globalWebhookEndpoint = await prisma.globalNexhealthWebhookEndpoint.findUnique({
      where: { id: "singleton" }
    });

    return NextResponse.json({
      practice,
      globalWebhookEndpoint
    });

  } catch (error) {
    console.error("Error fetching practice data:", error);
    return NextResponse.json(
      { error: "Failed to fetch practice data" },
      { status: 500 }
    );
  }
}

================
File: app/practice-config/ProvidersConfig.tsx
================
"use client";

import { useState } from "react";
import { toast } from "sonner";

interface Provider {
  id: string;
  nexhealthProviderId: string;
  firstName: string | null;
  lastName: string;
}

interface SavedProvider {
  id: string;
  providerId: string;
  isActive: boolean;
  provider: Provider;
}

interface AppointmentType {
  id: string;
  nexhealthAppointmentTypeId: string;
  name: string;
  duration: number;
  bookableOnline: boolean | null;
  groupCode: string | null;
}

interface SavedOperatory {
  id: string;
  nexhealthOperatoryId: string;
  name: string;
  isActive: boolean;
}

interface ProviderSettings {
  acceptedAppointmentTypeIds: string[];
  defaultAppointmentTypeId: string | null;
  defaultOperatoryId: string | null;
  assignedOperatoryIds: string[]; // NEW: Multiple operatories
}

interface ProvidersConfigProps {
  savedProviders: SavedProvider[];
  allProviders: Provider[]; // Add raw providers
  allAppointmentTypes: AppointmentType[];
  allOperatories: SavedOperatory[];
  onUpdate: () => void;
}

export function ProvidersConfig({
  savedProviders,
  allProviders,
  allAppointmentTypes,
  allOperatories,
  onUpdate
}: ProvidersConfigProps) {
  const [expandedProvider, setExpandedProvider] = useState<string | null>(null);
  const [providerSettings, setProviderSettings] = useState<{ [key: string]: ProviderSettings }>({});
  const [loading, setLoading] = useState<{ [key: string]: boolean }>({});
  const [fetchingSettings, setFetchingSettings] = useState<{ [key: string]: boolean }>({});
  const [selectedProviders, setSelectedProviders] = useState<string[]>([]);
  const [syncLoading, setSyncLoading] = useState(false);
  const [activationLoading, setActivationLoading] = useState(false);

  const activeProviders = savedProviders.filter(sp => sp.isActive);
  
  // Get unactivated providers (exist in allProviders but not in savedProviders)
  const savedProviderIds = new Set(savedProviders.map(sp => sp.providerId));
  const unactivatedProviders = allProviders.filter(p => !savedProviderIds.has(p.id));

  const fetchProviderSettings = async (savedProviderId: string) => {
    setFetchingSettings(prev => ({ ...prev, [savedProviderId]: true }));
    try {
      const response = await fetch(`/api/practice-config/provider-settings/${savedProviderId}`);
      if (response.ok) {
        const settings = await response.json();
        setProviderSettings(prev => ({
          ...prev,
          [savedProviderId]: {
            acceptedAppointmentTypeIds: Array.isArray(settings.acceptedAppointmentTypes) ? settings.acceptedAppointmentTypes.map((at: { id: string }) => at.id) : [],
            defaultAppointmentTypeId: settings.defaultAppointmentTypeId || null,
            defaultOperatoryId: settings.defaultOperatoryId || null,
            assignedOperatoryIds: Array.isArray(settings.assignedOperatories) ? settings.assignedOperatories.map((op: { id: string }) => op.id) : []
          }
        }));
      } else {
        // Initialize with empty settings if none exist
        setProviderSettings(prev => ({
          ...prev,
          [savedProviderId]: {
            acceptedAppointmentTypeIds: [],
            defaultAppointmentTypeId: null,
            defaultOperatoryId: null,
            assignedOperatoryIds: []
          }
        }));
      }
    } catch (error) {
      console.error('Error fetching provider settings:', error);
      toast.error('Failed to fetch provider settings');
    } finally {
      setFetchingSettings(prev => ({ ...prev, [savedProviderId]: false }));
    }
  };

  const handleProviderExpand = async (savedProviderId: string) => {
    if (expandedProvider === savedProviderId) {
      setExpandedProvider(null);
    } else {
      setExpandedProvider(savedProviderId);
      if (!providerSettings[savedProviderId]) {
        await fetchProviderSettings(savedProviderId);
      }
    }
  };

  const updateProviderSetting = (savedProviderId: string, field: keyof ProviderSettings, value: string | string[] | null) => {
    setProviderSettings(prev => ({
      ...prev,
      [savedProviderId]: {
        ...prev[savedProviderId],
        [field]: value
      }
    }));
  };

  const handleAcceptedTypesChange = (savedProviderId: string, appointmentTypeId: string, checked: boolean) => {
    const currentSettings = providerSettings[savedProviderId];
    let newAcceptedTypes: string[];
    
    if (checked) {
      newAcceptedTypes = [...(currentSettings?.acceptedAppointmentTypeIds || []), appointmentTypeId];
    } else {
      newAcceptedTypes = (currentSettings?.acceptedAppointmentTypeIds || []).filter(id => id !== appointmentTypeId);
      // If we're removing the default appointment type, clear it
      if (currentSettings?.defaultAppointmentTypeId === appointmentTypeId) {
        updateProviderSetting(savedProviderId, 'defaultAppointmentTypeId', null);
      }
    }
    
    updateProviderSetting(savedProviderId, 'acceptedAppointmentTypeIds', newAcceptedTypes);
  };

  const handleOperatoryAssignmentChange = (savedProviderId: string, operatoryId: string, checked: boolean) => {
    const currentSettings = providerSettings[savedProviderId];
    let newAssignedOperatories: string[];
    
    if (checked) {
      newAssignedOperatories = [...(currentSettings?.assignedOperatoryIds || []), operatoryId];
    } else {
      newAssignedOperatories = (currentSettings?.assignedOperatoryIds || []).filter(id => id !== operatoryId);
      // If we're removing the default operatory, clear it
      if (currentSettings?.defaultOperatoryId === operatoryId) {
        updateProviderSetting(savedProviderId, 'defaultOperatoryId', null);
      }
    }
    
    updateProviderSetting(savedProviderId, 'assignedOperatoryIds', newAssignedOperatories);
  };

  const saveProviderSettings = async (savedProviderId: string) => {
    const settings = providerSettings[savedProviderId];
    if (!settings) return;

    // Ensure data types are correct before sending
    const payload = {
      acceptedAppointmentTypeIds: Array.isArray(settings.acceptedAppointmentTypeIds) ? settings.acceptedAppointmentTypeIds : [],
      defaultAppointmentTypeId: settings.defaultAppointmentTypeId || null,
      defaultOperatoryId: settings.defaultOperatoryId || null,
      assignedOperatoryIds: Array.isArray(settings.assignedOperatoryIds) ? settings.assignedOperatoryIds : []
    };

    console.log('🔍 Saving provider settings:', {
      savedProviderId,
      payload,
      payloadTypes: Object.keys(payload).map(key => `${key}: ${typeof payload[key as keyof typeof payload]} (${Array.isArray(payload[key as keyof typeof payload]) ? 'array' : 'not array'})`)
    });

    setLoading(prev => ({ ...prev, [savedProviderId]: true }));
    try {
      const response = await fetch(`/api/practice-config/provider-settings/${savedProviderId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (response.ok) {
        toast.success('Provider settings saved successfully!');
        onUpdate();
      } else {
        const error = await response.json();
        console.error('❌ API Error Response:', error);
        
        // Show more detailed error information
        if (error.issues && Array.isArray(error.issues)) {
          const errorMessages = error.issues.map((issue: any) => `${issue.path}: ${issue.message}`).join(', ');
          toast.error(`Validation failed: ${errorMessages}`);
        } else {
          toast.error(`Failed to save: ${error.error || 'Unknown error'}`);
        }
      }
    } catch (error) {
      console.error('Error saving provider settings:', error);
      toast.error('Failed to save provider settings');
    } finally {
      setLoading(prev => ({ ...prev, [savedProviderId]: false }));
    }
  };

  const getProviderName = (provider: Provider) => {
    return `${provider.firstName || ''} ${provider.lastName}`.trim() || 'Unnamed Provider';
  };

  const getAcceptedAppointmentTypes = (savedProviderId: string) => {
    const settings = providerSettings[savedProviderId];
    if (!settings) return [];
    return allAppointmentTypes.filter(at => settings.acceptedAppointmentTypeIds.includes(at.id));
  };

  const handleSyncNexHealth = async () => {
    setSyncLoading(true);
    try {
      const response = await fetch('/api/sync-nexhealth', {
        method: 'POST'
      });

      if (response.ok) {
        const result = await response.json();
        toast.success(`Successfully synced ${result.data.providersCount} providers and ${result.data.operatoriesCount} operatories!`);
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Sync failed: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error syncing with NexHealth:', error);
      toast.error('Failed to sync with NexHealth');
    } finally {
      setSyncLoading(false);
    }
  };

  const handleProviderSelection = (providerId: string, checked: boolean) => {
    setSelectedProviders(prev => 
      checked 
        ? [...prev, providerId]
        : prev.filter(id => id !== providerId)
    );
  };

  const handleActivateProviders = async () => {
    if (selectedProviders.length === 0) {
      toast.error('Please select at least one provider to activate');
      return;
    }

    setActivationLoading(true);
    try {
      const response = await fetch('/api/practice-config/providers/activate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ providerIds: selectedProviders })
      });

      if (response.ok) {
        const result = await response.json();
        toast.success(`Successfully activated ${result.activatedProviders} provider(s)!`);
        setSelectedProviders([]);
        onUpdate();
      } else {
        const error = await response.json();
        toast.error(`Activation failed: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error activating providers:', error);
      toast.error('Failed to activate providers');
    } finally {
      setActivationLoading(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-xl font-semibold">Providers Configuration</h2>
        <button
          onClick={handleSyncNexHealth}
          disabled={syncLoading}
          className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
        >
          {syncLoading ? 'Syncing...' : 'Sync from NexHealth'}
        </button>
      </div>
      
      {activeProviders.length === 0 ? (
        <div className="space-y-6">
          {unactivatedProviders.length > 0 ? (
            <>
              <div className="text-center py-4">
                <p className="text-gray-600 mb-4">
                  Found {unactivatedProviders.length} provider(s) from NexHealth. Select providers to activate:
                </p>
              </div>
              
              <div className="space-y-3">
                {unactivatedProviders.map((provider) => (
                  <label key={provider.id} className="flex items-center p-3 border border-gray-200 rounded-lg hover:bg-gray-50">
                    <input
                      type="checkbox"
                      checked={selectedProviders.includes(provider.id)}
                      onChange={(e) => handleProviderSelection(provider.id, e.target.checked)}
                      className="mr-3"
                    />
                    <div className="flex-1">
                      <h3 className="font-medium text-gray-900">
                        {getProviderName(provider)}
                      </h3>
                      <p className="text-sm text-gray-500">
                        Provider ID: {provider.nexhealthProviderId}
                      </p>
                    </div>
                  </label>
                ))}
              </div>
              
              {selectedProviders.length > 0 && (
                <div className="flex justify-center">
                  <button
                    onClick={handleActivateProviders}
                    disabled={activationLoading}
                    className="bg-green-600 text-white px-6 py-2 rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {activationLoading ? 'Activating...' : `Activate ${selectedProviders.length} Provider(s)`}
                  </button>
                </div>
              )}
            </>
          ) : allProviders.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              <p className="mb-4">No providers found. Please sync with NexHealth first.</p>
              <button
                onClick={handleSyncNexHealth}
                disabled={syncLoading}
                className="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {syncLoading ? 'Syncing...' : 'Sync from NexHealth'}
              </button>
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500">
              <p>All providers have been synced but none are activated.</p>
            </div>
          )}
        </div>
      ) : (
        <div className="space-y-4">
          {activeProviders.map((savedProvider) => (
            <div key={savedProvider.id} className="border border-gray-200 rounded-lg">
              <div
                className="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50"
                onClick={() => handleProviderExpand(savedProvider.id)}
              >
                <div>
                  <h3 className="font-medium text-gray-900">
                    {getProviderName(savedProvider.provider)}
                  </h3>
                  <p className="text-sm text-gray-500">
                    Provider ID: {savedProvider.provider.nexhealthProviderId}
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-sm text-gray-500">
                    {expandedProvider === savedProvider.id ? 'Collapse' : 'Configure'}
                  </span>
                  <svg
                    className={`w-5 h-5 text-gray-500 transition-transform ${
                      expandedProvider === savedProvider.id ? 'rotate-180' : ''
                    }`}
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </div>
              </div>

              {expandedProvider === savedProvider.id && (
                <div className="border-t border-gray-200 p-4">
                  {fetchingSettings[savedProvider.id] ? (
                    <div className="text-center py-4 text-gray-500">Loading settings...</div>
                  ) : (
                    <div className="space-y-6">
                      {/* Accepted Appointment Types */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Accepted Appointment Types</h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                          {allAppointmentTypes.map((appointmentType) => (
                            <label key={appointmentType.id} className="flex items-center">
                              <input
                                type="checkbox"
                                checked={providerSettings[savedProvider.id]?.acceptedAppointmentTypeIds.includes(appointmentType.id) || false}
                                onChange={(e) => handleAcceptedTypesChange(savedProvider.id, appointmentType.id, e.target.checked)}
                                className="mr-2"
                              />
                              <span className="text-sm text-gray-700">
                                {appointmentType.name} ({appointmentType.duration} min)
                              </span>
                            </label>
                          ))}
                        </div>
                      </div>

                      {/* Default Appointment Type */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Default Appointment Type</h4>
                        <select
                          value={providerSettings[savedProvider.id]?.defaultAppointmentTypeId || ''}
                          onChange={(e) => updateProviderSetting(savedProvider.id, 'defaultAppointmentTypeId', e.target.value || null)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          <option value="">Select default appointment type</option>
                          {getAcceptedAppointmentTypes(savedProvider.id).map((appointmentType) => (
                            <option key={appointmentType.id} value={appointmentType.id}>
                              {appointmentType.name} ({appointmentType.duration} min)
                            </option>
                          ))}
                        </select>
                      </div>

                      {/* Assigned Operatories */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Assigned Operatories</h4>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                          {allOperatories.filter(op => op.isActive).map((operatory) => (
                            <label key={operatory.id} className="flex items-center">
                              <input
                                type="checkbox"
                                checked={providerSettings[savedProvider.id]?.assignedOperatoryIds.includes(operatory.id) || false}
                                onChange={(e) => handleOperatoryAssignmentChange(savedProvider.id, operatory.id, e.target.checked)}
                                className="mr-2"
                              />
                              <span className="text-sm text-gray-700">
                                {operatory.name} (ID: {operatory.nexhealthOperatoryId})
                              </span>
                            </label>
                          ))}
                        </div>
                      </div>

                      {/* Default Operatory */}
                      <div>
                        <h4 className="font-medium text-gray-900 mb-3">Default Operatory</h4>
                        <select
                          value={providerSettings[savedProvider.id]?.defaultOperatoryId || ''}
                          onChange={(e) => updateProviderSetting(savedProvider.id, 'defaultOperatoryId', e.target.value || null)}
                          className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          <option value="">Select default operatory</option>
                          {allOperatories
                            .filter(op => op.isActive && (providerSettings[savedProvider.id]?.assignedOperatoryIds.includes(op.id) || false))
                            .map((operatory) => (
                              <option key={operatory.id} value={operatory.id}>
                                {operatory.name} (ID: {operatory.nexhealthOperatoryId})
                              </option>
                            ))}
                        </select>
                      </div>

                      {/* Save Button */}
                      <div className="flex justify-end pt-4">
                        <button
                          onClick={() => saveProviderSettings(savedProvider.id)}
                          disabled={loading[savedProvider.id]}
                          className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                          {loading[savedProvider.id] ? 'Saving...' : 'Save Settings'}
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

================
File: app/page.tsx
================
import Link from "next/link";
import { auth } from "@clerk/nextjs/server";

export default async function HomePage() {
  const { userId } = await auth();

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-white to-slate-100">
      <div className="max-w-6xl mx-auto px-6 py-16">
        {/* Hero Section */}
        <div className="text-center max-w-4xl mx-auto mb-20">
          <div className="mb-6">
            <span className="inline-block px-4 py-2 bg-blue-50 text-blue-700 text-sm font-medium rounded-full border border-blue-200">
              Now Available
            </span>
          </div>
          
          <h1 className="text-5xl md:text-6xl font-bold text-slate-900 mb-6 leading-tight">
            Laine Voice AI
          </h1>
          
          <p className="text-xl text-slate-600 mb-10 leading-relaxed max-w-2xl mx-auto">
            Intelligent voice assistant that seamlessly integrates with your EHR system to streamline appointment scheduling and enhance patient communication.
          </p>
          
          {userId ? (
            <div className="space-y-6">
              <p className="text-lg text-slate-700">
                Welcome back! Ready to configure your practice?
              </p>
              <Link
                href="/practice-config"
                className="inline-flex items-center px-8 py-4 bg-blue-600 text-white font-semibold rounded-xl hover:bg-blue-700 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5"
              >
                Go to Practice Configuration
                <svg className="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </Link>
            </div>
          ) : (
            <div className="space-y-6">
              <p className="text-lg text-slate-700">
                Get started by creating your account to configure your practice.
              </p>
              <div className="flex flex-col sm:flex-row gap-4 justify-center items-center">
                <Link
                  href="/sign-up"
                  className="inline-flex items-center px-8 py-4 bg-blue-600 text-white font-semibold rounded-xl hover:bg-blue-700 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:-translate-y-0.5"
                >
                  Get Started
                  <svg className="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </Link>
                <Link
                  href="/sign-in"
                  className="inline-flex items-center px-8 py-4 bg-white text-slate-700 font-semibold rounded-xl border-2 border-slate-200 hover:border-slate-300 hover:bg-slate-50 transition-all duration-200"
                >
                  Sign In
                </Link>
              </div>
            </div>
          )}
        </div>

        {/* Features Grid */}
        <div className="max-w-4xl mx-auto">
          {/* Core Features */}
          <div className="bg-white rounded-2xl p-8 shadow-sm border border-slate-200 hover:shadow-md transition-shadow duration-200">
            <div className="flex items-center mb-6">
              <div className="w-12 h-12 bg-blue-100 rounded-xl flex items-center justify-center mr-4">
                <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                </svg>
              </div>
              <h3 className="text-2xl font-bold text-slate-900">Core Capabilities</h3>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-4">
                {[
                  "Voice-Powered Scheduling",
                  "EHR System Integration", 
                  "Natural Language Processing",
                  "Real-time Appointment Management"
                ].map((feature, index) => (
                  <div key={index} className="flex items-center">
                    <div className="w-5 h-5 bg-blue-100 rounded-full flex items-center justify-center mr-3">
                      <svg className="w-3 h-3 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    </div>
                    <span className="text-slate-700 font-medium">{feature}</span>
                  </div>
                ))}
              </div>
              <div className="space-y-4">
                {[
                  "Automated Patient Communication",
                  "Practice Workflow Optimization",
                  "Secure Data Handling",
                  "24/7 Availability"
                ].map((feature, index) => (
                  <div key={index} className="flex items-center">
                    <div className="w-5 h-5 bg-blue-100 rounded-full flex items-center justify-center mr-3">
                      <svg className="w-3 h-3 text-blue-600" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    </div>
                    <span className="text-slate-700 font-medium">{feature}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>

        {/* Bottom CTA */}
        <div className="text-center mt-20">
          <div className="max-w-2xl mx-auto">
            <h2 className="text-3xl font-bold text-slate-900 mb-4">
              Ready to Enhance Your Practice?
            </h2>
            <p className="text-lg text-slate-600 mb-8">
              Transform your appointment scheduling with AI-powered voice assistance that integrates seamlessly with your existing systems.
            </p>
            {!userId && (
              <Link
                href="/sign-up"
                className="inline-flex items-center px-8 py-4 bg-slate-900 text-white font-semibold rounded-xl hover:bg-slate-800 transition-all duration-200 shadow-lg hover:shadow-xl"
              >
                Start Your Configuration
                <svg className="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </Link>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: lib/utils/error-messages.ts
================
/**
 * Standardized error message templates for patient-facing responses
 * These provide consistent, professional, and helpful messages across all tools
 */

export interface ErrorMessageTemplate {
  code: string;
  message: string;
  category: 'technical' | 'validation' | 'not_found' | 'permission' | 'timeout';
}

export const ERROR_MESSAGES: Record<string, ErrorMessageTemplate> = {
  // Authentication & Permission Errors
  AUTHENTICATION_ERROR: {
    code: 'AUTHENTICATION_ERROR',
    message: "I'm having trouble accessing the system right now. Please contact the office for assistance.",
    category: 'permission'
  },
  
  PERMISSION_ERROR: {
    code: 'PERMISSION_ERROR', 
    message: "I don't have permission to access that information. Please contact the office.",
    category: 'permission'
  },

  // Practice Configuration Errors
  PRACTICE_NOT_FOUND: {
    code: 'PRACTICE_NOT_FOUND',
    message: "I'm having trouble identifying the practice settings. Please contact the office.",
    category: 'technical'
  },

  PRACTICE_NOT_CONFIGURED: {
    code: 'PRACTICE_NOT_CONFIGURED',
    message: "The practice scheduling system isn't fully set up yet. Please contact the office to schedule your appointment.",
    category: 'technical'
  },

  // Patient Lookup Errors
  PATIENT_NOT_FOUND: {
    code: 'PATIENT_NOT_FOUND',
    message: "I couldn't find your information in our system. Could you please verify your name and date of birth, or contact the office directly?",
    category: 'not_found'
  },

  PATIENT_MULTIPLE_MATCHES: {
    code: 'PATIENT_MULTIPLE_MATCHES',
    message: "I found multiple patients with similar information. For your privacy and security, please contact the office directly to schedule your appointment.",
    category: 'validation'
  },

  // Appointment Type Errors
  APPOINTMENT_TYPE_NOT_FOUND: {
    code: 'APPOINTMENT_TYPE_NOT_FOUND',
    message: "I'm not sure what type of appointment you're looking for. Could you describe what you need, or would you like me to list the available services?",
    category: 'not_found'
  },

  APPOINTMENT_TYPE_AMBIGUOUS: {
    code: 'APPOINTMENT_TYPE_AMBIGUOUS', 
    message: "I found several services that might match what you're looking for. Let me help you choose the right one.",
    category: 'validation'
  },

  // Availability & Scheduling Errors
  NO_AVAILABILITY: {
    code: 'NO_AVAILABILITY',
    message: "I don't see any available appointments for that time. Would you like me to check other dates or contact the office for more options?",
    category: 'not_found'
  },

  SCHEDULING_ERROR: {
    code: 'SCHEDULING_ERROR',
    message: "I encountered an issue while checking availability. Please try again or contact the office directly.",
    category: 'technical'
  },

  // Validation Errors - General
  VALIDATION_ERROR: {
    code: 'VALIDATION_ERROR',
    message: "I received some unexpected information. Could you try rephrasing that?",
    category: 'validation'
  },

  // Validation Errors - Specific to New Patient Creation
  MISSING_PHONE: {
    code: 'MISSING_PHONE',
    message: "I need your phone number to create your patient record. What's your phone number?",
    category: 'validation'
  },

  MISSING_EMAIL: {
    code: 'MISSING_EMAIL',
    message: "I need your email address to create your patient record. What's your email address?",
    category: 'validation'
  },

  INVALID_PHONE: {
    code: 'INVALID_PHONE',
    message: "I didn't get a valid phone number. Could you tell me your phone number again? For example, 'my number is three one three, five five five, one two three four'.",
    category: 'validation'
  },

  INVALID_EMAIL: {
    code: 'INVALID_EMAIL',
    message: "I need a valid email address. Could you tell me your email again? For example, 'my email is john at gmail dot com'.",
    category: 'validation'
  },

  INVALID_DATE: {
    code: 'INVALID_DATE',
    message: "I didn't understand that date. Could you try saying it differently, like 'next Tuesday' or 'December 15th'?",
    category: 'validation'
  },

  DATE_TOO_FAR: {
    code: 'DATE_TOO_FAR',
    message: "I can only check availability up to 3 months in advance. Please choose a date within that range.",
    category: 'validation'
  },

  DATE_IN_PAST: {
    code: 'DATE_IN_PAST',
    message: "That date has already passed. Could you choose a future date for your appointment?",
    category: 'validation'
  },

  // Technical Errors
  SYSTEM_ERROR: {
    code: 'SYSTEM_ERROR',
    message: "I'm experiencing a technical issue right now. Please try again in a moment or contact the office directly.",
    category: 'technical'
  },

  TIMEOUT_ERROR: {
    code: 'TIMEOUT_ERROR',
    message: "That request is taking longer than expected. Please try again or contact the office if the issue continues.",
    category: 'timeout'
  },

  // NexHealth API Errors
  NEXHEALTH_API_ERROR: {
    code: 'NEXHEALTH_API_ERROR',
    message: "I'm having trouble connecting to the scheduling system. Please contact the office to make your appointment.",
    category: 'technical'
  },

  NEXHEALTH_RATE_LIMIT: {
    code: 'NEXHEALTH_RATE_LIMIT',
    message: "The system is busy right now. Please wait a moment and try again, or contact the office directly.",
    category: 'timeout'
  },

  // Generic Fallback
  EXECUTION_ERROR: {
    code: 'EXECUTION_ERROR',
    message: "I encountered an issue while processing your request. Please try again or contact the office for assistance.",
    category: 'technical'
  },

  INVALID_DATE_OF_BIRTH: {
    code: 'INVALID_DATE_OF_BIRTH',
    message: "I need your date of birth in a valid format. Could you tell me your date of birth again?",
    category: 'validation'
  },

  MISSING_FIRST_NAME: {
    code: 'MISSING_FIRST_NAME',
    message: "I need your first name to create your patient record. Could you tell me your first name?",
    category: 'validation'
  },

  MISSING_LAST_NAME: {
    code: 'MISSING_LAST_NAME',
    message: "I need your last name to create your patient record. Could you tell me your last name?",
    category: 'validation'
  }
};

/**
 * Get a standardized error message for a given error code
 */
export function getErrorMessage(code: string): ErrorMessageTemplate {
  return ERROR_MESSAGES[code] || ERROR_MESSAGES.EXECUTION_ERROR;
}

/**
 * Get just the patient message for a given error code
 */
export function getPatientMessage(code: string): string {
  return getErrorMessage(code).message;
}

/**
 * Parse Zod validation errors to determine specific error codes
 */
function parseZodValidationError(error: Error, toolName?: string): string {
  try {
    // Check if this is a ZodError with detailed issues
    if (error.name === 'ZodError' && 'issues' in error) {
      const zodError = error as { issues: Array<{ path: string[]; code: string; message?: string; validation?: string }> };
      
      // Special handling for create_new_patient tool
      if (toolName === 'create_new_patient' && zodError.issues) {
        for (const issue of zodError.issues) {
          if (issue.path && issue.path.length > 0) {
            const fieldName = issue.path[0];
            
            // Check for specific field validation errors
            if (fieldName === 'phone') {
              if (issue.code === 'too_small' || issue.code === 'invalid_string') {
                return 'MISSING_PHONE';
              }
            }
            
            if (fieldName === 'email') {
              if (issue.validation === 'email' || issue.code === 'invalid_string') {
                return 'MISSING_EMAIL';
              }
            }
            
            if (fieldName === 'firstName') {
              return 'MISSING_FIRST_NAME';
            }
            
            if (fieldName === 'lastName') {
              return 'MISSING_LAST_NAME';
            }
            
            if (fieldName === 'dateOfBirth') {
              return 'INVALID_DATE_OF_BIRTH';
            }
          }
        }
      }
      
      // Default validation error
      return 'VALIDATION_ERROR';
    }
    
    return 'VALIDATION_ERROR';
  } catch {
    return 'VALIDATION_ERROR';
  }
}

/**
 * Determine error code from an error object
 */
export function getErrorCode(error: unknown, toolName?: string): string {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    
    // Handle Zod validation errors with specific parsing
    if (error.name === 'ZodError' || message.includes('validation')) {
      return parseZodValidationError(error, toolName);
    }
    
    // Authentication & Permission
    if (message.includes('401') || message.includes('unauthorized')) {
      return 'AUTHENTICATION_ERROR';
    }
    if (message.includes('403') || message.includes('forbidden')) {
      return 'PERMISSION_ERROR';
    }
    
    // NexHealth specific
    if (message.includes('nexhealth')) {
      if (message.includes('rate limit') || message.includes('429')) {
        return 'NEXHEALTH_RATE_LIMIT';
      }
      return 'NEXHEALTH_API_ERROR';
    }
    
    // Not found
    if (message.includes('404') || message.includes('not found')) {
      return 'PATIENT_NOT_FOUND';
    }
    
    // Timeout
    if (message.includes('timeout') || message.includes('connection')) {
      return 'TIMEOUT_ERROR';
    }
  }
  
  return 'EXECUTION_ERROR';
}

/**
 * Helper to get both error code and patient message from an error
 */
export function processError(error: unknown, toolName?: string): { code: string; message: string } {
  const code = getErrorCode(error, toolName);
  const message = getPatientMessage(code);
  return { code, message };
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/app/generated/prisma

ceo-notes.txt

tool-call-issues.txt

================
File: app/api/nexhealth-webhook/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import crypto from "crypto";
import { prisma } from "@/lib/prisma";

async function getRawBody(req: NextRequest): Promise<Buffer> {
  const reader = req.body?.getReader();
  if (!reader) return Buffer.from('');
  const chunks: Uint8Array[] = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (value) chunks.push(value);
  }
  return Buffer.concat(chunks);
}

export async function POST(req: NextRequest) {
  console.log("=== NexHealth Webhook Handler ===");
  
  try {
    const rawBody = await getRawBody(req);
    console.log("Raw body length:", rawBody.length);
    
    if (rawBody.length === 0) {
      console.error("Empty request body received");
      return NextResponse.json({ error: "Empty request body" }, { status: 400 });
    }
    
    const signature = req.headers.get("x-nexhealth-signature");
    console.log("Signature present:", !!signature);
    
    // Enhanced signature verification with better error messages
    const globalWebhookConfig = await prisma.globalNexhealthWebhookEndpoint.findUnique({
      where: { id: "singleton" }
    });
    
    if (!globalWebhookConfig?.secretKey) {
      console.error("CRITICAL: Webhook secret not found in database");
      return NextResponse.json({ error: "Webhook not configured" }, { status: 500 });
    }
    
    if (!signature) {
      console.error("Missing webhook signature - potential unauthorized request");
      return NextResponse.json({ error: "Missing signature" }, { status: 401 });
    }
    
    // Verify signature with enhanced security logging
    const expectedSignature = crypto
      .createHmac("sha256", globalWebhookConfig.secretKey)
      .update(rawBody)
      .digest("hex");
    
    // Use timing-safe comparison to prevent timing attacks
    const signatureMatches = crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'), 
      Buffer.from(expectedSignature, 'hex')
    );
    
    if (!signatureMatches) {
      console.error("Signature verification failed");
      // Log truncated signatures for debugging without exposing full secrets
      console.error("Expected signature (first 8 chars):", expectedSignature.substring(0, 8));
      console.error("Received signature (first 8 chars):", signature.substring(0, 8));
      console.error("Request body hash (for debugging):", crypto.createHash('sha256').update(rawBody).digest('hex').substring(0, 16));
      return NextResponse.json({ error: "Invalid signature" }, { status: 401 });
    }
    
    console.log("✅ Signature verification successful");
    
    // Parse and validate JSON
    let event;
    try {
      event = JSON.parse(rawBody.toString());
    } catch (parseError) {
      console.error("JSON parsing failed:", parseError);
      return NextResponse.json({ error: "Invalid JSON payload" }, { status: 400 });
    }
    
    console.log("Webhook event received:", {
      resource_type: event.resource_type,
      event_name: event.event_name,
      subdomain: event.subdomain,
      institution_id: event.institution_id,
      timestamp: new Date().toISOString()
    });
    
    const { resource_type, event_name, subdomain, institution_id, data } = event;

    // Validate required event fields
    if (!resource_type || !event_name || !subdomain) {
      console.error("Missing required event fields:", { resource_type, event_name, subdomain });
      return NextResponse.json({ error: "Invalid event structure" }, { status: 400 });
    }

    // Find the practice associated with this subdomain/institution_id
    const practice = await prisma.practice.findFirst({
      where: { nexhealthSubdomain: subdomain },
    });

    if (!practice) {
      console.warn(`NexHealth Webhook: Received event for unknown subdomain/institution: ${subdomain}/${institution_id}`);
      // Still return 200 to NexHealth to acknowledge receipt and prevent retries for unknown practices.
      return NextResponse.json({ message: "Event received but practice not found" }, { status: 200 });
    }

    console.log(`Processing event for practice: ${practice.id} (${practice.name || 'Unnamed'})`);

    // --- Handle specific events with enhanced logging ---
    
    if (resource_type === "Patient") {
      if (event_name === "patient_created") {
        console.log(`✅ Practice ${practice.id} - Patient created in NexHealth. Patient ID: ${data?.patients?.[0]?.id}`);
        // TODO: Upsert patient data into local Patient table
      } else if (event_name === "patient_updated") {
        console.log(`✅ Practice ${practice.id} - Patient updated in NexHealth. Patient ID: ${data?.patients?.[0]?.id}`);
        // TODO: Update local patient data
      } else {
        console.log(`ℹ️ Practice ${practice.id} - Unhandled Patient event: ${event_name}`);
      }
    } else if (resource_type === "Appointment") {
      if (event_name === "appointment_created") {
        console.log(`✅ Practice ${practice.id} - Appointment created in EHR. Appointment ID: ${data?.appointment?.id}`);
        // TODO: Sync new appointment to local database
      } else if (event_name === "appointment_updated") {
        console.log(`✅ Practice ${practice.id} - Appointment updated in EHR. Appointment ID: ${data?.appointment?.id}`);
        // TODO: Update local appointment data
      } else if (event_name === "appointment_insertion.complete") {
        console.log(`🎉 Practice ${practice.id} - Appointment insertion complete (Laine booking succeeded). Appointment ID: ${data?.appointment?.id}`);
        // TODO: Mark appointment as confirmed in local DB
      } else if (event_name === "appointment_insertion.failed") {
        console.error(`❌ Practice ${practice.id} - Appointment insertion failed (Laine booking failed). Error: ${data?.error}`);
        // TODO: Handle booking failure, notify practice or retry
      } else {
        console.log(`ℹ️ Practice ${practice.id} - Unhandled Appointment event: ${event_name}`);
      }
    } else if (resource_type === "SyncStatus") {
      if (event_name === "sync_status_read_change") {
        console.log(`📊 Practice ${practice.id} - EHR read functionality status change. Status: ${data?.read_status}`);
        // TODO: Update system monitoring, resume read operations if needed
      } else if (event_name === "sync_status_write_change") {
        console.log(`📊 Practice ${practice.id} - EHR write functionality status change. Status: ${data?.write_status}`);
        // TODO: Update system monitoring, resume write operations if needed
      } else {
        console.log(`ℹ️ Practice ${practice.id} - Unhandled SyncStatus event: ${event_name}`);
      }
    } else {
      console.log(`ℹ️ Practice ${practice.id} - Received unhandled event: ${resource_type}.${event_name}`);
    }

    // Update webhook last sync timestamp
    await prisma.practice.update({
      where: { id: practice.id },
      data: { 
        webhookLastSyncAt: new Date(),
        webhookLastSuccessfulSyncAt: new Date(),
        webhookSyncErrorMsg: null
      }
    });

    return NextResponse.json({ success: true, message: "Event processed successfully" });
    
  } catch (error) {
    console.error("❌ Webhook processing error:", error);
    console.error("Error stack:", error instanceof Error ? error.stack : 'No stack trace');
    
    return NextResponse.json({ 
      error: "Internal server error",
      details: error instanceof Error ? error.message : "Unknown error",
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}

================
File: app/api/sync-nexhealth/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { getAppointmentTypes, getProviders, getOperatories } from "@/lib/nexhealth";

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number;
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

export async function POST() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get the practice for this user
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json(
        { error: "NexHealth configuration missing. Please configure your subdomain and location ID first." },
        { status: 400 }
      );
    }

    // Fetch data from NexHealth (including operatories)
    const [appointmentTypes, providers, operatories] = await Promise.all([
      getAppointmentTypes(practice.nexhealthSubdomain, practice.nexhealthLocationId),
      getProviders(practice.nexhealthSubdomain, practice.nexhealthLocationId),
      getOperatories(practice.nexhealthSubdomain, practice.nexhealthLocationId),
    ]);

    // Sync appointment types - use 'minutes' from NexHealth API
    const appointmentTypePromises = appointmentTypes.map((type: NexHealthAppointmentType) =>
      prisma.appointmentType.upsert({
        where: {
          practiceId_nexhealthAppointmentTypeId: {
            practiceId: practice.id,
            nexhealthAppointmentTypeId: type.id.toString(),
          },
        },
        update: {
          name: type.name,
          duration: type.minutes || 0, // Use 'minutes' from NexHealth API
        },
        create: {
          practiceId: practice.id,
          nexhealthAppointmentTypeId: type.id.toString(),
          name: type.name,
          duration: type.minutes || 0, // Use 'minutes' from NexHealth API
        },
      })
    );

    // Sync providers
    const providerPromises = providers.map((provider: NexHealthProvider) =>
      prisma.provider.upsert({
        where: {
          practiceId_nexhealthProviderId: {
            practiceId: practice.id,
            nexhealthProviderId: provider.id.toString(),
          },
        },
        update: {
          firstName: provider.first_name || null,
          lastName: provider.last_name || provider.name || "Unknown",
        },
        create: {
          practiceId: practice.id,
          nexhealthProviderId: provider.id.toString(),
          firstName: provider.first_name || null,
          lastName: provider.last_name || provider.name || "Unknown",
        },
      })
    );

    // Sync operatories (NEW)
    const operatoryPromises = operatories.map((operatory: { id: number; name?: string; active?: boolean }) =>
      prisma.savedOperatory.upsert({
        where: {
          practiceId_nexhealthOperatoryId: {
            practiceId: practice.id,
            nexhealthOperatoryId: operatory.id.toString(),
          },
        },
        update: {
          name: operatory.name || `Operatory ${operatory.id}`,
          isActive: operatory.active !== false, // Default to true unless explicitly false
        },
        create: {
          practiceId: practice.id,
          nexhealthOperatoryId: operatory.id.toString(),
          name: operatory.name || `Operatory ${operatory.id}`,
          isActive: operatory.active !== false,
        },
      })
    );

    // Execute all upserts (including operatories)
    await Promise.all([...appointmentTypePromises, ...providerPromises, ...operatoryPromises]);

    return NextResponse.json({
      success: true,
      message: `Successfully synced ${appointmentTypes.length} appointment types, ${providers.length} providers, and ${operatories.length} operatories.`,
      data: {
        appointmentTypesCount: appointmentTypes.length,
        providersCount: providers.length,
        operatoriesCount: operatories.length,
      },
    });
  } catch (error) {
    console.error("Error syncing NexHealth data:", error);
    return NextResponse.json(
      { error: "Failed to sync NexHealth data. Please check your configuration and try again." },
      { status: 500 }
    );
  }
}

================
File: app/globals.css
================
@import "tailwindcss";

@custom-variant dark (&:is(.dark *));

:root {
  --background: #ffffff;
  --foreground: #0f172a;
}

.dark {
  --background: #0f172a;
  --foreground: #f8fafc;
}

@layer base {
  * {
    @apply border-gray-300;
  }
  body {
    @apply bg-white text-gray-900;
  }
}

================
File: lib/tools/checkInsuranceParticipation.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const checkInsuranceParticipationSchema = z.object({
  insuranceProviderName: z.string().min(1)
    .describe("Dental insurance provider name patient mentioned (e.g., 'Cigna', 'Healthplex', 'Renaissance'). Extract primary insurer name.")
});

const checkInsuranceParticipationTool: ToolDefinition<typeof checkInsuranceParticipationSchema> = {
  name: "check_insurance_participation",
  description: "Checks if practice is in-network with patient's dental insurance provider. Use after patient mentions their insurance company name.",
  schema: checkInsuranceParticipationSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    try {
      // Check if practice has accepted insurances configured
      if (!practice.acceptedInsurances || practice.acceptedInsurances.trim() === '') {
        return {
          success: true, // Tool ran, but no configuration data available
          error_code: "INSURANCE_CONFIG_MISSING",
          message_to_patient: `This practice hasn't specified which insurances they accept in my system. It would be best to confirm directly with the office regarding your ${args.insuranceProviderName} plan. Would you like to proceed with scheduling for now?`,
          data: { 
            insuranceProviderName: args.insuranceProviderName,
            participation: "unknown_configuration",
            practiceAcceptedList: null
          }
        };
      }

      // Parse the accepted insurances string into an array
      const acceptedProviderNames = practice.acceptedInsurances
        .split(',')
        .map(name => name.trim().toLowerCase())
        .filter(name => name.length > 0);

      // Normalize the insurance provider name from args
      const normalizedInsuranceProviderName = args.insuranceProviderName.trim().toLowerCase();

      // Check for matches using includes for partial matching
      const isInNetwork = acceptedProviderNames.some(acceptedName => 
        acceptedName.includes(normalizedInsuranceProviderName) || 
        normalizedInsuranceProviderName.includes(acceptedName)
      );

      if (isInNetwork) {
        return {
          success: true,
          message_to_patient: `Great news! We are in-network with ${args.insuranceProviderName}. We can proceed with scheduling if you're ready. What type of appointment were you thinking of?`,
          data: {
            insuranceProviderName: args.insuranceProviderName,
            participation: "in-network",
            practiceAcceptedList: practice.acceptedInsurances
          }
        };
      } else {
        return {
          success: true,
          message_to_patient: `Based on the information I have, we might be out-of-network with ${args.insuranceProviderName}. You are still welcome to be seen here, but you would be responsible for the cost out-of-pocket. Would you like an estimate for the service you're considering?`,
          data: {
            insuranceProviderName: args.insuranceProviderName,
            participation: "out-of-network",
            practiceAcceptedList: practice.acceptedInsurances
          }
        };
      }

    } catch (error) {
      console.error(`[checkInsuranceParticipation] Error:`, error);
      
      return {
        success: false,
        error_code: "EXECUTION_ERROR",
        message_to_patient: "I had trouble checking the insurance. Please contact the office to verify your insurance coverage.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check that insurance for you...",
    success: "Okay, insurance check processed.",
    fail: "There was an issue with the insurance check."
  }
};

export default checkInsuranceParticipationTool;

================
File: lib/tools/getPracticeDetails.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const getPracticeDetailsSchema = z.object({});

const getPracticeDetailsTool: ToolDefinition<typeof getPracticeDetailsSchema> = {
  name: "get_practice_details",
  description: "Retrieves practice details like address and location info. Use when patient asks for practice address or location information, or when providing confirmation and directions.",
  schema: getPracticeDetailsSchema,
  
  async run({ context }): Promise<ToolResult> {
    const { practice } = context;
    
    try {
      // Check if practice address exists and is not empty
      if (!practice.address || practice.address.trim() === '') {
        return {
          success: false,
          error_code: "PRACTICE_DETAIL_MISSING",
          message_to_patient: "I don't have the specific address details available in my system right now. However, our office team can certainly provide that to you. Were you looking to schedule an appointment?",
          details: "Practice address is not configured."
        };
      }

      return {
        success: true,
        message_to_patient: `Our practice is located at ${practice.address}. Is there anything else about our location you'd like to know?`,
        data: { 
          address: practice.address 
        }
      };

    } catch (error) {
      console.error(`[getPracticeDetails] Error:`, error);
      
      return {
        success: false,
        error_code: "EXECUTION_ERROR",
        message_to_patient: "I couldn't retrieve the practice details at the moment. Please contact the office for location information.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me get those practice details for you...",
    success: "Okay, practice details processed.",
    fail: "There was an issue retrieving the practice details."
  }
};

export default getPracticeDetailsTool;

================
File: lib/tools/getServiceCostEstimate.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const getServiceCostEstimateSchema = z.object({
  serviceName: z.string().min(1)
    .describe("Dental service name patient asked about (e.g., 'limited exam and x-rays', 'cleaning', 'new patient special'). Match to patient's exact request.")
});

const getServiceCostEstimateTool: ToolDefinition<typeof getServiceCostEstimateSchema> = {
  name: "get_service_cost_estimate",
  description: "Provides estimated cost for dental services, particularly for out-of-network or self-pay patients. Use when patient asks about cost of a visit or service.",
  schema: getServiceCostEstimateSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    try {
      // Check if practice has service cost estimates configured
      if (!practice.serviceCostEstimates || practice.serviceCostEstimates.trim() === '') {
        return {
          success: true, // Tool ran, but no configuration data available
          error_code: "COST_CONFIG_MISSING",
          message_to_patient: "I don't have specific cost information in my system. The office staff can provide you with an estimate. Would you like to schedule an appointment so they can discuss costs with you?",
          data: { 
            serviceName: args.serviceName,
            found: false,
            estimate: null
          }
        };
      }

      // Parse the service cost estimates string (e.g., "Cleaning: $120, Exam and X-rays: $80, New Patient Special: $129")
      const serviceCosts: Array<{ service: string; cost: string }> = [];
      
      const entries = practice.serviceCostEstimates.split(',').map(entry => entry.trim());
      
      for (const entry of entries) {
        if (entry.includes(':')) {
          const [servicePart, costPart] = entry.split(':', 2);
          const service = servicePart?.trim();
          const cost = costPart?.trim();
          
          if (service && cost) {
            serviceCosts.push({ service, cost });
          }
        }
      }

      if (serviceCosts.length === 0) {
        return {
          success: true,
          error_code: "COST_CONFIG_INVALID",
          message_to_patient: "I'm having trouble reading the cost information in my system. The office staff can provide you with accurate pricing.",
          data: { 
            serviceName: args.serviceName,
            found: false,
            estimate: null
          }
        };
      }

      // Normalize the service name from args for matching
      const normalizedServiceName = args.serviceName.trim().toLowerCase();

      // Try to find a matching service
      const matchedService = serviceCosts.find(serviceItem => 
        serviceItem.service.toLowerCase().includes(normalizedServiceName) ||
        normalizedServiceName.includes(serviceItem.service.toLowerCase())
      );

      if (matchedService) {
        return {
          success: true,
          message_to_patient: `For a ${matchedService.service}, the estimated cost is ${matchedService.cost}. Does that work for you, or would you like to discuss scheduling?`,
          data: {
            serviceName: args.serviceName,
            estimate: matchedService.cost,
            found: true,
            matchedKey: matchedService.service
          }
        };
      }

      // Check for "New Patient Special" or similar as a fallback for general inquiries
      const specialOffer = serviceCosts.find(serviceItem => 
        serviceItem.service.toLowerCase().includes('special') ||
        serviceItem.service.toLowerCase().includes('new patient')
      );

      if (specialOffer && (
        normalizedServiceName.includes('new') || 
        normalizedServiceName.includes('first') || 
        normalizedServiceName.includes('visit') ||
        normalizedServiceName.includes('appointment')
      )) {
        return {
          success: true,
          message_to_patient: `While I don't have a specific estimate for ${args.serviceName}, we do have a ${specialOffer.service} for ${specialOffer.cost} which typically covers an initial exam and necessary x-rays. Would that interest you?`,
          data: {
            serviceName: args.serviceName,
            estimate: specialOffer.cost,
            found: true,
            type: "special_offer",
            matchedKey: specialOffer.service
          }
        };
      }

      // No match found
      return {
        success: true,
        message_to_patient: `I couldn't find a specific cost estimate for ${args.serviceName} in my system. Our team can provide detailed pricing information. Would you like to proceed with scheduling, and they can discuss costs with you then?`,
        data: {
          serviceName: args.serviceName,
          found: false,
          estimate: null
        }
      };

    } catch (error) {
      console.error(`[getServiceCostEstimate] Error:`, error);
      
      return {
        success: false,
        error_code: "EXECUTION_ERROR",
        message_to_patient: "I'm unable to retrieve cost estimates right now. Please contact the office for pricing information.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check on that cost estimate for you...",
    success: "Okay, cost estimate processed.",
    fail: "There was an issue retrieving the cost estimate."
  }
};

export default getServiceCostEstimateTool;

================
File: lib/tools/types.ts
================
// lib/tools/types.ts
import { z } from "zod";
import { Practice, AppointmentType, SavedProvider, SavedOperatory } from "@prisma/client";

// Enhanced practice context with scheduling data
export interface PracticeWithSchedulingData extends Practice {
  appointmentTypes: AppointmentType[];
  savedProviders: (SavedProvider & { 
    provider: { 
      id: string; 
      firstName: string | null; 
      lastName: string; 
      nexhealthProviderId: string; 
    };
    acceptedAppointmentTypes?: Array<{
      appointmentType: AppointmentType;
    }>;
    defaultOperatoryId?: string | null;
  })[];
  savedOperatories: SavedOperatory[];
}

// Tool execution context
export interface ToolExecutionContext {
  practice: PracticeWithSchedulingData;
  vapiCallId: string;
  toolCallId: string;
  assistantId: string;
  callSummaryForNote?: string; // ADD THIS LINE for bookAppointment tool
}

// Standardized tool result format
export interface ToolResult {
  success: boolean;
  message_to_patient: string;
  data?: Record<string, unknown>;
  error_code?: string;
  details?: string;
}

// VAPI tool definition interface
export interface VapiToolFunction {
  name: string;
  description: string;
  parameters: Record<string, unknown>; // JSON schema object
}

export interface VapiToolSchema {
  type: "function";
  async?: boolean;
  function: VapiToolFunction;
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

// Internal tool definition
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface ToolDefinition<T extends z.ZodType<any, any>> {
  name: string;
  description: string;
  schema: T;
  run: (params: { 
    args: z.infer<T>; 
    context: ToolExecutionContext 
  }) => Promise<ToolResult>;
  messages?: {
    start?: string;
    delay?: string;
    success?: string;
    fail?: string;
  };
  async?: boolean;
}

// VAPI webhook payload types
export interface VapiToolCall {
  toolCallId: string;
  name: string;
  arguments: string; // JSON string
}

export interface VapiToolCallsMessage {
  type: "tool-calls";
  timestamp: number;
  call: {
    id: string;
    assistantId: string;
    orgId?: string;
  };
  assistant: {
    id: string;
  };
  toolCallList: VapiToolCall[];
}

export interface VapiServerMessage {
  message: VapiToolCallsMessage;
}

================
File: README.md
================
# Laine AI Voice Assistant

AI-powered voice assistant for healthcare practices, integrating NexHealth EHR with VAPI voice AI technology.

## Features

- 🎙️ **VAPI Voice Integration**: AI-powered voice calls with customizable assistants
- 🏥 **NexHealth EHR Integration**: Patient lookup, appointment management, and data synchronization
- 🔗 **Webhook Management**: Automated event handling for appointments and patient updates
- 👤 **Practice Management**: Multi-tenant SaaS platform with practice-specific configurations
- 🔒 **Secure Authentication**: Clerk-based user authentication and practice isolation

## Quick Start

1. **Environment Setup**:
   ```bash
   cp .env.example .env
   # Configure your API keys and database URL
   ```

2. **Database Setup**:
   ```bash
   pnpm install
   pnpm db:push
   ```

3. **Development Server**:
   ```bash
   pnpm dev
   ```

4. **Webhook Configuration** (Production):
   ```bash
   # Setup global webhook endpoint
   pnpm webhook:setup
   
   # Subscribe practices to events
   pnpm webhook:subscribe your-practice-subdomain
   ```

## Documentation

- 📖 [Webhook Management Guide](docs/webhook-management.md) - Complete guide to NexHealth webhook setup
- 🛠️ [API Documentation](docs/api.md) - API endpoints and integration details

## Technology Stack

- **Frontend**: Next.js 15, React 19, Tailwind CSS
- **Backend**: Next.js API Routes, Prisma ORM
- **Database**: PostgreSQL (Supabase)
- **Authentication**: Clerk
- **Voice AI**: VAPI
- **EHR Integration**: NexHealth API
- **Deployment**: Vercel

## Key Components

### VAPI Assistant Integration
- AI voice assistants with customizable voices and prompts
- Tool calling system for EHR operations
- Call logging and transcript management

### NexHealth Integration  
- Patient search and data retrieval
- Appointment scheduling and management
- Real-time webhook event processing

### Practice Management
- Multi-tenant architecture with practice isolation
- Configurable assistant settings per practice
- Automated practice onboarding workflow

# LAINE Project Context

## **Project Overview**
**LAINE** is an AI voice receptionist SaaS platform for dental practices. It enables dental offices to automate patient interactions, appointment scheduling, and EHR integration through AI voice assistants.

## **Core Functionality**
- **AI Voice Reception**: Patients call and speak with an AI assistant (powered by VAPI)
- **Patient Lookup**: Find existing patients in the practice's EHR system
- **Appointment Scheduling**: Check availability and book appointments
- **EHR Integration**: Connect with NexHealth to access patient records and scheduling
- **Multi-Tenant SaaS**: Each dental practice gets isolated data and configuration

## **Technology Stack**

### **Frontend**
- **Next.js 15+** (App Router)
- **React 19** with TypeScript
- **Tailwind CSS** for styling
- **Clerk** for authentication

### **Backend**
- **Next.js API Routes** 
- **Prisma ORM** with PostgreSQL
- **Supabase** for database hosting

### **External Integrations**
- **VAPI**: AI voice calling platform
- **NexHealth**: Dental practice EHR/scheduling system  
- **Clerk**: User authentication and management

### **Key Dependencies**
- `@clerk/nextjs` - Authentication
- `@prisma/client` - Database ORM
- `zod` - Schema validation
- `sonner` - Toast notifications

## **Architecture Patterns**

### **Multi-Tenant SaaS Design**
- Each dental practice is isolated by `practiceId`
- Users authenticate via Clerk (`clerkUserId`)
- All data operations are practice-scoped

### **Tool-Based AI Framework**
- AI assistant uses "tools" to perform actions
- Tools are TypeScript functions with Zod schemas
- Centralized tool execution via webhook handler

### **API Integration Layer**
- NexHealth API for EHR operations
- VAPI API for voice assistant management
- Token-based authentication with caching

## **Database Schema (Key Models)**

### **Core Models**
```prisma
Practice {
  id: String (Primary Key)
  clerkUserId: String (Unique - links to Clerk user)
  name: String? (Optional practice name)
  nexhealthSubdomain: String? (NexHealth subdomain)
  nexhealthLocationId: String? (NexHealth location ID)
}

PracticeAssistantConfig {
  practiceId: String (FK to Practice)
  vapiAssistantId: String? (VAPI assistant ID)
  voiceProvider: String (voice provider)
  systemPrompt: String (AI instructions)
  firstMessage: String (greeting message)
}
```

### **Scheduling Models**
```prisma
AppointmentType {
  practiceId: String (FK to Practice)
  nexhealthAppointmentTypeId: String (NexHealth ID)
  name: String (e.g., "General Cleanup")
  duration: Int (minutes)
}

Provider {
  practiceId: String (FK to Practice) 
  nexhealthProviderId: String (NexHealth ID)
  firstName: String?
  lastName: String
}

SavedProvider {
  practiceId: String (FK to Practice)
  providerId: String (FK to Provider)
  isDefault: Boolean
  isActive: Boolean
}
```

### **Logging Models**
```prisma
CallLog {
  vapiCallId: String (Unique - from VAPI)
  practiceId: String (FK to Practice)
  callStatus: String (e.g., "IN_PROGRESS", "ENDED")
  transcriptText: String?
  nexhealthPatientId: String? (if patient found)
}

ToolLog {
  practiceId: String (FK to Practice)
  vapiCallId: String? (FK to CallLog)
  toolName: String (e.g., "find_patient_in_ehr")
  toolCallId: String (VAPI tool call ID)
  arguments: String (JSON)
  result: String (JSON)
  success: Boolean
}
```

## **Key API Endpoints**

### **VAPI Integration**
- `POST /api/vapi/tool-calls` - Centralized tool execution webhook
- `POST /api/vapi/webhook` - General VAPI webhooks (call status, transcripts)

### **Practice Configuration**
- `POST /api/practice-config/providers` - Save provider preferences
- `POST /api/practice-config/operatories` - Save operatory preferences
- `POST /api/sync-nexhealth` - Sync data from NexHealth API

### **NexHealth Integration**
- `POST /api/nexhealth-webhook` - Receive NexHealth events
- `POST /api/webhook-subscribe` - Subscribe to NexHealth events

## **AI Tools Framework**

### **Tool Structure**
Each tool is defined with:
```typescript
interface ToolDefinition<T extends z.ZodType> {
  name: string                    // Tool identifier
  description: string             // What the tool does
  schema: T                      // Zod validation schema
  run: (params) => Promise<ToolResult>  // Tool execution logic
  messages?: ToolMessages        // VAPI voice prompts
}
```

### **Current Tools**
1. **`find_patient_in_ehr`** - Search for patients by name and DOB
2. **`find_appointment_type`** - Match patient requests to appointment types
3. **`check_available_slots`** - Find available appointment times

### **Tool Execution Flow**
1. VAPI calls `/api/vapi/tool-calls` webhook
2. Practice identified by assistant ID
3. Tool arguments validated with Zod
4. Tool executes with practice context
5. Results logged to database
6. Response sent back to VAPI

## **Typical User Journey**

### **Practice Setup**
1. Practice owner signs up via Clerk
2. Configure NexHealth subdomain and location ID
3. Sync appointment types and providers from NexHealth
4. Select preferred providers and operatories for scheduling
5. Create and configure VAPI voice assistant

### **Patient Interaction**
1. Patient calls dental office phone number
2. VAPI voice assistant answers
3. Assistant asks for patient name and date of birth
4. `find_patient_in_ehr` tool searches NexHealth EHR
5. If patient found, assistant asks about appointment purpose
6. `find_appointment_type` tool matches request to available types
7. `check_available_slots` tool finds available times
8. Assistant presents options to patient

## **Environment Variables**
```bash
# Database
DATABASE_URL=postgresql://...

# Authentication  
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_...
CLERK_SECRET_KEY=sk_...

# VAPI Integration
VAPI_API_KEY=vapi_...
NEXT_PUBLIC_APP_URL=https://your-domain.com

# NexHealth Integration
NEXHEALTH_API_KEY=nexhealth_...
NEXHEALTH_API_BASE_URL=https://nexhealth.info
```

## **Key File Structure**
```
app/
├── api/
│   ├── vapi/
│   │   ├── tool-calls/route.ts     # Centralized tool handler
│   │   └── webhook/route.ts        # VAPI general webhooks
│   ├── practice-config/            # Practice management APIs
│   └── nexhealth-webhook/route.ts  # NexHealth event handler
├── practice-config/                # Practice configuration UI
└── laine/                         # Assistant configuration UI

lib/
├── tools/
│   ├── types.ts                   # Tool framework types
│   ├── index.ts                   # Tool registry
│   ├── findPatient.ts            # Patient lookup tool
│   ├── findAppointmentType.ts    # Appointment type matching
│   └── checkAvailableSlots.ts    # Availability checking
├── nexhealth.ts                  # NexHealth API client
├── vapi.ts                       # VAPI API client
└── prisma.ts                     # Database client

prisma/
└── schema.prisma                  # Database schema
```

## **Development Commands**
```bash
# Development
pnpm dev                          # Start development server
pnpm build                        # Build for production
pnpm lint                         # Run ESLint

# Database
pnpm db:push                      # Push schema changes
pnpm db:list                      # List database contents
pnpm db:clean                     # Clean test data

# Webhooks
pnpm webhook:setup                # Setup NexHealth webhook endpoint
pnpm webhook:subscribe <subdomain> # Subscribe practice to events
pnpm webhook:list                 # List webhook subscriptions
```

## **Common Patterns**

### **Practice Context Injection**
All operations include practice context:
```typescript
const practice = await findPracticeByAssistantId(assistantId);
// All subsequent operations are practice-scoped
```

### **Error Handling**
User-friendly error messages for patients:
```typescript
return {
  success: false,
  error_code: "PATIENT_NOT_FOUND",
  message_to_patient: "I couldn't find that patient. Would you like to try different information?"
};
```

### **Tool Result Format**
Standardized response format:
```typescript
interface ToolResult {
  success: boolean
  message_to_patient: string  // What the AI says to the patient
  data?: Record<string, unknown>  // Structured data
  error_code?: string  // Error classification
}
```

================
File: app/api/practice-config/basic/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { subscribePracticeToWebhooks } from "@/lib/webhook-utils";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const formData = await req.formData();
    const name = formData.get("practiceName") as string | null;
    const subdomain = formData.get("nexhealthSubdomain") as string;
    const locationId = formData.get("nexhealthLocationId") as string;
    const address = formData.get("practiceAddress") as string | null;
    const acceptedInsurances = formData.get("acceptedInsurances") as string | null;
    const serviceCostEstimates = formData.get("serviceCostEstimates") as string | null;

    if (!subdomain || !locationId) {
      return NextResponse.json(
        { error: "Subdomain and Location ID are required" },
        { status: 400 }
      );
    }

    // Update webhook last sync timestamp to reflect sync attempt time
    const syncAttemptTime = new Date();

    // Save the practice configuration
    const practice = await prisma.practice.upsert({
      where: { clerkUserId: userId },
      update: { 
        name, 
        nexhealthSubdomain: subdomain, 
        nexhealthLocationId: locationId,
        address,
        acceptedInsurances,
        serviceCostEstimates,
        webhookLastSyncAt: syncAttemptTime // Update sync timestamp when attempt is made
      },
      create: { 
        clerkUserId: userId, 
        name, 
        nexhealthSubdomain: subdomain, 
        nexhealthLocationId: locationId,
        address,
        acceptedInsurances,
        serviceCostEstimates,
        webhookLastSyncAt: syncAttemptTime // Set initial sync timestamp
      },
    });

    // Automatically sync webhooks after saving configuration
    let webhookSyncResult = { 
      success: false, 
      message: "Webhook sync not attempted",
      successCount: 0,
      skipCount: 0,
      failCount: 0
    };
    
    try {
      console.log(`[AutoWebhookSync] Auto-syncing webhooks for practice ${practice.id}...`);
      webhookSyncResult = await subscribePracticeToWebhooks(subdomain);
      
      if (webhookSyncResult.success) {
        console.log(`[AutoWebhookSync] ✅ Successfully synced webhooks for ${subdomain}`);
        
        // Update practice with successful sync
        await prisma.practice.update({
          where: { id: practice.id },
          data: {
            webhookLastSuccessfulSyncAt: new Date(),
            webhookSyncErrorMsg: null
          }
        });
      } else {
        console.warn(`[AutoWebhookSync] ⚠️ Webhook sync completed with issues: ${webhookSyncResult.message}`);
        
        // Update practice with error message
        await prisma.practice.update({
          where: { id: practice.id },
          data: {
            webhookSyncErrorMsg: webhookSyncResult.message
          }
        });
      }
    } catch (webhookError) {
      console.error(`[AutoWebhookSync] ❌ Failed to sync webhooks:`, webhookError);
      const errorMessage = webhookError instanceof Error ? webhookError.message : "Configuration saved, but webhook sync failed";
      
      // Update practice with error message
      await prisma.practice.update({
        where: { id: practice.id },
        data: {
          webhookSyncErrorMsg: errorMessage
        }
      });
      
      webhookSyncResult = {
        success: false,
        message: errorMessage,
        successCount: 0,
        skipCount: 0,
        failCount: 0
      };
    }

    // Return minimal response suitable for non-reloading save
    return NextResponse.json({ 
      success: true,
      practice: {
        id: practice.id,
        name: practice.name,
        nexhealthSubdomain: practice.nexhealthSubdomain,
        nexhealthLocationId: practice.nexhealthLocationId,
        webhookLastSyncAt: practice.webhookLastSyncAt
      },
      webhookSync: webhookSyncResult
    });

  } catch (error) {
    console.error("Error saving practice config:", error);
    return NextResponse.json(
      { error: "Failed to save configuration" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/check-slots/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import { z } from "zod";

interface NexhealthSlot {
  time: string;
  end_time: string;
  operatory_id?: number;
  [key: string]: unknown;
}

const checkSlotsSchema = z.object({
  requestedDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "requestedDate must be in YYYY-MM-DD format"),
  appointmentTypeId: z.string().min(1, "appointmentTypeId is required"),
  providerIds: z.array(z.string()).optional().default([]),
  operatoryIds: z.array(z.string()).optional().default([]),
  daysToSearch: z.number().min(1).max(30).optional().default(1)
});

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: true,
        savedProviders: {
          include: {
            provider: true,
            defaultOperatory: true,
            acceptedAppointmentTypes: {
              include: {
                appointmentType: true
              }
            }
          },
          where: { isActive: true }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({ 
        error: "NexHealth configuration incomplete. Please configure subdomain and location ID." 
      }, { status: 400 });
    }

    const body = await req.json();

    // Validate input using Zod
    const validationResult = checkSlotsSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json({
        error: "Invalid input",
        details: validationResult.error.issues
      }, { status: 400 });
    }

    const { requestedDate, appointmentTypeId, providerIds, operatoryIds, daysToSearch } = validationResult.data;

    // Validate appointment type belongs to practice
    const appointmentType = practice.appointmentTypes.find(
      at => at.nexhealthAppointmentTypeId === appointmentTypeId
    );

    if (!appointmentType) {
      return NextResponse.json({ 
        error: "Appointment type not found or doesn't belong to practice" 
      }, { status: 400 });
    }

    // NEW LOGIC: Determine providers based on accepted appointment types
    let eligibleProviders = practice.savedProviders.filter(sp => sp.isActive);

    // First, filter providers who accept this appointment type
    const providersWhoAcceptType = eligibleProviders.filter(sp => {
      // If provider has no accepted appointment types configured, include them (backward compatibility)
      if (sp.acceptedAppointmentTypes.length === 0) {
        return true;
      }
      // Otherwise, check if they accept this specific appointment type
      return sp.acceptedAppointmentTypes.some(
        relation => relation.appointmentType.id === appointmentType.id
      );
    });

    // Apply provider filter if specific providers were requested
    if (providerIds.length > 0) {
      eligibleProviders = providersWhoAcceptType.filter(sp => 
        providerIds.includes(sp.provider.id)
      );
    } else {
      eligibleProviders = providersWhoAcceptType;
    }

    if (eligibleProviders.length === 0) {
      return NextResponse.json({ 
        error: "No providers are configured to accept this appointment type" 
      }, { status: 400 });
    }

    // NEW LOGIC: Determine operatories for each provider
    const providerOperatoryPairs: Array<{
      provider: { id: string; nexhealthProviderId: string; firstName: string | null; lastName: string; };
      operatoryId: string | null;
    }> = [];

    for (const savedProvider of eligibleProviders) {
      if (operatoryIds.length > 0) {
        // If specific operatories were requested, check if provider's default operatory is in the list
        if (savedProvider.defaultOperatoryId && operatoryIds.includes(savedProvider.defaultOperatoryId)) {
          providerOperatoryPairs.push({
            provider: savedProvider.provider,
            operatoryId: savedProvider.defaultOperatoryId
          });
        } else {
          // If provider's default operatory is not in the requested list, 
          // we could either skip this provider or use the first requested operatory
          // For now, we'll use the first requested operatory if available
          const firstRequestedOperatory = practice.savedOperatories.find(so => 
            operatoryIds.includes(so.id) && so.isActive
          );
          if (firstRequestedOperatory) {
            providerOperatoryPairs.push({
              provider: savedProvider.provider,
              operatoryId: firstRequestedOperatory.id
            });
          }
        }
      } else {
        // No specific operatories requested, use provider's default operatory if available
        providerOperatoryPairs.push({
          provider: savedProvider.provider,
          operatoryId: savedProvider.defaultOperatoryId
        });
      }
    }

    // Prepare NexHealth API call parameters
    const nexhealthProviderIds = providerOperatoryPairs.map(pair => pair.provider.nexhealthProviderId);
    
    // Get unique operatory IDs and convert to NexHealth operatory IDs
    const uniqueOperatoryIds = [...new Set(
      providerOperatoryPairs
        .map(pair => pair.operatoryId)
        .filter((id): id is string => id !== null)
    )];

    const nexhealthOperatoryIds = uniqueOperatoryIds.length > 0 
      ? practice.savedOperatories
          .filter(so => uniqueOperatoryIds.includes(so.id))
          .map(so => so.nexhealthOperatoryId)
      : [];

    // Build NexHealth API parameters
    const params: Record<string, string | number | string[]> = {
      start_date: requestedDate,
      days: daysToSearch,
      'lids[]': [practice.nexhealthLocationId],
      'pids[]': nexhealthProviderIds,
      appointment_type_id: appointmentTypeId
    };

    // Add operatory IDs if we have any
    if (nexhealthOperatoryIds.length > 0) {
      params['operatory_ids[]'] = nexhealthOperatoryIds;
    }

    console.log("Checking appointment slots with new provider logic:", {
      eligibleProvidersCount: eligibleProviders.length,
      providersWhoAcceptType: providersWhoAcceptType.length,
      providerOperatoryPairs: providerOperatoryPairs.length,
      params
    });

    // Call NexHealth API
    const slotsResponse = await fetchNexhealthAPI(
      '/appointment_slots',
      practice.nexhealthSubdomain,
      params
    );

    // Parse response and extract slots
    const availableSlots: Array<NexhealthSlot & { provider_id: number; location_id: number }> = [];
    
    if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
      // Extract all slots from all providers
      for (const providerData of slotsResponse.data) {
        if (providerData.slots && Array.isArray(providerData.slots)) {
          availableSlots.push(...providerData.slots.map((slot: NexhealthSlot) => ({
            ...slot,
            provider_id: providerData.pid,
            location_id: providerData.lid
          })));
        }
      }
    }

    // Create provider lookup map
    const providerLookup = new Map();
    eligibleProviders.forEach(sp => {
      providerLookup.set(sp.provider.nexhealthProviderId, {
        id: sp.provider.id,
        nexhealthProviderId: sp.provider.nexhealthProviderId,
        name: `${sp.provider.firstName || ''} ${sp.provider.lastName}`.trim(),
        defaultOperatory: sp.defaultOperatory ? {
          id: sp.defaultOperatory.id,
          name: sp.defaultOperatory.name,
          nexhealthOperatoryId: sp.defaultOperatory.nexhealthOperatoryId
        } : null
      });
    });

    // Create operatory lookup map
    const operatoryLookup = new Map();
    practice.savedOperatories.forEach(so => {
      operatoryLookup.set(so.nexhealthOperatoryId, {
        id: so.id,
        nexhealthOperatoryId: so.nexhealthOperatoryId,
        name: so.name
      });
    });

    // Format slots for display with enhanced information
    const formattedSlots = availableSlots.map((slot, index) => {
      // Parse the time string correctly to preserve the timezone
      const startTime = new Date(slot.time);
      const endTime = new Date(slot.end_time);
      
      // Use the timezone from the original date string for formatting
      const timeString = startTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
      });

      const endTimeString = endTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Chicago'
      });

      // Get provider and operatory details
      const providerInfo = providerLookup.get(slot.provider_id.toString()) || { 
        name: `Provider ${slot.provider_id}`, 
        nexhealthProviderId: slot.provider_id 
      };
      
      const operatoryInfo = slot.operatory_id ? 
        operatoryLookup.get(slot.operatory_id.toString()) || { 
          name: `Operatory ${slot.operatory_id}`, 
          nexhealthOperatoryId: slot.operatory_id 
        } : null;
      
      return {
        slot_id: `slot_${index}`,
        time: slot.time,
        end_time: slot.end_time,
        display_time: timeString,
        display_end_time: endTimeString,
        display_range: `${timeString} - ${endTimeString}`,
        operatory_id: slot.operatory_id,
        provider_id: slot.provider_id,
        location_id: slot.location_id,
        provider_info: providerInfo,
        operatory_info: operatoryInfo
      };
    });

    // Sort slots by time
    formattedSlots.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());

    return NextResponse.json({
      success: true,
      params: params,
      response: slotsResponse,
      data: {
        requested_date: requestedDate,
        appointment_type: {
          id: appointmentType.nexhealthAppointmentTypeId,
          name: appointmentType.name,
          duration: appointmentType.duration,
          groupCode: appointmentType.groupCode
        },
        available_slots: formattedSlots,
        has_availability: formattedSlots.length > 0,
        total_slots_found: formattedSlots.length,
        debug_info: {
          total_active_providers: practice.savedProviders.length,
          providers_who_accept_type: providersWhoAcceptType.length,
          eligible_providers_after_filter: eligibleProviders.length,
          provider_operatory_pairs: providerOperatoryPairs.length,
          providers_used: eligibleProviders.map(sp => ({
            id: sp.provider.id,
            name: `${sp.provider.firstName || ''} ${sp.provider.lastName}`.trim(),
            nexhealthProviderId: sp.provider.nexhealthProviderId,
            defaultOperatory: sp.defaultOperatory ? sp.defaultOperatory.name : null,
            acceptedAppointmentTypesCount: sp.acceptedAppointmentTypes.length
          })),
          operatories_used: uniqueOperatoryIds.map(id => {
            const operatory = practice.savedOperatories.find(so => so.id === id);
            return operatory ? {
              id: operatory.id,
              name: operatory.name,
              nexhealthOperatoryId: operatory.nexhealthOperatoryId
            } : null;
          }).filter(Boolean)
        }
      }
    });

  } catch (error) {
    console.error("Error checking appointment slots:", error);
    return NextResponse.json(
      { 
        error: "Failed to check appointment slots", 
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}

================
File: app/laine/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { createVapiAssistant } from "@/lib/vapi";
import { buildVapiTools } from "@/lib/tools";
import { LainePracticeClient } from "./laine-practice-client";

async function createPracticeAssistant() {
  "use server";
  
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Not authenticated");
  }

  // Get the practice
  const practice = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practice) {
    throw new Error("Practice not found");
  }

  if (practice.assistantConfig?.vapiAssistantId) {
    throw new Error("Assistant already exists for this practice");
  }

  const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
  
  // Build tools for the assistant
  const tools = buildVapiTools(appBaseUrl);
  
  // Create default assistant configuration
  const assistantConfig = {
    name: `${practice.name || 'Practice'} - Laine`,
    model: {
      provider: "openai" as const,
      model: "gpt-4.1-nano",
      temperature: 0.7,
      messages: [
        {
          role: "system" as const,
          content: "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient."
        }
      ],
      tools
    },
    voice: {
      provider: "vapi" as const,
      voiceId: "Elliot"
    },
    firstMessage: "Hello! This is Laine from your dental office. How can I help you today?",
    // General assistant webhooks (status updates, call reports, transcripts)
    serverUrl: `${appBaseUrl}/api/vapi/webhook`,
    serverMessages: ["end-of-call-report", "status-update", "transcript"],
    silenceTimeoutSeconds: 30,
    maxDurationSeconds: 600, // 10 minutes
    backgroundSound: "office" as const,
    backchannelingEnabled: true,
    backgroundDenoisingEnabled: true,
    modelOutputInMessagesEnabled: true
  };

  try {
    console.log("Creating VAPI assistant for practice:", practice.id);
    const vapiAssistant = await createVapiAssistant(assistantConfig);
    
    // Create or update the assistant config in our database
    await prisma.practiceAssistantConfig.upsert({
      where: { practiceId: practice.id },
      create: {
        practiceId: practice.id,
        vapiAssistantId: vapiAssistant.id,
        voiceProvider: "vapi",
        voiceId: "Elliot",
        systemPrompt: "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.",
        firstMessage: "Hello! This is Laine from your dental office. How can I help you today?"
      },
      update: {
        vapiAssistantId: vapiAssistant.id,
        updatedAt: new Date()
      }
    });

    console.log(`Successfully created VAPI assistant ${vapiAssistant.id} for practice ${practice.id}`);
  } catch (error) {
    console.error("Error creating VAPI assistant:", error);
    throw new Error(`Failed to create assistant: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  revalidatePath("/laine");
}

export default async function LainePage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/sign-in");
  }

  // Get the practice with assistant configuration
  const practice = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practice) {
    redirect("/practice-config");
  }

  const hasAssistant = practice.assistantConfig?.vapiAssistantId;

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-2xl mx-auto">
        <h1 className="text-3xl font-bold mb-6">Laine AI Assistant Configuration</h1>
        <LainePracticeClient 
          practice={practice} 
          hasAssistant={!!hasAssistant}
          createPracticeAssistant={createPracticeAssistant}
        />
      </div>
    </div>
  );
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ClerkProvider, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Laine AI Voice Assistant",
  description: "Advanced voice assistant for healthcare practices with seamless NexHealth integration",
};

async function Header() {
  const { userId } = await auth();
  
  return (
    <header className="fixed top-0 left-0 right-0 bg-white/10 backdrop-blur-md border-b border-slate-200/30 z-50">
      <div className="flex items-center justify-between max-w-6xl mx-auto px-6 py-4">
        <div className="flex items-center">
          <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center mr-3">
            <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
          <h1 className="text-xl font-bold text-slate-900">Laine AI</h1>
        </div>
        <div className="flex items-center gap-4">
          {userId ? (
            <div className="flex items-center gap-4">
              <a 
                href="/practice-config" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Practice Config
              </a>
              <a 
                href="/laine" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Laine Assistant
              </a>
              <a 
                href="/test" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Test
              </a>
              <a 
                href="/tool-calls" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Tool Calls
              </a>
              <UserButton afterSignOutUrl="/" />
            </div>
          ) : (
            <>
              <SignInButton mode="modal">
                <button className="px-4 py-2 text-sm font-medium text-slate-600 hover:text-slate-900 transition-colors">
                  Sign In
                </button>
              </SignInButton>
              <SignUpButton mode="modal">
                <button className="px-4 py-2 text-sm font-semibold bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                  Sign Up
                </button>
              </SignUpButton>
            </>
          )}
        </div>
      </div>
    </header>
  );
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body
          className={`${geistSans.variable} ${geistMono.variable} antialiased bg-slate-50`}
        >
          <Header />
          <main className="pt-20">
            {children}
          </main>
        </body>
      </html>
    </ClerkProvider>
  );
}

================
File: lib/tools/findAppointmentType.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const findAppointmentTypeSchema = z.object({
  userRequest: z.string()
    .min(1)
    .describe(`Patient's requested service type. Common variations: cleaning/hygiene/prophy, checkup/exam, emergency/pain, filling/cavity, crown/cap, root canal, extraction/pull tooth. Example: "I need a cleaning" → "cleaning"`)
});

const findAppointmentTypeTool: ToolDefinition<typeof findAppointmentTypeSchema> = {
  name: "find_appointment_type",
  description: "Matches patient's service request to available appointment types. Use after confirming patient identity when they mention what type of appointment they need (cleaning, checkup, filling, etc.).",
  schema: findAppointmentTypeSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.appointmentTypes || practice.appointmentTypes.length === 0) {
      return {
        success: false,
        error_code: "NO_APPOINTMENT_TYPES",
        message_to_patient: "I don't have any appointment types configured for this practice. Please contact the office directly to schedule your appointment."
      };
    }

    try {
      const userRequest = args.userRequest.toLowerCase().trim();
      
      // Create searchable appointment type list with common aliases
      const appointmentTypeAliases: Record<string, string[]> = {
        'cleaning': ['clean', 'hygiene', 'prophy', 'prophylaxis', 'dental cleaning', 'teeth cleaning'],
        'checkup': ['check', 'exam', 'examination', 'visit', 'routine'],
        'consultation': ['consult', 'new patient', 'initial'],
        'filling': ['cavity', 'restoration', 'tooth repair'],
        'crown': ['cap', 'tooth cap'],
        'root canal': ['endodontic', 'nerve', 'tooth infection'],
        'extraction': ['pull', 'remove', 'tooth removal'],
        'emergency': ['urgent', 'pain', 'broken', 'asap']
      };

      const availableTypes = practice.appointmentTypes.map(type => ({
        id: type.nexhealthAppointmentTypeId,
        name: type.name,
        duration: type.duration,
        searchTerms: type.name.toLowerCase(),
        aliases: [] as string[]
      }));

      // Add aliases to available types
      availableTypes.forEach(type => {
        Object.entries(appointmentTypeAliases).forEach(([key, aliases]) => {
          if (type.searchTerms.includes(key)) {
            type.aliases = aliases;
          }
        });
      });

      console.log(`[findAppointmentType] Looking for "${userRequest}" in types:`, availableTypes.map(t => t.name));

      // Enhanced matching algorithm
      let bestMatch = null;
      let bestScore = 0;

      for (const type of availableTypes) {
        let score = 0;
        
        // Exact match gets highest score
        if (type.searchTerms === userRequest) {
          score = 100;
        }
        // Check aliases
        else if (type.aliases.some(alias => userRequest.includes(alias))) {
          score = 80;
        }
        // Check if type name is in request
        else if (userRequest.includes(type.searchTerms)) {
          score = 70;
        }
        // Partial word matches
        else {
          const requestWords = userRequest.split(' ');
          const typeWords = type.searchTerms.split(' ');
          
          for (const requestWord of requestWords) {
            for (const typeWord of typeWords) {
              if (typeWord.includes(requestWord) || requestWord.includes(typeWord)) {
                score += 20;
              }
            }
            // Check aliases too
            for (const alias of type.aliases) {
              if (alias.includes(requestWord) || requestWord.includes(alias)) {
                score += 15;
              }
            }
          }
        }

        if (score > bestScore) {
          bestScore = score;
          bestMatch = type;
        }
      }

      if (!bestMatch || bestScore < 10) {
        // No good match found - present options conversationally
        const typeOptions = availableTypes
          .slice(0, 5) // Limit to 5 options for voice
          .map(type => type.name)
          .join(', ');
          
        return {
          success: true,
          message_to_patient: `I want to make sure I schedule the right appointment for you. We offer ${typeOptions}. Which of these sounds like what you need?`,
          data: {
            matched: false,
            available_types: availableTypes.map(t => ({
              id: t.id,
              name: t.name,
              duration: t.duration
            })),
            user_request: userRequest
          }
        };
      }

      // Good match found - confirm and move forward
      return {
        success: true,
        message_to_patient: `Perfect! I can schedule you for a ${bestMatch.name} which takes ${bestMatch.duration} minutes. What day would work best for you?`,
        data: {
          matched: true,
          appointment_type_id: bestMatch.id,
          appointment_type_name: bestMatch.name,
          duration_minutes: bestMatch.duration,
          user_request: userRequest
        }
      };

    } catch (error) {
      console.error(`[findAppointmentType] Error:`, error);
      
      return {
        success: false,
        error_code: "APPOINTMENT_TYPE_SEARCH_ERROR",
        message_to_patient: "I had trouble understanding what type of appointment you need. Could you tell me again what you'd like to come in for?",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me find the right appointment type for you...",
    success: "Okay, appointment type search processed.",
    fail: "There was an issue with the appointment type search."
  }
};

export default findAppointmentTypeTool;

================
File: lib/tools/findPatient.ts
================
// lib/tools/findPatient.ts
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Helper to get current date context
function getCurrentDateContext(): string {
  const today = new Date();
  return `Today is ${today.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  })}`;
}

export const findPatientSchema = z.object({
  firstName: z.string()
    .min(1)
    .describe(`Patient's first name. If spelled out (B-O-B), convert to proper form (Bob). Example: "My name is Bob Ross" → "Bob"`),
  lastName: z.string()
    .min(1)
    .describe(`Patient's last name. If spelled out (R-O-S-S), convert to proper form (Ross). Example: "Bob Ross" → "Ross"`),
  dateOfBirth: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe(`Date of birth in YYYY-MM-DD format. ${getCurrentDateContext()} Examples: "October 30, 1998" → "1998-10-30", "10/30/98" → "1998-10-30"`)
});

const findPatientTool: ToolDefinition<typeof findPatientSchema> = {
  name: "find_patient_in_ehr",
  description: "Use when an existing patient provides their full name and date of birth to verify their identity and retrieve their record before scheduling appointments or accessing their information. Only call when you have all three pieces: first name, last name, and complete date of birth.",
  schema: findPatientSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I'm sorry, I can't access patient records right now. Please contact the office directly for assistance."
      };
    }

    try {
      const patientName = `${args.firstName} ${args.lastName}`;
      const searchParams = {
        location_id: practice.nexhealthLocationId,
        name: patientName,
        date_of_birth: args.dateOfBirth,
        inactive: 'false',
        non_patient: 'false',
        page: '1',
        per_page: '300'
      };

      console.log(`[findPatient] Searching for: ${patientName}, DOB: ${args.dateOfBirth}`);
      
      const searchResults = await fetchNexhealthAPI(
        '/patients',
        practice.nexhealthSubdomain,
        searchParams
      );
      
      // Handle different response structures
      let patients = [];
      if (Array.isArray(searchResults)) {
        patients = searchResults;
      } else if (searchResults?.data?.patients) {
        patients = searchResults.data.patients;
      } else if (searchResults?.patients) {
        patients = searchResults.patients;
      } else if (searchResults?.data && Array.isArray(searchResults.data)) {
        patients = searchResults.data;
      }

      console.log(`[findPatient] Found ${patients.length} potential matches`);

      if (patients.length === 0) {
        // Format the date for friendly display
        const dobParts = args.dateOfBirth.split('-');
        const dobDate = new Date(parseInt(dobParts[0]), parseInt(dobParts[1]) - 1, parseInt(dobParts[2]));
        const friendlyDob = dobDate.toLocaleDateString('en-US', { 
          month: 'long', 
          day: 'numeric', 
          year: 'numeric' 
        });
        
        return {
          success: true,
          message_to_patient: `I couldn't find a patient record for ${args.firstName} ${args.lastName} with date of birth ${friendlyDob}. Are you a new patient with us, or would you like to double-check that information?`,
          data: { 
            found_patients: [], 
            patient_exists: false,
            searched_name: `${args.firstName} ${args.lastName}`,
            searched_dob: args.dateOfBirth
          }
        };
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const patient = patients[0] as any; // Take first match
      
      // Store patient context for subsequent tool calls
      await updateCallLogWithPatient(vapiCallId, practice.id, String(patient.id));
      
      // Format the date of birth for natural speech
      const patientDob = patient.bio?.date_of_birth || patient.date_of_birth || args.dateOfBirth;
      const dobParts = patientDob.split('-');
      const dobDate = new Date(parseInt(dobParts[0]), parseInt(dobParts[1]) - 1, parseInt(dobParts[2]));
      const friendlyDob = dobDate.toLocaleDateString('en-US', { 
        month: 'long', 
        day: 'numeric', 
        year: 'numeric' 
      });
      
      return {
        success: true,
        message_to_patient: `Perfect! I found ${patient.first_name || args.firstName} ${patient.last_name || args.lastName}, born ${friendlyDob}. What type of appointment would you like to schedule today?`,
        data: {
          found_patients: [{
            id: patient.id,
            firstName: patient.first_name,
            lastName: patient.last_name,
            dob: patientDob
          }],
          patient_exists: true,
          patient_id: patient.id
        }
      };

    } catch (error) {
      console.error(`[findPatient] Error:`, error);
      
      let message = "I'm having trouble accessing patient records right now. Please try again in a moment or contact the office directly.";
      if (error instanceof Error && error.message.includes("401")) {
        message = "There's an authentication issue with the patient system. Please contact the office for assistance.";
      }
      
      return {
        success: false,
        error_code: "NEXHEALTH_API_ERROR",
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me look that up for you...",
    success: "Okay, patient lookup processed.",
    fail: "There was an issue with that lookup."
  }
};

async function updateCallLogWithPatient(vapiCallId: string, practiceId: string, patientId: string) {
  try {
    const { prisma } = await import("@/lib/prisma");
    await prisma.callLog.upsert({
      where: { vapiCallId },
      create: {
        vapiCallId,
        practiceId,
        callStatus: "TOOL_IN_PROGRESS",
        nexhealthPatientId: patientId,
        callTimestampStart: new Date()
      },
      update: {
        nexhealthPatientId: patientId,
        updatedAt: new Date()
      }
    });
  } catch (error) {
    console.error("[findPatient] Error updating call log:", error);
  }
}

export default findPatientTool;

================
File: lib/tools/index.ts
================
import { ToolDefinition, VapiToolSchema, VapiToolFunction } from "./types";
import { zodToJsonSchema } from "zod-to-json-schema";

// Import all tools
import findPatientTool from "./findPatient";
import findAppointmentTypeTool from "./findAppointmentType";
import checkAvailableSlotsTool from "./checkAvailableSlots";
import bookAppointmentTool from "./bookAppointment";
import createNewPatientTool from "./createNewPatient";
import getPracticeDetailsTool from "./getPracticeDetails";
import checkInsuranceParticipationTool from "./checkInsuranceParticipation";
import getServiceCostEstimateTool from "./getServiceCostEstimate";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const tools: ToolDefinition<any>[] = [
  findPatientTool,
  findAppointmentTypeTool,
  checkAvailableSlotsTool,
  bookAppointmentTool,
  createNewPatientTool,
  getPracticeDetailsTool,
  checkInsuranceParticipationTool,
  getServiceCostEstimateTool
];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function getToolByName(name: string): ToolDefinition<any> | undefined {
  return tools.find(t => t.name === name);
}

// This function builds the array for VAPI's `model.tools[]`
export function buildVapiTools(appBaseUrl: string): VapiToolSchema[] {
  console.log(`Building VAPI tools for ${tools.length} registered tools`);
  
  return tools.map(tool => {
    // Generate JSON schema without $schema property
    const schema = zodToJsonSchema(tool.schema, { 
      target: "jsonSchema7", 
      $refStrategy: "none" 
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $schema, ...parameters } = schema;
    
    const vapiToolFunction: VapiToolFunction = {
      name: tool.name,
      description: tool.description,
      parameters
    };
    
    const vapiTool: VapiToolSchema = {
      type: "function",
      async: tool.async ?? false,
      function: vapiToolFunction,
      server: { 
        url: `${appBaseUrl}/api/vapi/tool-calls`
      }
    };

    // Add only the start message - success/fail messages will be dynamic from tool execution
    if (tool.messages?.start) {
      vapiTool.messages = [
        { type: "request-start", content: tool.messages.start }
      ];
    }
    
    console.log(`Built VAPI tool: ${tool.name} -> ${vapiTool.server.url}`);
    return vapiTool;
  });
}

// Export individual tool schemas for validation
export { findPatientSchema } from "./findPatient";
export { findAppointmentTypeSchema } from "./findAppointmentType";
export { checkAvailableSlotsSchema } from "./checkAvailableSlots";
export { bookAppointmentSchema } from "./bookAppointment";
export { createNewPatientSchema } from "./createNewPatient";
export { getPracticeDetailsSchema } from "./getPracticeDetails";
export { checkInsuranceParticipationSchema } from "./checkInsuranceParticipation";
export { getServiceCostEstimateSchema } from "./getServiceCostEstimate";

================
File: lib/nexhealth.ts
================
import { prisma } from "@/lib/prisma";
import { addSeconds } from 'date-fns';

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number; // NexHealth uses 'minutes' not 'duration'
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

interface NexHealthOperatory {
  id: number;
  name: string;
  location_id: number;
  active: boolean;
}

const NEXHEALTH_API_BASE_URL = process.env.NEXHEALTH_API_BASE_URL!;
const MASTER_NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY!; // The master key

const TOKEN_CACHE_ID = "singleton"; // Fixed ID for the single token entry
const TOKEN_EXPIRY_BUFFER_SECONDS = 300; // 5 minutes buffer
const DEFAULT_TOKEN_LIFETIME_SECONDS = 55 * 60; // 55 minutes (safe for 1-hour tokens)

async function fetchNewBearerToken(): Promise<{ accessToken: string; expiresAt: Date }> {
  if (!MASTER_NEXHEALTH_API_KEY) {
    throw new Error("NEXHEALTH_API_KEY is not configured in environment variables.");
  }

  const authUrl = `${NEXHEALTH_API_BASE_URL}/authenticates`;
  console.log("Fetching new NexHealth bearer token...");

  try {
    const response = await fetch(authUrl, {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.Nexhealth+json;version=2',
        // NexHealth expects the raw master key for /authenticates endpoint
        'Authorization': MASTER_NEXHEALTH_API_KEY,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("Failed to fetch NexHealth bearer token:", response.status, errorBody);
      throw new Error(`NexHealth Authentication failed: ${response.status} - ${errorBody}`);
    }

    const result = await response.json();
    
    if (!result.data || !result.data.token) {
      console.error("NexHealth /authenticates response missing token:", result);
      throw new Error("Invalid token response from NexHealth /authenticates");
    }

    const accessToken = result.data.token;
    const now = new Date();
    
    // If NexHealth provides expiry in response, use it. Otherwise, use default lifetime.
    // Most JWT tokens have 1-hour validity, we use 55 minutes to be safe
    let expiresAt: Date;
    
    if (result.data.exp) {
      // If exp is provided as UNIX timestamp (seconds)
      expiresAt = new Date(result.data.exp * 1000);
    } else {
      // Default to 55 minutes from now
      expiresAt = addSeconds(now, DEFAULT_TOKEN_LIFETIME_SECONDS);
    }

    console.log(`New NexHealth token expires at: ${expiresAt.toISOString()}`);

    // Cache the token in database
    await prisma.nexhealthTokenCache.upsert({
      where: { id: TOKEN_CACHE_ID },
      update: { accessToken, expiresAt },
      create: { id: TOKEN_CACHE_ID, accessToken, expiresAt },
    });

    return { accessToken, expiresAt };
  } catch (error) {
    console.error('Error fetching NexHealth bearer token:', error);
    throw error;
  }
}

export async function getNexhealthBearerToken(): Promise<string> {
  try {
    // Check for cached token
    const cachedToken = await prisma.nexhealthTokenCache.findUnique({
      where: { id: TOKEN_CACHE_ID },
    });

    if (cachedToken) {
      const now = new Date();
      const tokenStillValidUntil = addSeconds(now, TOKEN_EXPIRY_BUFFER_SECONDS);
      
      if (cachedToken.expiresAt > tokenStillValidUntil) {
        console.log("Using cached NexHealth bearer token.");
        return cachedToken.accessToken;
      }
      console.log("Cached NexHealth token expired or nearing expiry.");
    } else {
      console.log("No cached NexHealth token found.");
    }

    // Fetch new token if none cached or expired
    const { accessToken } = await fetchNewBearerToken();
    return accessToken;
  } catch (error) {
    console.error('Error getting NexHealth bearer token:', error);
    throw error;
  }
}

// Export the generic API function for use in tools and other modules
export async function fetchNexhealthAPI(
  path: string, // e.g., "/appointment_types"
  subdomain: string, // Practice-specific subdomain
  params?: Record<string, string | number | string[]>,
  method: string = 'GET',
  body?: unknown
) {
  // Get valid bearer token
  const bearerToken = await getNexhealthBearerToken();
  
  const url = new URL(`${NEXHEALTH_API_BASE_URL}${path}`);
  
  // Add subdomain for data API calls (not for /authenticates)
  if (path !== '/authenticates' && !params?.subdomain) {
    url.searchParams.append('subdomain', subdomain);
  }
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v.toString()));
      } else {
        url.searchParams.append(key, value.toString());
      }
    });
  }

  const options: RequestInit = {
    method,
    headers: {
      'Accept': 'application/vnd.Nexhealth+json;version=2',
      'Authorization': `Bearer ${bearerToken}`, // Use bearer token for data APIs
      'Content-Type': 'application/json',
    },
  };

  if (body && method !== 'GET') {
    options.body = JSON.stringify(body);
  }

  try {
    const response = await fetch(url.toString(), options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`NexHealth API error (${response.status}):`, errorText);
      
      // If we get 401, the token might be invalid - clear cache and retry once
      if (response.status === 401) {
        console.log("Got 401, clearing token cache and retrying...");
        await prisma.nexhealthTokenCache.deleteMany({
          where: { id: TOKEN_CACHE_ID }
        });
        
        // Retry with fresh token (recursive call - but only once due to cache clear)
        return fetchNexhealthAPI(path, subdomain, params, method, body);
      }
      
      throw new Error(`NexHealth API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('NexHealth API error:', error);
    throw error;
  }
}

export async function getAppointmentTypes(subdomain: string, locationId: string): Promise<NexHealthAppointmentType[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    { location_id: locationId }
  );
  
  // Handle different possible response structures
  let appointmentTypes = null;
  
  if (Array.isArray(data)) {
    appointmentTypes = data;
  } else if (data?.data?.appointment_types && Array.isArray(data.data.appointment_types)) {
    appointmentTypes = data.data.appointment_types;
  } else if (data?.appointment_types && Array.isArray(data.appointment_types)) {
    appointmentTypes = data.appointment_types;
  } else if (data?.data && Array.isArray(data.data)) {
    appointmentTypes = data.data;
  } else {
    console.warn("Unexpected appointment_types response structure:", data);
    appointmentTypes = [];
  }
  return appointmentTypes;
}

export async function getProviders(subdomain: string, locationId: string): Promise<NexHealthProvider[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/providers',
    subdomain,
    { location_id: locationId, inactive: 'false', page: '1', per_page: '300' }
  );
  
  // Handle different possible response structures
  let providers = null;
  
  if (Array.isArray(data)) {
    providers = data;
  } else if (data?.data?.providers && Array.isArray(data.data.providers)) {
    providers = data.data.providers;
  } else if (data?.providers && Array.isArray(data.providers)) {
    providers = data.providers;
  } else if (data?.data && Array.isArray(data.data)) {
    providers = data.data;
  } else {
    console.warn("Unexpected providers response structure:", data);
    providers = [];
  }
  return providers;
}

export async function getOperatories(subdomain: string, locationId: string): Promise<NexHealthOperatory[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/operatories',
    subdomain,
    { location_id: locationId, page: '1', per_page: '300' }
  );
  
  console.log("Raw NexHealth operatories response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let operatories = null;
  
  if (Array.isArray(data)) {
    operatories = data;
  } else if (data?.data?.operatories && Array.isArray(data.data.operatories)) {
    operatories = data.data.operatories;
  } else if (data?.operatories && Array.isArray(data.operatories)) {
    operatories = data.operatories;
  } else if (data?.data && Array.isArray(data.data)) {
    operatories = data.data;
  } else {
    console.warn("Unexpected operatories response structure:", data);
    operatories = [];
  }
  
  console.log(`Parsed ${operatories.length} operatories`);
  return operatories.filter((op: NexHealthOperatory) => op.active !== false);
}

// Availability-related interfaces and functions
interface NexHealthAvailability {
  id: number;
  provider_id: number;
  location_id: number;
  operatory_id?: number;
  begin_time: string;
  end_time: string;
  days: string[];
  specific_date?: string;
  custom_recurrence?: {
    num: number;
    unit: string;
    ref: string;
  };
  tz_offset: string;
  active: boolean;
  synced: boolean;
  appointment_types: Array<{
    id: number;
    name: string;
    parent_type: string;
    parent_id: number;
    minutes: number;
    bookable_online: boolean;
  }>;
}

interface CreateAvailabilityData {
  provider_id: number;
  operatory_id?: number;
  days: string[];
  begin_time: string;
  end_time: string;
  appointment_type_ids: number[];
  active?: boolean;
}

interface UpdateAvailabilityData {
  provider_id?: number;
  operatory_id?: number;
  days?: string[];
  begin_time?: string;
  end_time?: string;
  appointment_type_ids?: number[];
  active?: boolean;
}

export async function createNexhealthAvailability(
  subdomain: string, 
  locationId: string, 
  availabilityData: CreateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !locationId) {
    throw new Error("Subdomain and Location ID are required.");
  }

  const data = await fetchNexhealthAPI(
    '/availabilities',
    subdomain,
    { location_id: locationId },
    'POST',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth create availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected create availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth create availability");
  }

  console.log(`Created availability with ID: ${availability.id}`);
  return availability;
}

export async function updateNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string,
  availabilityData: UpdateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !nexhealthAvailabilityId) {
    throw new Error("Subdomain and availability ID are required.");
  }

  const data = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    {},
    'PATCH',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth update availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected update availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth update availability");
  }

  console.log(`Updated availability with ID: ${availability.id}`);
  return availability;
}

export async function deleteNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string
): Promise<void> {
  const response = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    undefined,
    'DELETE'
  );
  
  // For DELETE operations, expect a 204 or successful response with no data
  console.log(`Deleted NexHealth availability ${nexhealthAvailabilityId}:`, response);
}

// Appointment Type CRUD Functions

interface CreateAppointmentTypeData {
  name: string;
  minutes: number;
  bookable_online?: boolean;
  parent_type: "Location" | "Institution";
  parent_id: string | number;
  emr_appt_descriptor_ids?: number[];
}

interface UpdateAppointmentTypeData {
  name?: string;
  minutes?: number;
  bookable_online?: boolean;
  parent_type?: "Location" | "Institution";
  parent_id?: string | number;
  emr_appt_descriptor_ids?: number[];
}

export async function createNexhealthAppointmentType(
  subdomain: string,
  locationId: string,
  apptTypeData: CreateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      name: apptTypeData.name,
      minutes: apptTypeData.minutes,
      bookable_online: apptTypeData.bookable_online ?? true,
      parent_type: apptTypeData.parent_type,
      parent_id: apptTypeData.parent_id,
      ...(apptTypeData.emr_appt_descriptor_ids && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    undefined,
    'POST',
    requestBody
  );

  console.log('Created NexHealth appointment type:', response);
  return response.data;
}

export async function updateNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId: string,
  apptTypeData: UpdateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      ...(apptTypeData.name !== undefined && { name: apptTypeData.name }),
      ...(apptTypeData.minutes !== undefined && { minutes: apptTypeData.minutes }),
      ...(apptTypeData.bookable_online !== undefined && { bookable_online: apptTypeData.bookable_online }),
      ...(apptTypeData.parent_type !== undefined && { parent_type: apptTypeData.parent_type }),
      ...(apptTypeData.parent_id !== undefined && { parent_id: apptTypeData.parent_id }),
      ...(apptTypeData.emr_appt_descriptor_ids !== undefined && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    undefined,
    'PATCH',
    requestBody
  );

  console.log(`Updated NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
  return response.data;
}

export async function deleteNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId?: string
): Promise<void> {
  const params = locationId ? { location_id: locationId } : undefined;

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    params,
    'DELETE'
  );

  console.log(`Deleted NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
}

// Sync function for appointment types
export async function syncPracticeAppointmentTypes(
  practiceId: string,
  subdomain: string,
  locationId: string
): Promise<void> {
  try {
    console.log(`Syncing appointment types for practice ${practiceId}...`);
    
    // Fetch appointment types from NexHealth
    const nexhealthAppointmentTypes = await getAppointmentTypes(subdomain, locationId);
    
    console.log(`Found ${nexhealthAppointmentTypes.length} appointment types from NexHealth`);

    // Sync each appointment type with local database
    for (const nexhealthType of nexhealthAppointmentTypes) {
      try {
        await prisma.appointmentType.upsert({
          where: {
            practiceId_nexhealthAppointmentTypeId: {
              practiceId,
              nexhealthAppointmentTypeId: nexhealthType.id.toString()
            }
          },
          update: {
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString(),
            lastSyncError: null, // Clear any previous errors on successful sync
            updatedAt: new Date()
          },
          create: {
            practiceId,
            nexhealthAppointmentTypeId: nexhealthType.id.toString(),
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString()
          }
        });

        console.log(`Synced appointment type: ${nexhealthType.name} (ID: ${nexhealthType.id})`);
      } catch (error) {
        console.error(`Error syncing appointment type ${nexhealthType.id}:`, error);
        
        // Try to update just the error field if the record exists
        try {
          await prisma.appointmentType.update({
            where: {
              practiceId_nexhealthAppointmentTypeId: {
                practiceId,
                nexhealthAppointmentTypeId: nexhealthType.id.toString()
              }
            },
            data: {
              lastSyncError: error instanceof Error ? error.message : 'Unknown sync error',
              updatedAt: new Date()
            }
          });
        } catch (updateError) {
          console.error(`Failed to update sync error for appointment type ${nexhealthType.id}:`, updateError);
        }
      }
    }

    console.log(`Completed syncing appointment types for practice ${practiceId}`);
  } catch (error) {
    console.error(`Error syncing appointment types for practice ${practiceId}:`, error);
    throw error;
  }
}

================
File: package.json
================
{
  "name": "laine-integrated",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate",
    "vercel-build": "prisma generate && next build",
    "db:migrate": "prisma migrate deploy",
    "db:push": "prisma db push",
    "db:seed": "prisma db seed",
    "webhook:setup": "node scripts/manage-nexhealth-webhooks.js setup-global-endpoint",
    "webhook:subscribe": "node scripts/manage-nexhealth-webhooks.js subscribe-practice",
    "webhook:list": "node scripts/manage-nexhealth-webhooks.js list-subscriptions",
    "fix:appointment-types": "node scripts/fix-availability-appointment-types.js fix",
    "test:slots": "node scripts/fix-availability-appointment-types.js test-slots",
    "db:list": "node scripts/clean-database.js list",
    "db:clean": "node scripts/clean-database.js clean-test",
    "db:clean-all": "node scripts/clean-database.js clean-all-confirmed"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@clerk/nextjs": "^6.20.2",
    "@prisma/client": "^6.8.2",
    "@vapi-ai/web": "^2.3.5",
    "ai": "^4.3.16",
    "date-fns": "^4.1.0",
    "dotenv": "^16.5.0",
    "fast-glob": "^3.3.3",
    "luxon": "^3.6.1",
    "next": "15.3.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "sonner": "^2.0.4",
    "zod": "^3.25.42",
    "zod-to-json-schema": "^3.24.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/jest": "^29.5.14",
    "@types/luxon": "^3.6.2",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "jest": "^29.7.0",
    "prisma": "^6.8.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

================
File: lib/tools/bookAppointment.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import { DateTime } from "luxon";

export const bookAppointmentSchema = z.object({
  selectedTime: z.string()
    .min(1)
    .describe(`Time patient selected from available options. Include AM/PM. Examples: "I'll take 8 AM" → "8:00 AM", "The 2:30 slot" → "2:30 PM"`),
  patientId: z.string()
    .min(1)
    .describe(`CRITICAL: Numeric patient ID (e.g., "381872342") from previous find_patient_in_ehr or create_new_patient tool call. NOT patient name. Required for EHR linking.`),
  appointmentTypeId: z.string()
    .min(1)
    .describe("Appointment type ID from successful find_appointment_type tool call data.appointment_type_id field"),
  requestedDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe("Appointment date in YYYY-MM-DD format from check_available_slots or user input"),
  durationMinutes: z.number()
    .min(1)
    .describe("Appointment duration in minutes from find_appointment_type tool call data.duration_minutes field")
});

const bookAppointmentTool: ToolDefinition<typeof bookAppointmentSchema> = {
  name: "book_appointment",
  description: "Books the actual appointment after patient selects a specific time from available slots. Use after showing available slots and getting patient's time preference.",
  schema: bookAppointmentSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId, callSummaryForNote } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't book appointments right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "I need to assign a provider but none are configured. Please contact the office to complete your booking."
      };
    }

    try {
      console.log(`[bookAppointment] Booking appointment for patient ${args.patientId} on ${args.requestedDate} at ${args.selectedTime}`);

      // Validate patient ID before proceeding
      if (!args.patientId || args.patientId === 'null' || args.patientId === 'undefined' || args.patientId === 'new_patient') {
        return {
          success: false,
          error_code: "INVALID_PATIENT_ID",
          message_to_patient: "I need to verify your patient information before booking. Let me help you with that first.",
          details: `Invalid patient ID provided: ${args.patientId}`
        };
      }

      // Validate that patient ID is numeric (NexHealth requirement)
      if (isNaN(parseInt(args.patientId))) {
        return {
          success: false,
          error_code: "INVALID_PATIENT_ID_FORMAT",
          message_to_patient: "There's an issue with your patient record. Please contact the office to complete your booking.",
          details: `Patient ID must be numeric, received: ${args.patientId}`
        };
      }

      // Validate selected time format
      const timePattern = /^(1[0-2]|[1-9]):([0-5][0-9])\s?(AM|PM)$/i;
      if (!timePattern.test(args.selectedTime.trim())) {
      return {
         success: false,
         error_code: "INVALID_TIME_FORMAT",
         message_to_patient: `I didn't quite catch that time. Could you please choose from the available times I mentioned?`
       };
     }

     // Get practice configuration
     const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
     const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

     if (activeProviders.length === 0) {
       return {
         success: false,
         error_code: "NO_ACTIVE_PROVIDERS",
         message_to_patient: "I need to assign a provider but none are available. Please contact the office to complete your booking."
       };
     }

     // Find the appointment type to help with provider selection
     const appointmentType = practice.appointmentTypes?.find(
       at => at.nexhealthAppointmentTypeId === args.appointmentTypeId
     );

     // IMPROVED LOGIC: Select provider based on accepted appointment types
     let selectedProvider = activeProviders[0]; // Fallback to first
     
     if (appointmentType) {
       // Try to find a provider that accepts this appointment type
       const providersForType = activeProviders.filter(sp => {
         // If no accepted types configured, provider accepts all (backward compatibility)
         if (!sp.acceptedAppointmentTypes || sp.acceptedAppointmentTypes.length === 0) {
           return true;
         }
         // Check if provider accepts this appointment type
         return sp.acceptedAppointmentTypes.some(
           relation => relation.appointmentType.id === appointmentType.id
         );
       });

       if (providersForType.length > 0) {
         selectedProvider = providersForType[0];
       }
     }

     // IMPROVED LOGIC: Select operatory based on provider's default or first available
     let selectedOperatory = activeOperatories[0]; // Fallback

     if (selectedProvider.defaultOperatoryId) {
       const defaultOperatory = activeOperatories.find(
         op => op.id === selectedProvider.defaultOperatoryId
       );
       if (defaultOperatory) {
         selectedOperatory = defaultOperatory;
       }
     }

     if (!selectedOperatory) {
       return {
         success: false,
         error_code: "NO_ACTIVE_OPERATORIES",
         message_to_patient: "I need to assign a room but none are available. Please contact the office to complete your booking."
       };
     }

     // Convert selected time to proper start_time format
     const { startTime } = parseSelectedTimeToNexHealthFormat(
       args.selectedTime,
       args.requestedDate,
       'America/Chicago' // Default practice timezone
     );

     // Get appointment type name for notes
     const appointmentTypeNameForNote = appointmentType?.name || "Appointment";

     let finalNote = `${appointmentTypeNameForNote} - Scheduled via LAINE AI.`;
     if (callSummaryForNote && callSummaryForNote.trim() !== "" && !callSummaryForNote.toLowerCase().includes("failed") && !callSummaryForNote.toLowerCase().includes("not available")) {
       finalNote = `${callSummaryForNote} (Booked via LAINE AI)`;
     } else if (callSummaryForNote) {
       // If summary generation failed or was unavailable, append that info.
       finalNote = `${appointmentTypeNameForNote} - Scheduled via LAINE AI. (${callSummaryForNote})`;
     }
     
     // Ensure note is not excessively long for EHR systems
     if (finalNote.length > 250) { // Example limit, adjust as needed
       finalNote = finalNote.substring(0, 247) + "...";
     }

     // Prepare booking data
     const bookingData = {
       patient_id: parseInt(args.patientId),
       provider_id: parseInt(selectedProvider.provider.nexhealthProviderId),
       appointment_type_id: parseInt(args.appointmentTypeId),
       operatory_id: parseInt(selectedOperatory.nexhealthOperatoryId),
       start_time: startTime,
       note: finalNote
     };

     console.log(`[bookAppointment] Booking data with note:`, JSON.stringify(bookingData, null, 2));

     // Make the booking API call
     const bookingResponse = await fetchNexhealthAPI(
       '/appointments',
       practice.nexhealthSubdomain,
       bookingData,
       'POST'
     );

     if (!bookingResponse?.id) {
       console.error('[bookAppointment] Booking failed: Invalid response format');
       return {
         success: false,
         error_code: "BOOKING_FAILED",
         message_to_patient: "I'm having trouble booking your appointment. Please contact the office to complete your booking."
       };
     }

     // Update call log with booking information
     const appointmentId = bookingResponse.data?.id || bookingResponse.data?.appointment?.id;
     if (appointmentId) {
       await updateCallLogWithBooking(vapiCallId, String(appointmentId), args.requestedDate, args.selectedTime);
     }

     // Format appointment details for confirmation
     const formattedDate = formatDate(args.requestedDate);
     const formattedTime = args.selectedTime;
     const providerName = selectedProvider.provider.firstName ? 
       `${selectedProvider.provider.firstName} ${selectedProvider.provider.lastName || ''}`.trim() : 
       selectedProvider.provider.lastName || 'your provider';
     const appointmentTypeName = appointmentType?.name || "your appointment";

     return {
       success: true,
       message_to_patient: `Excellent! I've successfully booked your ${appointmentTypeName} for ${formattedDate} at ${formattedTime} with ${providerName}. You should receive a confirmation shortly. Is there anything else I can help you with today?`,
       data: {
         appointment_id: String(appointmentId),
         patient_id: args.patientId,
         appointment_type: appointmentTypeName,
         date: args.requestedDate,
         time: args.selectedTime,
         provider_name: providerName,
         booked: true
       }
     };

    } catch (error) {
      console.error(`[bookAppointment] Error:`, error);
      
      return {
        success: false,
        error_code: "BOOKING_ERROR",
        message_to_patient: "I'm having trouble completing your booking right now. Please contact the office directly to schedule your appointment.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me book that appointment for you...",
    success: "Okay, booking processed.",
    fail: "There was an issue with the booking."
  }
};

/**
* Convert patient's selected time to NexHealth API format with proper timezone handling
*/
function parseSelectedTimeToNexHealthFormat(
 selectedTime: string,
 requestedDate: string,
 practiceTimezone: string = 'America/Chicago'
): { startTime: string } {
 // Parse the selected time and date in the practice's timezone
 const localDateTime = DateTime.fromFormat(
   `${requestedDate} ${selectedTime}`,
   'yyyy-MM-dd h:mm a',
   { zone: practiceTimezone }
 );

 if (!localDateTime.isValid) {
   throw new Error(`Invalid date/time format: ${requestedDate} ${selectedTime}. Error: ${localDateTime.invalidReason}`);
 }

 // Convert to UTC and format for NexHealth API
 const startTime = localDateTime.toUTC().toISO({ suppressMilliseconds: true });

 if (!startTime) {
   throw new Error(`Failed to convert to UTC: ${requestedDate} ${selectedTime}`);
 }

 console.log(`[timezone] Converting ${selectedTime} on ${requestedDate} in ${practiceTimezone} to UTC: ${startTime}`);

 return { startTime };
}

/**
* Format date for patient-friendly display
*/
function formatDate(dateString: string): string {
 try {
   const date = new Date(dateString + 'T00:00:00');
   return date.toLocaleDateString('en-US', {
     weekday: 'long',
     month: 'long',
     day: 'numeric'
   });
 } catch {
   return dateString;
 }
}

/**
* Update call log with booking information
*/
async function updateCallLogWithBooking(
 vapiCallId: string,
 appointmentId: string,
 appointmentDate: string,
 appointmentTime: string
) {
 try {
   const { prisma } = await import("@/lib/prisma");
   await prisma.callLog.update({
     where: { vapiCallId },
     data: {
       callStatus: "APPOINTMENT_BOOKED",
       bookedAppointmentNexhealthId: appointmentId,
       summary: `Appointment booked for ${appointmentDate} at ${appointmentTime}`,
       updatedAt: new Date()
     }
   });
 } catch (error) {
   console.error("[bookAppointment] Error updating call log:", error);
 }
}

export default bookAppointmentTool;

================
File: lib/tools/createNewPatient.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Helper for current date context
function getCurrentDateContext(): string {
  const today = new Date();
  return `Today is ${today.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  })}`;
}

export const createNewPatientSchema = z.object({
  firstName: z.string()
    .min(1)
    .describe(`Patient's first name. If spelled out (B-O-B), convert to proper form (Bob). Example: "My name is Sarah" → "Sarah"`),
  lastName: z.string()
    .min(1)
    .describe(`Patient's last name. If spelled out (T-E-S-T), convert to proper form (Test). Example: "Last name is Johnson" → "Johnson"`),
  dateOfBirth: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe(`Date of birth in YYYY-MM-DD format. ${getCurrentDateContext()} Example: "January 20, 1990" → "1990-01-20"`),
  phone: z.string()
    .min(10)
    .describe(`Phone number as digits only. Example: "313-555-1200" → "3135551200"`),
  email: z.string()
    .email()
    .describe(`Email address. Convert spoken format. Example: "john at gmail dot com" → "john@gmail.com"`),
  insurance_name: z.string().optional()
    .describe("Dental insurance company name if provided (e.g., Cigna, MetLife). Optional.")
});

const createNewPatientTool: ToolDefinition<typeof createNewPatientSchema> = {
  name: "create_new_patient",
  description: `Creates new patient record when all required information is collected: first name, last name, date of birth, phone (10+ digits), and valid email. Insurance name is optional. CRITICAL: Only call when you have ALL required fields - do not call with missing or empty values.`,
  schema: createNewPatientSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I'm sorry, I can't create new patient records right now. Please contact the office directly to register as a new patient."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "I need to assign you to a provider but none are configured. Please contact the office to complete your registration."
      };
    }

    try {
      // Validate all required fields are present and valid
      const validationResult = validatePatientData(args);
      if (!validationResult.isValid) {
        return {
          success: false,
          error_code: validationResult.errorCode || "VALIDATION_ERROR",
          message_to_patient: validationResult.message || "There was an issue with the information provided.",
          details: validationResult.details || "Validation failed"
        };
      }

      // Get the first active provider for new patient assignment
      const activeProvider = practice.savedProviders.find(sp => sp.isActive);
      if (!activeProvider) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "I need to assign you to a provider but none are available. Please contact the office to complete your registration."
        };
      }

      // Prepare new patient data in EXACT NexHealth API format (matching your curl example)
      const patientBio: {
        date_of_birth: string;
        phone_number: string;
        gender: string;
        insurance_name?: string;
      } = {
        date_of_birth: args.dateOfBirth,
        phone_number: args.phone,
        gender: "Female" // Default as per API example - this can be enhanced later
      };

      // Add insurance_name if provided
      if (args.insurance_name && args.insurance_name.trim() !== "") {
        patientBio.insurance_name = args.insurance_name.trim();
      }

      const newPatientData = {
        provider: { 
          provider_id: parseInt(activeProvider.provider.nexhealthProviderId) 
        },
        patient: {
          first_name: args.firstName,
          last_name: args.lastName,
          email: args.email,
          bio: patientBio
        }
      };

      console.log(`[createNewPatient] Creating patient: ${args.firstName} ${args.lastName}`);
      console.log(`[createNewPatient] Patient data:`, JSON.stringify(newPatientData, null, 2));

      const createResponse = await fetchNexhealthAPI(
        '/patients',
        practice.nexhealthSubdomain,
        { location_id: practice.nexhealthLocationId },
        'POST',
        newPatientData
      );

      console.log(`[createNewPatient] API Response:`, JSON.stringify(createResponse, null, 2));

      // Extract patient ID from response (following your curl response format)
      let newPatientId = null;
      if (createResponse?.data?.user?.id) {
        newPatientId = createResponse.data.user.id;
      } else if (createResponse?.data?.id) {
        newPatientId = createResponse.data.id;
      }

      if (!newPatientId) {
        console.error(`[createNewPatient] Failed to extract patient ID from response`);
        return {
          success: false,
          error_code: "PATIENT_CREATION_FAILED",
          message_to_patient: "I had trouble creating your patient record. Please contact the office to complete your registration.",
          details: "Could not extract patient ID from response"
        };
      }

      // Update call log with new patient ID
      await updateCallLogWithPatient(vapiCallId, practice.id, String(newPatientId));

      // Format confirmation message
      const formattedPhone = formatPhoneForDisplay(args.phone);

      // Create context-aware success message based on insurance information
      let successMessage: string;
      if (args.insurance_name && args.insurance_name.trim() !== "") {
        successMessage = `Excellent! I've successfully created your patient profile for ${args.firstName} ${args.lastName}. I've also noted your ${args.insurance_name} insurance. To make sure we have all the details, could you provide the subscriber's full name on that policy?`;
      } else {
        successMessage = `Excellent! I've successfully created your patient profile for ${args.firstName} ${args.lastName}. Welcome to ${practice.name || 'our practice'}! Now, what type of appointment were you looking to schedule today?`;
      }

      return {
        success: true,
        message_to_patient: successMessage,
        data: {
          patient_id: String(newPatientId), // Ensure string format for consistency with bookAppointment.ts
          patient_name: `${args.firstName} ${args.lastName}`,
          date_of_birth: args.dateOfBirth,
          phone: formattedPhone,
          email: args.email,
          insurance_name: args.insurance_name || null,
          created: true
        }
      };

    } catch (error) {
      console.error(`[createNewPatient] Error:`, error);
      
      let message = "I'm having trouble creating your patient record right now. Please contact the office directly to register.";
      let errorCode = "PATIENT_CREATION_ERROR";
      
      if (error instanceof Error) {
        if (error.message.includes("400") || error.message.includes("validation")) {
          errorCode = "VALIDATION_ERROR";
          message = "There was an issue with the information provided. Let me help you with the registration process.";
        } else if (error.message.includes("409") || error.message.includes("duplicate")) {
          errorCode = "DUPLICATE_PATIENT";
          message = `It looks like you're already in our system, ${args.firstName}! I've found your existing record. Will you be using the same insurance we have on file, or has anything changed?`;
        } else if (error.message.includes("401")) {
          errorCode = "AUTH_ERROR";
          message = "There's an authentication issue with our system. Please contact the office to register.";
        }
      }
      
      return {
        success: false,
        error_code: errorCode,
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me gather the information needed to create your patient record...",
    success: "Okay, patient registration processed.",
    fail: "There was an issue with the registration."
  }
};

/**
 * Validate patient data with comprehensive checks
 */
function validatePatientData(args: {
  firstName: string;
  lastName: string;
  dateOfBirth: string;
  phone: string;
  email: string;
}): 
  | { isValid: true; errorCode?: undefined; message?: undefined; details?: undefined }
  | { isValid: false; errorCode: string; message: string; details: string } {
  
  // Check first name
  if (!args.firstName || args.firstName.trim().length === 0) {
    return {
      isValid: false,
      errorCode: "MISSING_FIRST_NAME",
      message: "I need your first name to create your patient record. Could you tell me your first name?",
      details: "First name is required"
    };
  }

  // Check last name
  if (!args.lastName || args.lastName.trim().length === 0) {
    return {
      isValid: false,
      errorCode: "MISSING_LAST_NAME",
      message: "I need your last name to create your patient record. Could you tell me your last name?",
      details: "Last name is required"
    };
  }

  // Check date of birth format
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!args.dateOfBirth || !dateRegex.test(args.dateOfBirth)) {
    return {
      isValid: false,
      errorCode: "INVALID_DATE_OF_BIRTH",
      message: "I need your date of birth in a valid format. Could you tell me your date of birth again?",
      details: "Date of birth must be in YYYY-MM-DD format"
    };
  }

  // Check phone number
  if (!args.phone || args.phone.length < 10) {
    return {
      isValid: false,
      errorCode: "MISSING_PHONE",
      message: "I need your phone number to create your patient record. What's your phone number?",
      details: "Phone number is required and must be at least 10 digits"
    };
  }

  // Check email
  if (!args.email || !args.email.includes('@')) {
    return {
      isValid: false,
      errorCode: "MISSING_EMAIL",
      message: "I need your email address to create your patient record. What's your email address?",
      details: "Valid email address is required"
    };
  }

  // Additional phone validation - ensure it's digits only
  const phoneDigits = args.phone.replace(/\D/g, '');
  if (phoneDigits.length < 10) {
    return {
      isValid: false,
      errorCode: "INVALID_PHONE",
      message: "I didn't get a valid phone number. Could you tell me your phone number again?",
      details: "Phone number must contain at least 10 digits"
    };
  }

  return { isValid: true };
}

/**
 * Format phone number for display
 */
function formatPhoneForDisplay(phone: string): string {
  const digits = phone.replace(/\D/g, '');
  if (digits.length === 10) {
    return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
  }
  return phone;
}

/**
 * Update call log with new patient ID
 */
async function updateCallLogWithPatient(vapiCallId: string, practiceId: string, patientId: string) {
  try {
    const { prisma } = await import("@/lib/prisma");
    await prisma.callLog.upsert({
      where: { vapiCallId },
      create: {
        vapiCallId,
        practiceId,
        callStatus: "TOOL_IN_PROGRESS",
        nexhealthPatientId: patientId,
        callTimestampStart: new Date()
      },
      update: {
        nexhealthPatientId: patientId,
        updatedAt: new Date()
      }
    });
  } catch (error) {
    console.error("[createNewPatient] Error updating call log:", error);
  }
}

export default createNewPatientTool;

================
File: app/api/vapi/tool-calls/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getToolByName } from "@/lib/tools";
import { prisma } from "@/lib/prisma";
import { ToolExecutionContext, ToolDefinition } from "@/lib/tools/types";
import { getErrorCode, getPatientMessage } from "@/lib/utils/error-messages";
import { generateCallSummaryForNote } from "@/lib/ai/summarization";

// Type for VAPI payload (flexible to handle various structures)
interface VapiPayload {
  message: {
    type: string;
    call: {
      id: string;
      assistantId?: string;
      assistant?: {
        id?: string;
        [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
      };
      [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    assistant?: {
      id?: string;
      [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    toolCallList?: any[]; // eslint-disable-line @typescript-eslint/no-explicit-any
    [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
  };
}

// Enhanced function to extract assistant ID with strict validation
function extractAssistantId(payload: VapiPayload): string {
  const { message } = payload;
  
  console.log("=== Assistant ID Extraction Debug ===");
  console.log("Call object keys:", Object.keys(message.call || {}));
  console.log("Assistant object keys:", Object.keys(message.assistant || {}));
  
  // Check if VAPI is sending assistant ID in different locations
  const assistantId = message.call?.assistantId || 
                     message.assistant?.id ||
                     message.call?.assistant?.id;
  
  if (!assistantId) {
    // For VAPI tool call payloads, assistant ID is often not included
    // This is normal behavior, not a critical error
    console.log("ℹ️ No assistant ID found in VAPI tool call payload (this is normal)");
    console.log("Payload structure:", JSON.stringify({
      call: Object.keys(message.call || {}),
      assistant: Object.keys(message.assistant || {}),
      assistantName: message.assistant?.name || message.call?.assistant?.name
    }, null, 2));
    
    // Use assistant name as fallback (standard for VAPI tool calls)
    const assistantName = message.assistant?.name || message.call?.assistant?.name;
    if (assistantName && assistantName.includes(" - Laine")) {
      console.log("✅ Using assistant name for practice lookup:", assistantName);
      return assistantName; // This will be handled differently in practice lookup
    }
    
    throw new Error("Assistant identification is required for practice lookup");
  }
  
  console.log("✅ Found assistant ID:", assistantId);
  return assistantId;
}

// Simplified practice lookup with strict validation - now handles assistant name fallback
async function findPracticeByAssistantId(assistantIdOrName: string) {
  console.log("=== Practice Lookup Debug ===");
  console.log("Assistant ID or Name:", assistantIdOrName);
  
  try {
    let practice = null;
    
    // First try to find by assistant ID (preferred method)
    const assistantConfig = await prisma.practiceAssistantConfig.findUnique({
      where: { vapiAssistantId: assistantIdOrName },
      include: { 
        practice: true
      }
    });
    
    if (assistantConfig) {
      practice = assistantConfig.practice;
      console.log("✅ Found practice by assistant ID:", practice.id);
    }
    
    // If not found and looks like an assistant name, try to find by Royal Oak or subdomain
    if (!practice && (assistantIdOrName.includes("Laine") || assistantIdOrName.includes("Practice"))) {
      console.log("⚠️ Attempting practice lookup by assistant name:", assistantIdOrName);
      
      const config = await prisma.practiceAssistantConfig.findFirst({
        where: { 
          practice: {
            OR: [
              { name: { contains: "Royal Oak" } },
              { nexhealthSubdomain: "xyz" } // Fallback to known subdomain
            ]
          }
        },
        include: { practice: true }
      });
      
      if (config) {
        practice = config.practice;
        console.log(`✅ Found practice by pattern matching:`, practice.id);
        console.log(`   Pattern used: Looking for Royal Oak or xyz subdomain`);
      }
      
      // If still not found but this looks like a Laine assistant, try fallback to first practice
      if (!practice && (assistantIdOrName.includes("Laine") || assistantIdOrName.includes("Practice"))) {
        console.log("⚠️ No exact match found, trying first available practice as fallback");
        const fallbackConfig = await prisma.practiceAssistantConfig.findFirst({
          include: { practice: true }
        });
        
        if (fallbackConfig) {
          practice = fallbackConfig.practice;
          console.log(`✅ Using fallback practice:`, practice.id);
          console.log(`   Note: This should be temporary - assistant name should be fixed`);
        }
      }
    }
    
    if (!practice) {
      console.log("❌ No practice found for assistant ID/name:", assistantIdOrName);
      return null;
    }
    
    console.log("✅ Successfully found practice:", practice.id);
    return await fetchPracticeWithSchedulingData(practice.id);
    
  } catch (error) {
    console.error("❌ Error in practice lookup:", error);
    return null;
  }
}

// Separate function to fetch practice with scheduling data
async function fetchPracticeWithSchedulingData(practiceId: string) {
  try {
    const practice = await prisma.practice.findUnique({ 
      where: { id: practiceId },
      include: {
        appointmentTypes: true,
        savedProviders: {
          where: { isActive: true },
          include: {
            provider: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                nexhealthProviderId: true
              }
            }
          }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });
    
    if (!practice) {
      console.error(`❌ Practice not found: ${practiceId}`);
      return null;
    }
    
    console.log("✅ Loaded practice with scheduling data:", {
      id: practice.id,
      name: practice.name,
      appointmentTypes: practice.appointmentTypes.length,
      savedProviders: practice.savedProviders.length,
      savedOperatories: practice.savedOperatories.length
    });
    
    return practice;
  } catch (error) {
    console.error("❌ Error fetching practice with scheduling data:", error);
    return null;
  }
}

// Enhanced tool name extraction function
function extractToolName(toolCall: any): string | null { // eslint-disable-line @typescript-eslint/no-explicit-any
  // Log the tool call structure for debugging
  console.log("=== Tool Call Structure Debug ===");
  console.log("Tool call keys:", Object.keys(toolCall));
  console.log("Tool call object:", JSON.stringify(toolCall, null, 2));
  
  // Method 1: Check function.name (most common)
  if (toolCall.function && typeof toolCall.function === 'object' && toolCall.function.name) {
    console.log("✅ Found tool name in function.name:", toolCall.function.name);
    return toolCall.function.name;
  }
  
  // Method 2: Check direct name property
  if (toolCall.name && typeof toolCall.name === 'string') {
    console.log("✅ Found tool name in name:", toolCall.name);
    return toolCall.name;
  }
  
  // Method 3: Check if function is a string (edge case)
  if (typeof toolCall.function === 'string') {
    console.log("✅ Found tool name as string in function:", toolCall.function);
    return toolCall.function;
  }
  
  console.error("❌ Unable to extract tool name from tool call");
  console.error("Available fields:", {
    hasFunction: !!toolCall.function,
    functionType: typeof toolCall.function,
    functionKeys: toolCall.function ? Object.keys(toolCall.function) : null,
    hasName: !!toolCall.name,
    nameType: typeof toolCall.name
  });
  
  return null;
}

// Enhanced tool call ID extraction function
function extractToolCallId(toolCall: any): string { // eslint-disable-line @typescript-eslint/no-explicit-any
  // Method 1: Check id property
  if (toolCall.id && typeof toolCall.id === 'string') {
    console.log("✅ Found tool call ID in id:", toolCall.id);
    return toolCall.id;
  }
  
  // Method 2: Check toolCallId property
  if (toolCall.toolCallId && typeof toolCall.toolCallId === 'string') {
    console.log("✅ Found tool call ID in toolCallId:", toolCall.toolCallId);
    return toolCall.toolCallId;
  }
  
  // Method 3: Generate fallback ID
  const fallbackId = `fallback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  console.warn("⚠️ No tool call ID found, using fallback:", fallbackId);
  
  return fallbackId;
}

// Enhanced tool call argument extraction
function extractToolCallArguments(toolCall: any): Record<string, unknown> { // eslint-disable-line @typescript-eslint/no-explicit-any
  console.log("=== Tool Call Arguments Extraction ===");
  console.log("Tool call structure:", Object.keys(toolCall));
  
  // Handle multiple possible argument formats from VAPI
  if (typeof toolCall.arguments === 'string') {
    try {
      const parsed = JSON.parse(toolCall.arguments);
      console.log("✅ Parsed arguments from string:", parsed);
      return parsed;
    } catch (error) {
      console.error("❌ Failed to parse tool call arguments as JSON string:", error);
      return {};
    }
  }
  
  if (typeof toolCall.arguments === 'object' && toolCall.arguments !== null) {
    console.log("✅ Using arguments object directly:", toolCall.arguments);
    return toolCall.arguments;
  }
  
  // Check if arguments are in toolCall.function.arguments
  if (toolCall.function?.arguments) {
    if (typeof toolCall.function.arguments === 'string') {
      try {
        const parsed = JSON.parse(toolCall.function.arguments);
        console.log("✅ Parsed function arguments from string:", parsed);
        return parsed;
      } catch (error) {
        console.error("❌ Failed to parse function arguments as JSON string:", error);
        return {};
      }
    }
    
    if (typeof toolCall.function.arguments === 'object') {
      console.log("✅ Using function arguments object:", toolCall.function.arguments);
      return toolCall.function.arguments;
    }
  }
  
  console.error("❌ Unable to extract arguments from tool call:", toolCall);
  return {};
}

async function executeToolSafely(
  // Use more flexible typing to avoid constraint issues
  tool: ToolDefinition<any>, // eslint-disable-line @typescript-eslint/no-explicit-any
  toolCall: any, // eslint-disable-line @typescript-eslint/no-explicit-any 
  context: ToolExecutionContext
) {
  try {
    const parsedArgs = extractToolCallArguments(toolCall);
    const startTime = Date.now();
    
    console.log(`Executing tool: ${tool.name} for practice ${context.practice.id} with args:`, parsedArgs);
    
    // Pre-validation for create_new_patient to prevent premature calls
    if (tool.name === 'create_new_patient') {
      const preValidationResult = validateCreateNewPatientArgs(parsedArgs);
      if (!preValidationResult.isValid) {
        console.log(`[${tool.name}] Pre-validation failed:`, preValidationResult.reason);
        
        const preValidationError = {
          success: false,
          error_code: preValidationResult.errorCode,
          message_to_patient: preValidationResult.message,
          details: preValidationResult.reason
        };
        
        // Log the pre-validation failure
        await logToolExecution(
          context,
          tool.name,
          parsedArgs,
          preValidationError,
          false,
          preValidationResult.reason
        );
        
        return preValidationError;
      }
    }
    
    // Validate arguments with tool schema
    const validatedArgs = tool.schema.parse(parsedArgs);
    
    const toolResult = await tool.run({
      args: validatedArgs,
      context
    });
    
    const executionTime = Date.now() - startTime;
    
    // Log successful execution
    await logToolExecution(
      context,
      tool.name,
      validatedArgs,
      toolResult,
      true,
      undefined,
      executionTime
    );
    
    return toolResult;
  } catch (error) {
    console.error(`Error executing tool ${tool.name}:`, error);
    
    const errorResult = {
      success: false,
      error_code: getErrorCode(error, tool.name),
      message_to_patient: getPatientMessage(getErrorCode(error, tool.name)),
      details: error instanceof Error ? error.message : "Unknown error"
    };
    
    // Log failed execution
    await logToolExecution(
      context,
      tool.name,
      toolCall.arguments || toolCall.function?.arguments || {},
      errorResult,
      false,
      error instanceof Error ? error.message : "Unknown error"
    );
    
    return errorResult;
  }
}

/**
 * Pre-validation for create_new_patient to prevent premature tool calls
 */
function validateCreateNewPatientArgs(args: any): { // eslint-disable-line @typescript-eslint/no-explicit-any
  isValid: boolean;
  errorCode?: string;
  message?: string;
  reason?: string;
} {
  // Check if any required field is missing or empty
  const requiredFields = ['firstName', 'lastName', 'dateOfBirth', 'phone', 'email'];
  const missingFields = [];
  
  for (const field of requiredFields) {
    if (!args[field] || typeof args[field] !== 'string' || args[field].trim().length === 0) {
      missingFields.push(field);
    }
  }
  
  // If multiple fields are missing, provide comprehensive guidance
  if (missingFields.length > 1) {
    const missingFieldsStr = missingFields.join(', ');
    let message = "";
    
    if (missingFields.includes('firstName') || missingFields.includes('lastName') || missingFields.includes('dateOfBirth')) {
      message = "I need to collect some information to create your patient record. Could you spell your first and last name letter by letter, then give me your date of birth?";
    } else if (missingFields.includes('phone') && missingFields.includes('email')) {
      message = "I still need your phone number and email address to finish creating your patient record. What's your phone number?";
    } else {
      message = getMissingFieldMessage(missingFields[0]);
    }
    
    return {
      isValid: false,
      errorCode: getMissingFieldErrorCode(missingFields[0]),
      message,
      reason: `Multiple missing fields: ${missingFieldsStr}`
    };
  }
  
  // Single field missing
  if (missingFields.length === 1) {
    const field = missingFields[0];
    return {
      isValid: false,
      errorCode: getMissingFieldErrorCode(field),
      message: getMissingFieldMessage(field),
      reason: `Missing or empty ${field}: "${args[field]}"`
    };
  }
  
  // Additional validation for phone (minimum 10 digits)
  const phoneDigits = args.phone.replace(/\D/g, '');
  if (phoneDigits.length < 10) {
    return {
      isValid: false,
      errorCode: 'MISSING_PHONE',
      message: "I need your phone number to create your patient record. What's your phone number?",
      reason: `Phone number too short: "${args.phone}" (${phoneDigits.length} digits)`
    };
  }
  
  // Additional validation for email (basic @ check)
  if (!args.email.includes('@') || !args.email.includes('.')) {
    return {
      isValid: false,
      errorCode: 'MISSING_EMAIL',
      message: "I need your email address to create your patient record. What's your email address?",
      reason: `Invalid email format: "${args.email}"`
    };
  }
  
  return { isValid: true };
}

/**
 * Get error code for missing field
 */
function getMissingFieldErrorCode(field: string): string {
  switch (field) {
    case 'firstName': return 'MISSING_FIRST_NAME';
    case 'lastName': return 'MISSING_LAST_NAME';
    case 'dateOfBirth': return 'INVALID_DATE_OF_BIRTH';
    case 'phone': return 'MISSING_PHONE';
    case 'email': return 'MISSING_EMAIL';
    default: return 'VALIDATION_ERROR';
  }
}

/**
 * Get error message for missing field
 */
function getMissingFieldMessage(field: string): string {
  switch (field) {
    case 'firstName': 
      return "I need your first name to create your patient record. Could you tell me your first name?";
    case 'lastName': 
      return "I need your last name to create your patient record. Could you tell me your last name?";
    case 'dateOfBirth': 
      return "I need your date of birth to create your patient record. Could you tell me your date of birth?";
    case 'phone': 
      return "I need your phone number to create your patient record. What's your phone number?";
    case 'email': 
      return "I need your email address to create your patient record. What's your email address?";
    default: 
      return "I need some additional information to complete your registration.";
  }
}

async function logToolExecution(
  context: ToolExecutionContext,
  toolName: string,
  arguments_: unknown,
  result: unknown,
  success: boolean,
  error?: string,
  executionTimeMs?: number
) {
  try {
    await prisma.toolLog.create({
      data: {
        practiceId: context.practice.id,
        vapiCallId: context.vapiCallId,
        toolName,
        toolCallId: context.toolCallId,
        arguments: JSON.stringify(arguments_),
        result: JSON.stringify(result),
        success,
        error,
        executionTimeMs: executionTimeMs || 0
      }
    });
  } catch (logError) {
    console.error("Error logging tool execution:", logError);
  }
}

export async function POST(req: NextRequest) {
  console.log("=== VAPI Centralized Tool Handler ===");
  
  try {
    // TODO: Implement request verification when VAPI provides signing
    
    const payload: VapiPayload = await req.json();
    console.log("VAPI payload:", JSON.stringify(payload, null, 2));
    
    // Validate payload structure
    if (!payload.message || payload.message.type !== "tool-calls") {
      console.error("Invalid payload type:", payload.message?.type);
      return NextResponse.json({ error: "Invalid payload type" }, { status: 400 });
    }
    
    const { message } = payload;
    const vapiCallId = message.call.id;
    
    let assistantId: string;
    let practice: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    
    try {
      assistantId = extractAssistantId(payload);
      practice = await findPracticeByAssistantId(assistantId);
      
      if (!practice) {
        throw new Error(`No practice found for assistant ID/name: ${assistantId}`);
      }
    } catch (error) {
      console.error("Assistant ID extraction or practice lookup failed:", error);
      
      // Create detailed error for debugging
      const debugInfo = {
        error: error instanceof Error ? error.message : "Unknown error",
        callId: vapiCallId,
        assistantName: (message.assistant as any)?.name, // eslint-disable-line @typescript-eslint/no-explicit-any
        availableFields: {
          call: Object.keys(message.call || {}),
          assistant: Object.keys(message.assistant || {})
        }
      };
      
      console.error("Debug info:", JSON.stringify(debugInfo, null, 2));
      
      // Return error results for all tool calls
      const toolCalls = message.toolCallList || message.toolCalls || [];
      const errorResults = toolCalls.map((toolCall: any) => ({ // eslint-disable-line @typescript-eslint/no-explicit-any
        toolCallId: extractToolCallId(toolCall),
        result: JSON.stringify({
          success: false,
          error_code: "ASSISTANT_ID_OR_PRACTICE_ERROR", 
          message_to_patient: "I'm having trouble connecting to your practice's system. Please try again or contact the office directly.",
          debug_info: debugInfo
        })
      }));
      
      return NextResponse.json({ results: errorResults });
    }
    
    // Update call log status
    try {
      await prisma.callLog.upsert({
        where: { vapiCallId },
        create: {
          vapiCallId,
          practiceId: practice.id,
          callStatus: "TOOL_IN_PROGRESS",
          callTimestampStart: new Date()
        },
        update: {
          callStatus: "TOOL_IN_PROGRESS",
          updatedAt: new Date()
        }
      });
    } catch (dbError) {
      console.error("Error updating CallLog:", dbError);
    }
    
    // Process all tool calls
    const results = [];
    
    console.log(`Processing ${(message.toolCallList || []).length} tool call(s)`);
    
    for (let i = 0; i < (message.toolCallList || []).length; i++) {
      const toolCall = (message.toolCallList || [])[i];
      
      console.log(`=== Processing Tool Call ${i + 1}/${(message.toolCallList || []).length} ===`);
     
      // Enhanced tool name extraction
      const toolName = extractToolName(toolCall);
      const toolCallId = extractToolCallId(toolCall);
      
      console.log(`Tool: ${toolName}, ID: ${toolCallId}`);
     
      if (!toolName) {
        console.error(`❌ Unable to extract tool name from tool call ${i + 1}`);
        results.push({
          toolCallId,
          result: JSON.stringify({
            success: false,
            error_code: "INVALID_TOOL_CALL",
            message_to_patient: getPatientMessage("VALIDATION_ERROR"),
            debug_info: {
              toolCallIndex: i,
              availableFields: Object.keys(toolCall),
              toolCallStructure: toolCall
            }
          })
        });
        continue;
      }
      
      const tool = getToolByName(toolName);
      
      if (!tool) {
        console.error(`❌ Unknown tool: ${toolName}`);
        results.push({
          toolCallId,
          result: JSON.stringify({
            success: false,
            error_code: "SYSTEM_ERROR",
            message_to_patient: getPatientMessage("SYSTEM_ERROR"),
            debug_info: {
              requestedTool: toolName,
              toolCallIndex: i
            }
          })
        });
        continue;
      }
      
      console.log(`✅ Found tool: ${tool.name}`);
      
      let callSummaryForNote: string | undefined = undefined; // Initialize here

      if (tool.name === "book_appointment") {
        // Debug: Log the call artifact structure to understand the payload
        console.log("[ToolCallHandler] Call artifact structure:", JSON.stringify(payload.message.call.artifact || payload.message.call, null, 2));
        
        let extractedTranscript = payload.message.call.artifact?.transcript;

        if (!extractedTranscript || typeof extractedTranscript !== 'string' || extractedTranscript.trim() === "") {
          console.warn("[ToolCallHandler] `artifact.transcript` is empty or missing. Checking alternative paths and constructing from messages.");
          
          // Try alternative paths for transcript
          const alternativePaths = [
            payload.message.call.transcript,
            payload.message.call.artifact?.messages,
            payload.message.call.artifact?.messagesOpenAIFormatted,
            payload.message.artifact?.transcript,
            payload.message.artifact?.messages,
            payload.message.artifact?.messagesOpenAIFormatted
          ];
          
          // Check for direct transcript in alternative locations
          for (const path of alternativePaths.slice(0, 1)) { // First check direct transcript paths
            if (path && typeof path === 'string' && path.trim() !== '') {
              extractedTranscript = path;
              console.log(`[ToolCallHandler] Found transcript in alternative path. Length: ${extractedTranscript.length}`);
              break;
            }
          }
          
          // If still no transcript, try to construct from messages
          if (!extractedTranscript || extractedTranscript.trim() === "") {
            const messagesArrays = [
              payload.message.call.artifact?.messages,
              payload.message.call.artifact?.messagesOpenAIFormatted,
              payload.message.artifact?.messages,
              payload.message.artifact?.messagesOpenAIFormatted
            ];
            
            for (const messages of messagesArrays) {
              if (Array.isArray(messages) && messages.length > 0) {
                console.log(`[ToolCallHandler] Constructing transcript from messages array with ${messages.length} items.`);
                console.log("[ToolCallHandler] Messages structure sample:", JSON.stringify(messages.slice(0, 3), null, 2));
                
                extractedTranscript = messages
                  .filter(msg => {
                    // Handle different message structures
                    const hasMessage = (msg.role === 'user' || msg.role === 'assistant' || msg.role === 'bot') && 
                                     (typeof msg.message === 'string' || typeof msg.content === 'string');
                    return hasMessage;
                  })
                  .map(msg => {
                    const role = msg.role === 'bot' ? 'assistant' : msg.role; // Normalize 'bot' to 'assistant'
                    const content = msg.message || msg.content || '';
                    return `${role}: ${content}`;
                  })
                  .join('\n');
                
                if (extractedTranscript.trim()) {
                  console.log(`[ToolCallHandler] Successfully constructed transcript from messages. Length: ${extractedTranscript.length}`);
                  break;
                } else {
                  console.warn("[ToolCallHandler] Constructed transcript from messages is empty, trying next messages array.");
                }
              }
            }
          }
        } else {
          console.log(`[ToolCallHandler] Using provided artifact.transcript. Length: ${extractedTranscript.length}`);
        }

        if (extractedTranscript && typeof extractedTranscript === 'string' && extractedTranscript.trim() !== "") {
          try {
            console.log(`[ToolCallHandler] Generating summary for book_appointment. Transcript used (first 500 chars): \n"""\n${extractedTranscript.substring(0, 500)}${extractedTranscript.length > 500 ? '...' : ''}\n"""`);
            callSummaryForNote = await generateCallSummaryForNote(extractedTranscript);
            console.log("[ToolCallHandler] Generated summary for note:", callSummaryForNote);
          } catch (summaryError) {
            console.error("[ToolCallHandler] Failed to generate call summary for note:", summaryError);
            callSummaryForNote = "AI summary generation failed for appointment note.";
          }
        } else {
          console.warn("[ToolCallHandler] No transcript available (neither direct nor constructed) for book_appointment summary.");
          callSummaryForNote = "No transcript available for summary note.";
        }
      }
      
      // Create execution context
      const context: ToolExecutionContext = {
        practice,
        vapiCallId,
        toolCallId,
        assistantId: assistantId || "unknown",
        callSummaryForNote, // Pass the summary
      };
      
      const toolResult = await executeToolSafely(tool, toolCall, context);
      
      let vapiToolResponseItem: any; // eslint-disable-line @typescript-eslint/no-explicit-any

      // Apply dynamic message structure for ALL tools
      if (toolResult.success) {
        vapiToolResponseItem = {
          toolCallId,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          result: JSON.stringify((toolResult as any).data || {}), // Data for LLM context
          message: {
            type: "request-complete", // Vapi specific type
            content: toolResult.message_to_patient, // Dynamic message to be spoken
          },
        };
        console.log(`[ToolCallHandler] Tool: ${tool.name}. Prepared SUCCESS response for Vapi with immediate message:`, toolResult.message_to_patient);
      } else {
        vapiToolResponseItem = {
          toolCallId,
          error: toolResult.error_code || toolResult.details || "Tool execution failed", // Error info for LLM
          message: {
            type: "request-failed", // Vapi specific type
            content: toolResult.message_to_patient, // Dynamic error message to be spoken
          },
        };
        console.log(`[ToolCallHandler] Tool: ${tool.name}. Prepared FAILURE response for Vapi with immediate message:`, toolResult.message_to_patient);
      }

      results.push(vapiToolResponseItem);
      
      console.log(`✅ Tool ${toolName} completed. Success: ${toolResult.success}`);
    }
    
    console.log("Sending results to VAPI:", JSON.stringify({ results }));
    return NextResponse.json({ results });
     
  } catch (error) {
    console.error("Error in centralized tool handler:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Practice {
  id          String  @id @default(cuid())
  clerkUserId String  @unique // Links to Clerk User ID
  name        String? // Optional practice name entered by user

  // NexHealth specific identifiers for this practice instance
  nexhealthSubdomain  String? // User-provided NexHealth subdomain
  nexhealthLocationId String? // User-provided NexHealth Location ID

  // Webhook synchronization tracking
  webhookLastSyncAt           DateTime? // Last time webhooks were synchronized (attempt)
  webhookLastSuccessfulSyncAt DateTime? // Last time webhooks were successfully synchronized
  webhookSyncErrorMsg         String? // Error message from last sync attempt if failed

  // New fields for additional practice information
  address              String? // Practice physical address
  acceptedInsurances   String? // Comma-separated list of accepted insurances
  serviceCostEstimates String? // Service cost estimates string

  // VAPI Assistant relationship - moved to separate config table for better modularity
  assistantConfig               PracticeAssistantConfig? // One-to-one relation
  nexhealthWebhookSubscriptions NexhealthWebhookSubscription[] // One-to-many

  appointmentTypes AppointmentType[]
  providers        Provider[]
  callLogs         CallLog[] // For VAPI call logging
  toolLogs         ToolLog[] // For tool execution logging

  // Add new relationships for scheduling preferences
  savedProviders   SavedProvider[]
  savedOperatories SavedOperatory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A practice is uniquely identified by its Clerk user for our app's purposes.
  // Subdomain + LocationID identify it for NexHealth API calls.
  // If a user could manage multiple NexHealth locations, this model would need adjustment.
  // For now, one Clerk user maps to one set of NexHealth subdomain/locationId.
}

model SavedProvider {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  providerId String // References Provider.id from our synced data
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  isActive Boolean @default(true) // Allow enabling/disabling

  // New fields for provider configuration
  defaultAppointmentTypeId String? // Optional default appointment type for this provider
  defaultAppointmentType   AppointmentType? @relation("DefaultProviderAppointmentType", fields: [defaultAppointmentTypeId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  defaultOperatoryId String? // Optional default operatory for this provider
  defaultOperatory   SavedOperatory? @relation("DefaultProviderOperatory", fields: [defaultOperatoryId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  // Relationship to accepted appointment types
  acceptedAppointmentTypes ProviderAcceptedAppointmentType[]

  // Relationship to assigned operatories (many-to-many)
  assignedOperatories ProviderOperatoryAssignment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, providerId]) // Prevent duplicate saves
  @@map("saved_providers")
}

// Join model for many-to-many relationship between SavedProvider and AppointmentType
model ProviderAcceptedAppointmentType {
  id              String        @id @default(cuid())
  savedProviderId String
  savedProvider   SavedProvider @relation(fields: [savedProviderId], references: [id], onDelete: Cascade)

  appointmentTypeId String // References AppointmentType.id
  appointmentType   AppointmentType @relation("ProviderAcceptedTypes", fields: [appointmentTypeId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([savedProviderId, appointmentTypeId]) // Prevent duplicate associations
  @@map("provider_accepted_appointment_types")
}

// Join model for many-to-many relationship between SavedProvider and SavedOperatory
model ProviderOperatoryAssignment {
  id              String        @id @default(cuid())
  savedProviderId String
  savedProvider   SavedProvider @relation(fields: [savedProviderId], references: [id], onDelete: Cascade)

  savedOperatoryId String
  savedOperatory   SavedOperatory @relation(fields: [savedOperatoryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([savedProviderId, savedOperatoryId]) // Prevent duplicate assignments
  @@map("provider_operatory_assignments")
}

model SavedOperatory {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthOperatoryId String // NexHealth operatory ID
  name                 String // Display name for operatory
  isActive             Boolean @default(true) // Allow enabling/disabling

  // Reverse relation for default operatory feature
  defaultForProviders SavedProvider[] @relation("DefaultProviderOperatory")

  // Reverse relation for provider assignments
  assignedToProviders ProviderOperatoryAssignment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthOperatoryId]) // Prevent duplicate saves
  @@map("saved_operatories")
}

model PracticeAssistantConfig {
  id         String   @id @default(cuid())
  practiceId String   @unique
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  vapiAssistantId String? @unique // The ID of the assistant on VAPI's platform

  // Customizable fields by practice
  voiceProvider String @default("11labs") // e.g., "11labs", "openai", "playht"
  voiceId       String @default("burt") // e.g., "burt" for 11labs, "alloy" for openai
  // voiceModel is often tied to provider/voiceId, can be added if needed

  systemPrompt String @default("You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.")
  firstMessage String @default("Hello! This is Laine from your dental office. How can I help you today?")

  // Potentially store other VAPI settings if customization is expanded
  // serverUrl for tool calls will be derived from NEXT_PUBLIC_APP_URL

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// For storing details about the global NexHealth webhook endpoint managed by the SaaS
model GlobalNexhealthWebhookEndpoint {
  id                  String   @id @default("singleton") // Ensures only one record
  nexhealthEndpointId String   @unique // The ID from NexHealth API after creating the endpoint
  secretKey           String // The secret key provided by NexHealth for this endpoint
  targetUrl           String // The URL registered with NexHealth (e.g., https://laine-integrated.vercel.app/api/nexhealth-webhook)
  isEnabled           Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

// For tracking which practices are subscribed to which NexHealth events
model NexhealthWebhookSubscription {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthWebhookEndpointId String // Foreign key to the global endpoint ID from NexHealth
  nexhealthSubscriptionId    String  @unique // The ID of this specific subscription from NexHealth API
  resourceType               String // e.g., "Appointment", "Patient"
  eventName                  String // e.g., "appointment_insertion.complete", "patient_created"
  isActive                   Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, resourceType, eventName]) // A practice should only have one active sub for a specific event
}

// For VAPI call logging, as per blueprint
model CallLog {
  id         String   @id @default(cuid()) // Or use vapi_call_id as PK if always present early
  vapiCallId String   @unique // From VAPI
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  callTimestampStart DateTime?
  callStatus         String? // e.g., INITIATED, IN_PROGRESS, FORWARDING, ENDED
  transcriptText     String?   @db.Text
  summary            String?   @db.Text // End of call report summary
  vapiTranscriptUrl  String? // URL to audio recording

  // Fields for tracking tool usage and outcomes within a call
  detectedIntent               String?
  nexhealthPatientId           String? // If patient identified/created
  bookedAppointmentNexhealthId String? // If appointment booked

  // Enhanced fields as per refactoring plan
  assistantId         String? // VAPI assistant ID
  endedReason         String? // From end-of-call-report
  callDurationSeconds Int? // Duration in seconds
  cost                Decimal? // Call cost if available

  toolLogs ToolLog[] // One-to-many relationship

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// New model for tracking individual tool executions
model ToolLog {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  vapiCallId String? // Optional - tools might be called outside of calls
  callLog    CallLog? @relation(fields: [vapiCallId], references: [vapiCallId], onDelete: Cascade)

  toolName        String // Name of the tool executed
  toolCallId      String // VAPI tool call ID
  arguments       String? @db.Text // JSON string of (redacted) arguments
  result          String? @db.Text // JSON string of result
  success         Boolean // Whether execution succeeded
  error           String? // Error message if failed
  executionTimeMs Int? // Execution time in milliseconds

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([practiceId, toolName])
  @@index([vapiCallId])
}

model AppointmentType {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthAppointmentTypeId String // ID from NexHealth
  name                       String
  duration                   Int // Duration in minutes (maps to NexHealth 'minutes')
  bookableOnline             Boolean? // Added field for online booking status
  groupCode                  String? // Optional group code for categorizing appointment types

  // Optional: Enhanced tracking fields
  parentType    String? // "Institution" or "Location"
  parentId      String? // ID of the parent
  lastSyncError String? // Error tracking for sync operations

  // Reverse relations for provider configuration
  defaultForProviders SavedProvider[]                   @relation("DefaultProviderAppointmentType")
  acceptedByProviders ProviderAcceptedAppointmentType[] @relation("ProviderAcceptedTypes")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthAppointmentTypeId])
}

model Provider {
  id         String   @id @default(cuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthProviderId String // ID from NexHealth
  firstName           String?
  lastName            String

  // Add new relationship
  savedByPractices SavedProvider[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthProviderId])
}

model NexhealthTokenCache {
  id          String   @id @default("singleton") // Fixed ID for single token entry
  accessToken String   @db.Text // The bearer token can be long
  expiresAt   DateTime // Timestamp when the token expires
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

================
File: app/practice-config/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@clerk/nextjs";
import { redirect } from "next/navigation";
import { Toaster, toast } from "sonner";
import { QuickReview } from "./QuickReview";
import { AppointmentTypesConfig } from "./AppointmentTypesConfig";
import { ProvidersConfig } from "./ProvidersConfig";
import { CheckAppointmentSlotsTool } from "./CheckAppointmentSlotsTool";

// Types for the simplified structure
interface Practice {
  id: string;
  name: string | null;
  nexhealthSubdomain: string | null;
  nexhealthLocationId: string | null;
  webhookLastSyncAt: string | null;
  address: string | null;
  acceptedInsurances: string | null;
  serviceCostEstimates: string | null;
  appointmentTypes: Array<{
    id: string;
    nexhealthAppointmentTypeId: string;
    name: string;
    duration: number;
    bookableOnline: boolean | null;
    groupCode: string | null;
    createdAt: string;
    updatedAt: string;
  }>;
  providers: Array<{
    id: string;
    nexhealthProviderId: string;
    firstName: string | null;
    lastName: string;
  }>;
  savedProviders: Array<{
    id: string;
    providerId: string;
    isActive: boolean;
    provider: {
      id: string;
      nexhealthProviderId: string;
      firstName: string | null;
      lastName: string;
    };
  }>;
  savedOperatories: Array<{
    id: string;
    nexhealthOperatoryId: string;
    name: string;
    isActive: boolean;
  }>;
}

interface WebhookStatus {
  lastSyncStatus: 'NEVER_SYNCED' | 'SYNCED' | 'SYNC_IN_PROGRESS' | 'ERROR';
  lastSyncAttemptAt: string | null;
  lastSyncErrorMessage: string | null;
  subscriptionCounts: {
    appointment: number;
    availability: number;
    patient: number;
    provider: number;
    location: number;
  };
}

export default function PracticeConfigPage() {
  const { userId, isLoaded } = useAuth();
  const [practice, setPractice] = useState<Practice | null>(null);
  const [webhookStatus, setWebhookStatus] = useState<WebhookStatus | null>(null);
  const [loading, setLoading] = useState(true);
  const [basicInfoLoading, setBasicInfoLoading] = useState(false);
  const [webhookLoading, setWebhookLoading] = useState(false);

  useEffect(() => {
    if (isLoaded && !userId) {
      redirect("/sign-in");
    }
  }, [isLoaded, userId]);

  useEffect(() => {
    if (isLoaded && userId) {
      fetchPracticeData();
      fetchWebhookStatus();
    }
  }, [isLoaded, userId]);

  const fetchPracticeData = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/practice-config/data');
      if (response.ok) {
        const data = await response.json();
        setPractice(data.practice);
      } else {
        console.error('Failed to fetch practice data');
      }
    } catch (error) {
      console.error('Error fetching practice data:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchWebhookStatus = async () => {
    try {
      setWebhookLoading(true);
      const response = await fetch('/api/practice-config/webhook-status');
      if (response.ok) {
        const data = await response.json();
        setWebhookStatus(data);
      } else {
        console.error('Failed to fetch webhook status');
      }
    } catch (error) {
      console.error('Error fetching webhook status:', error);
    } finally {
      setWebhookLoading(false);
    }
  };

  const handleBasicInfoSave = async (formData: FormData) => {
    setBasicInfoLoading(true);
    try {
      const response = await fetch('/api/practice-config/basic', {
        method: 'POST',
        body: formData
      });

      if (response.ok) {
        toast.success('Basic information saved successfully!');
        
        // Refresh data after save
        await fetchPracticeData();
        await fetchWebhookStatus();
      } else {
        const error = await response.json();
        toast.error(`Failed to save: ${error.error || 'Unknown error'}`);
      }
    } catch (error) {
      console.error('Error saving config:', error);
      toast.error('Failed to save configuration');
    } finally {
      setBasicInfoLoading(false);
    }
  };

  const refreshWebhookStatus = async () => {
    await fetchWebhookStatus();
  };

  const refreshPracticeData = async () => {
    await fetchPracticeData();
  };

  const getWebhookStatusIcon = (status: WebhookStatus['lastSyncStatus']) => {
    switch (status) {
      case 'SYNCED':
        return <div className="w-3 h-3 bg-green-500 rounded-full"></div>;
      case 'SYNC_IN_PROGRESS':
        return <div className="w-3 h-3 bg-blue-500 rounded-full animate-pulse"></div>;
      case 'ERROR':
        return <div className="w-3 h-3 bg-red-500 rounded-full"></div>;
      case 'NEVER_SYNCED':
        return <div className="w-3 h-3 bg-yellow-500 rounded-full"></div>;
      default:
        return <div className="w-3 h-3 bg-gray-400 rounded-full animate-pulse"></div>;
    }
  };

  const getWebhookStatusText = (status: WebhookStatus['lastSyncStatus']) => {
    switch (status) {
      case 'SYNCED':
        return 'Webhooks Synced';
      case 'SYNC_IN_PROGRESS':
        return 'Sync In Progress';
      case 'ERROR':
        return 'Webhook Error';
      case 'NEVER_SYNCED':
        return 'Never Synced';
      default:
        return 'Unknown Status';
    }
  };

  if (!isLoaded || loading) {
    return (
      <div className="max-w-6xl mx-auto p-6">
        <div className="text-center">Loading...</div>
      </div>
    );
  }

  if (!userId) {
    return null; // Will redirect
  }

  return (
    <>
      <Toaster position="top-right" />
      <div className="max-w-6xl mx-auto p-6">
        <h1 className="text-3xl font-bold mb-8">Practice Configuration</h1>
        
        {/* Basic Information Section */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <h2 className="text-xl font-semibold mb-4">Basic Information</h2>
          <form onSubmit={async (e) => {
            e.preventDefault();
            const formData = new FormData(e.currentTarget);
            await handleBasicInfoSave(formData);
          }} className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label htmlFor="practiceName" className="block text-sm font-medium text-gray-700 mb-1">
                  Practice Name (Optional)
                </label>
                <input
                  type="text"
                  id="practiceName"
                  name="practiceName"
                  defaultValue={practice?.name || ""}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="Enter your practice name"
                />
              </div>
              
              <div>
                <label htmlFor="nexhealthSubdomain" className="block text-sm font-medium text-gray-700 mb-1">
                  NexHealth Subdomain *
                </label>
                <input
                  type="text"
                  id="nexhealthSubdomain"
                  name="nexhealthSubdomain"
                  defaultValue={practice?.nexhealthSubdomain || ""}
                  required
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., testdental"
                />
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label htmlFor="nexhealthLocationId" className="block text-sm font-medium text-gray-700 mb-1">
                  NexHealth Location ID *
                </label>
                <input
                  type="text"
                  id="nexhealthLocationId"
                  name="nexhealthLocationId"
                  defaultValue={practice?.nexhealthLocationId || ""}
                  required
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., 123"
                />
              </div>

              <div>
                <label htmlFor="practiceAddress" className="block text-sm font-medium text-gray-700 mb-1">
                  Practice Address
                </label>
                <input
                  type="text"
                  id="practiceAddress"
                  name="practiceAddress"
                  defaultValue={practice?.address || ""}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  placeholder="e.g., 123 Dental St, Smileytown, CA 98765"
                />
              </div>
            </div>

            <div>
              <label htmlFor="acceptedInsurances" className="block text-sm font-medium text-gray-700 mb-1">
                Accepted Insurances (comma-separated)
              </label>
              <input
                type="text"
                id="acceptedInsurances"
                name="acceptedInsurances"
                defaultValue={practice?.acceptedInsurances || ""}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., Cigna, Delta Dental, MetLife"
              />
            </div>

            <div>
              <label htmlFor="serviceCostEstimates" className="block text-sm font-medium text-gray-700 mb-1">
                Service Cost Estimates (comma-separated &apos;Service: $Cost&apos;)
              </label>
              <input
                type="text"
                id="serviceCostEstimates"
                name="serviceCostEstimates"
                defaultValue={practice?.serviceCostEstimates || ""}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="e.g., Cleaning: $120, Exam: $80, X-Ray: $50"
              />
            </div>
            
            <div className="flex justify-between items-center">
              <button
                type="submit"
                disabled={basicInfoLoading}
                className="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {basicInfoLoading ? 'Saving...' : 'Save Basic Information'}
              </button>
            </div>
          </form>
        </div>

        {/* Webhook Status Section */}
        <div className="bg-white rounded-lg shadow p-6 mb-6">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold">Webhook Status</h2>
            <button
              onClick={refreshWebhookStatus}
              disabled={webhookLoading}
              className="text-blue-600 hover:text-blue-700 disabled:opacity-50 text-sm"
            >
              {webhookLoading ? 'Refreshing...' : 'Refresh'}
            </button>
          </div>
          
          {webhookStatus ? (
            <div className="space-y-4">
              <div className="flex items-center gap-3">
                {getWebhookStatusIcon(webhookStatus.lastSyncStatus)}
                <span className="font-medium">{getWebhookStatusText(webhookStatus.lastSyncStatus)}</span>
                {webhookStatus.lastSyncAttemptAt && (
                  <span className="text-sm text-gray-500">
                    Last sync: {new Date(webhookStatus.lastSyncAttemptAt).toLocaleString()}
                  </span>
                )}
              </div>
              
              {webhookStatus.lastSyncErrorMessage && (
                <div className="bg-red-50 border border-red-200 rounded-md p-3">
                  <p className="text-red-800 text-sm">{webhookStatus.lastSyncErrorMessage}</p>
                </div>
              )}
              
              <div className="grid grid-cols-2 md:grid-cols-5 gap-4 text-sm">
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.appointment}</div>
                  <div className="text-gray-600">Appointments</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.availability}</div>
                  <div className="text-gray-600">Availability</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.patient}</div>
                  <div className="text-gray-600">Patients</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.provider}</div>
                  <div className="text-gray-600">Providers</div>
                </div>
                <div className="text-center">
                  <div className="font-semibold text-lg">{webhookStatus.subscriptionCounts.location}</div>
                  <div className="text-gray-600">Locations</div>
                </div>
              </div>
            </div>
          ) : (
            <div className="text-gray-500">Loading webhook status...</div>
          )}
        </div>

        {practice?.nexhealthSubdomain && practice?.nexhealthLocationId && (
          <>
            {/* Quick Review Section */}
            <div className="mb-6">
              <QuickReview />
            </div>

            {/* Appointment Types Configuration Section */}
            <div className="mb-6">
              <AppointmentTypesConfig
                initialAppointmentTypes={practice.appointmentTypes}
                onUpdate={refreshPracticeData}
              />
            </div>

            {/* Providers Configuration Section */}
            <div className="mb-6">
              <ProvidersConfig
                savedProviders={practice.savedProviders}
                allProviders={practice.providers}
                allAppointmentTypes={practice.appointmentTypes}
                allOperatories={practice.savedOperatories}
                onUpdate={refreshPracticeData}
              />
            </div>

            {/* Check Appointment Slots Section */}
            <div className="mb-6">
              <CheckAppointmentSlotsTool
                appointmentTypes={practice.appointmentTypes}
                savedProviders={practice.savedProviders}
                savedOperatories={practice.savedOperatories}
              />
            </div>
          </>
        )}

        {(!practice?.nexhealthSubdomain || !practice?.nexhealthLocationId) && (
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
            <h3 className="text-lg font-semibold text-yellow-800 mb-2">Setup Required</h3>
            <p className="text-yellow-700">
              Please complete the basic information above (NexHealth Subdomain and Location ID) to access the full configuration options.
            </p>
          </div>
        )}
      </div>
    </>
  );
}

================
File: lib/tools/checkAvailableSlots.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Generate current date dynamically for LLM context
function getCurrentDate(): string {
  const today = new Date();
  return today.toISOString().split('T')[0]; // Returns YYYY-MM-DD
}

export const checkAvailableSlotsSchema = z.object({
  requestedDate: z.string()
    .min(1)
    .refine((date) => {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
        return false;
      }
      // Validate it's a real date
      const parsedDate = new Date(date);
      return !isNaN(parsedDate.getTime()) && date === parsedDate.toISOString().split('T')[0];
    }, "Date must be in YYYY-MM-DD format and be a valid date")
    .describe(`Patient's requested date in YYYY-MM-DD format. Today: ${getCurrentDate()}. Examples: "December 23rd" → "2025-12-23", "next Friday" → calculate from ${getCurrentDate()}, "tomorrow" → calculate from ${getCurrentDate()}`),
  appointmentTypeId: z.string().min(1).describe("Appointment type ID from previous find_appointment_type tool call"),
  days: z.number().min(1).max(7).default(1).describe("Number of days to check (default 1)")
});

const checkAvailableSlotsTool: ToolDefinition<typeof checkAvailableSlotsSchema> = {
  name: "check_available_slots",
  description: "Checks available appointment slots for a specific date and appointment type. Use after confirming patient identity and appointment type when patient requests a specific date.",
  schema: checkAvailableSlotsSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't check availability right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "The practice hasn't configured any providers for online scheduling. Please contact the office directly."
      };
    }

    try {
      // Get provider and operatory IDs from practice preferences
      const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
      const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

      if (activeProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "No providers are currently available for online scheduling. Please contact the office."
        };
      }

      // NEW LOGIC: Filter providers who accept this appointment type
      const appointmentType = practice.appointmentTypes?.find(
        at => at.nexhealthAppointmentTypeId === args.appointmentTypeId
      );

      if (!appointmentType) {
        return {
          success: false,
          error_code: "INVALID_APPOINTMENT_TYPE",
          message_to_patient: "I couldn't find that appointment type. Please contact the office for assistance."
        };
      }

      // Filter providers who accept this appointment type
      const eligibleProviders = activeProviders.filter(sp => {
        // If provider has no accepted appointment types configured, include them (backward compatibility)
        if (!sp.acceptedAppointmentTypes || sp.acceptedAppointmentTypes.length === 0) {
          return true;
        }
        // Otherwise, check if they accept this specific appointment type
        return sp.acceptedAppointmentTypes.some(
          relation => relation.appointmentType.id === appointmentType.id
        );
      });

      if (eligibleProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_PROVIDERS_FOR_TYPE",
          message_to_patient: `I don't see any providers available for ${appointmentType.name} appointments. Please contact the office for assistance.`
        };
      }

      // Get provider and operatory arrays from eligible providers
      const providers = eligibleProviders.map(sp => sp.provider.nexhealthProviderId);
      const operatories = activeOperatories.map(so => so.nexhealthOperatoryId);

      // Build search params object for NexHealth API
      const searchParams: Record<string, string | string[]> = {
        subdomain: practice.nexhealthSubdomain,
        start_date: args.requestedDate,
        days: args.days.toString(),
        appointment_type_id: args.appointmentTypeId,
        'lids[]': [practice.nexhealthLocationId],
        'pids[]': providers
      };

      // Add operatory IDs if configured
      if (operatories.length > 0) {
        searchParams['operatory_ids[]'] = operatories;
      }

      const slotsResponse = await fetchNexhealthAPI(
        '/appointment_slots',
        practice.nexhealthSubdomain,
        searchParams
      );

      // Parse response
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const availableSlots: any[] = [];
      
      if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
        // Extract all slots from all providers
        for (const providerData of slotsResponse.data) {
          if (providerData.slots && Array.isArray(providerData.slots)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            availableSlots.push(...providerData.slots.map((slot: any) => ({
              ...slot,
              provider_id: providerData.pid,
              location_id: providerData.lid
            })));
          }
        }
      }

      if (availableSlots.length === 0) {
        // No slots found - let's provide more helpful information
        const appointmentTypeName = practice.appointmentTypes?.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || "that appointment type";
        const friendlyDate = formatDate(args.requestedDate);
        
        let messageToPatient = `I'm sorry, I don't see any available slots for a ${appointmentTypeName} on ${friendlyDate}.`;

        const otherAppointmentTypesExist = (practice.appointmentTypes?.length || 0) > 1;

        if (otherAppointmentTypesExist) {
          messageToPatient += ` Would you like me to check a different date for the ${appointmentTypeName}, or perhaps look at other appointment types for that day?`;
        } else {
          messageToPatient += ` Would you like me to check for ${appointmentTypeName} on a different date?`;
        }

        return {
          success: true,
          message_to_patient: messageToPatient,
          data: {
            requested_date: args.requestedDate,
            requested_appointment_type_id: args.appointmentTypeId,
            appointment_type_name: appointmentTypeName, // Add for context
            available_slots: [],
            has_availability: false,
            debug_info: {
              providers_checked: providers.length,
              operatories_checked: operatories.length,
              appointment_type_name: appointmentTypeName
            }
          }
        };
      }

      // Format slots for patient-friendly display
      const formattedSlots = availableSlots.slice(0, 8).map((slot, index) => {
        // Parse the time string correctly to preserve the timezone
        const startTime = new Date(slot.time);
        
        // Use the timezone from the original date string for formatting
        const timeString = startTime.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
          timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
        });
        
        return {
          slot_id: `slot_${index}`,
          time: slot.time,
          end_time: slot.end_time,
          display_time: timeString,
          operatory_id: slot.operatory_id,
          provider_id: slot.provider_id,
          location_id: slot.location_id
        };
      });

      // Create more conversational message with appointment type and limited initial options
      const appointmentTypeName = practice.appointmentTypes?.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || "your appointment";
      const friendlyDate = formatDate(args.requestedDate);

      // Offer a limited number of slots initially for voice, e.g., 3 or 4
      const slotsToOfferCount = Math.min(formattedSlots.length, 3); // Offer up to 3 slots
      const offeredTimeList = formattedSlots.slice(0, slotsToOfferCount).map(slot => slot.display_time);
      
      let timeOptionsMessage = "";
      if (offeredTimeList.length === 1) {
        timeOptionsMessage = offeredTimeList[0];
      } else if (offeredTimeList.length > 1) {
        timeOptionsMessage = offeredTimeList.slice(0, -1).join(', ') + (offeredTimeList.length > 1 ? ', or ' : '') + offeredTimeList[offeredTimeList.length - 1];
      }

      let finalMessageToPatient = `Great! For a ${appointmentTypeName} on ${friendlyDate}, I have ${timeOptionsMessage} available.`;

      if (formattedSlots.length > slotsToOfferCount) {
        finalMessageToPatient += " Do any of those work, or would you like to hear more options?";
      } else {
        finalMessageToPatient += " Do any of those times work for you?";
      }

      return {
        success: true,
        message_to_patient: finalMessageToPatient,
        data: {
          requested_date: args.requestedDate,
          requested_appointment_type_id: args.appointmentTypeId,
          appointment_type_name: appointmentTypeName,
          available_slots: formattedSlots,
          has_availability: true,
          total_slots_found: availableSlots.length,
          slots_offered: slotsToOfferCount
        }
      };

    } catch (error) {
      console.error(`[checkAvailableSlots] Error:`, error);
      
      return {
        success: false,
        error_code: "SLOT_CHECK_ERROR",
        message_to_patient: "I'm having trouble checking availability right now. Please contact the office for scheduling assistance.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check what's available...",
    success: "Okay, availability check processed.",
    fail: "There was an issue checking availability."
  }
};

function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  });
}

export default checkAvailableSlotsTool;




================================================================
End of Codebase
================================================================
