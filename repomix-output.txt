This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: README.md, app/api/laine-config/recent-tool-logs/route.ts, app/api/laine-config/update/route.ts, app/api/practice-config/appointment-types/[appointmentTypeId]/route.ts, app/api/practice-config/appointment-types/route.ts, app/api/practice-config/availabilities/[availabilityId]/route.ts, app/api/practice-config/availabilities/route.ts, app/api/practice-config/basic/route.ts, app/api/practice-config/check-slots/route.ts, app/api/practice-config/data/route.ts, app/api/practice-config/fetch-operatories/route.ts, app/api/practice-config/operatories/route.ts, app/api/practice-config/providers/route.ts, app/api/vapi/tool-calls/route.ts, app/laine/laine-practice-client.tsx, app/laine/page.tsx, app/layout.tsx, docs/webhook-management.md, lib/nexhealth.ts, lib/prisma.ts, lib/tools/bookAppointment.ts, lib/tools/checkAvailableSlots.ts, lib/tools/checkInsuranceParticipation.ts, lib/tools/createNewPatient.ts, lib/tools/findAppointmentType.ts, lib/tools/findPatient.ts, lib/tools/getPracticeDetails.ts, lib/tools/getServiceCostEstimate.ts, lib/tools/index.ts, lib/tools/types.ts, lib/utils/error-messages.ts, lib/vapi.ts, middleware.ts, next.config.ts, prisma/schema.prisma, tsconfig.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    laine-config/
      recent-tool-logs/
        route.ts
      update/
        route.ts
    practice-config/
      appointment-types/
        [appointmentTypeId]/
          route.ts
        route.ts
      availabilities/
        [availabilityId]/
          route.ts
        route.ts
      basic/
        route.ts
      check-slots/
        route.ts
      data/
        route.ts
      fetch-operatories/
        route.ts
      operatories/
        route.ts
      providers/
        route.ts
    vapi/
      tool-calls/
        route.ts
  laine/
    laine-practice-client.tsx
    page.tsx
  layout.tsx
docs/
  webhook-management.md
lib/
  tools/
    bookAppointment.ts
    checkAvailableSlots.ts
    checkInsuranceParticipation.ts
    createNewPatient.ts
    findAppointmentType.ts
    findPatient.ts
    getPracticeDetails.ts
    getServiceCostEstimate.ts
    index.ts
    types.ts
  utils/
    error-messages.ts
  nexhealth.ts
  prisma.ts
  vapi.ts
prisma/
  schema.prisma
middleware.ts
next.config.ts
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: app/api/laine-config/recent-tool-logs/route.ts
================
import { NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Get the practice
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      select: { id: true }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Find the most recent vapiCallId that has tool logs for this practice
    const latestCallWithLogs = await prisma.toolLog.findFirst({
      where: { practiceId: practice.id },
      orderBy: { createdAt: 'desc' },
      select: { vapiCallId: true }
    });

    if (!latestCallWithLogs?.vapiCallId) {
      return NextResponse.json({ logs: [] });
    }

    // Fetch all logs for the most recent call with logs
    const recentLogs = await prisma.toolLog.findMany({
      where: {
        practiceId: practice.id,
        vapiCallId: latestCallWithLogs.vapiCallId
      },
      orderBy: { createdAt: 'asc' }, // Show tools in execution order for that call
      select: {
        id: true,
        toolName: true,
        arguments: true,
        result: true,
        success: true,
        error: true,
        executionTimeMs: true,
        createdAt: true,
        toolCallId: true
      }
    });

    // Transform the data to parse JSON strings and make it more client-friendly
    const transformedLogs = recentLogs.map(log => {
      let parsedArguments = null;
      let parsedResult = null;

      try {
        parsedArguments = log.arguments ? JSON.parse(log.arguments) : null;
      } catch (error) {
        console.warn(`Failed to parse arguments for tool log ${log.id}:`, error);
        parsedArguments = log.arguments;
      }

      try {
        parsedResult = log.result ? JSON.parse(log.result) : null;
      } catch (error) {
        console.warn(`Failed to parse result for tool log ${log.id}:`, error);
        parsedResult = log.result;
      }

      return {
        id: log.id,
        toolName: log.toolName,
        arguments: parsedArguments,
        result: parsedResult,
        success: log.success,
        error: log.error,
        executionTimeMs: log.executionTimeMs,
        createdAt: log.createdAt,
        toolCallId: log.toolCallId
      };
    });

    return NextResponse.json({ 
      logs: transformedLogs,
      callId: latestCallWithLogs.vapiCallId,
      totalLogs: transformedLogs.length
    });
  } catch (error) {
    console.error("Error fetching recent tool logs:", error);
    return NextResponse.json(
      { error: `Failed to fetch tool logs: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}

================
File: app/api/laine-config/update/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { prisma } from "@/lib/prisma";
import { updateVapiAssistant } from "@/lib/vapi";
import { buildVapiTools } from "@/lib/tools";

export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    const body = await request.json();
    const { voiceProvider, voiceId, systemPrompt, firstMessage } = body;

    if (!voiceProvider || !voiceId || !systemPrompt || !firstMessage) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    // Get the practice with assistant config
    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: { assistantConfig: true }
    });

    if (!practice || !practice.assistantConfig?.vapiAssistantId) {
      return NextResponse.json({ error: "Practice or assistant not found" }, { status: 404 });
    }

    const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    const tools = buildVapiTools(appBaseUrl);
    
    // Update VAPI assistant with new configuration
    const updateConfig = {
      model: {
        provider: "openai" as const,
        model: "gpt-4.1-nano-2025-04-14",
        temperature: 0.7,
        messages: [
          {
            role: "system" as const,
            content: systemPrompt
          }
        ],
        tools
      },
      voice: {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        provider: voiceProvider as any,
        voiceId: voiceId
      },
      firstMessage: firstMessage
    };

    console.log("Updating VAPI assistant:", practice.assistantConfig.vapiAssistantId);
    await updateVapiAssistant(practice.assistantConfig.vapiAssistantId, updateConfig);
    
    // Update our database
    await prisma.practiceAssistantConfig.update({
      where: { practiceId: practice.id },
      data: {
        voiceProvider,
        voiceId,
        systemPrompt,
        firstMessage,
        updatedAt: new Date()
      }
    });

    console.log(`Successfully updated VAPI assistant for practice ${practice.id}`);
    
    return NextResponse.json({ success: true, message: "Assistant configuration updated successfully" });
  } catch (error) {
    console.error("Error updating VAPI assistant:", error);
    return NextResponse.json(
      { error: `Failed to update assistant: ${error instanceof Error ? error.message : 'Unknown error'}` },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/appointment-types/[appointmentTypeId]/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { 
  updateNexhealthAppointmentType, 
  deleteNexhealthAppointmentType 
} from "@/lib/nexhealth";

interface RouteParams {
  appointmentTypeId: string;
}

export async function PUT(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { appointmentTypeId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to update appointment types"
      }, { status: 400 });
    }

    // Fetch the local appointment type record to get the NexHealth ID
    const localAppointmentType = await prisma.appointmentType.findFirst({
      where: {
        id: appointmentTypeId,
        practiceId: practice.id
      }
    });

    if (!localAppointmentType) {
      return NextResponse.json({
        error: "Appointment type not found"
      }, { status: 404 });
    }

    const { name, minutes, bookableOnline } = await req.json();

    // Build update data object with only provided fields
    const updateData: {
      name?: string;
      minutes?: number;
      bookable_online?: boolean;
    } = {};

    if (name !== undefined) {
      if (typeof name !== 'string' || name.trim().length === 0) {
        return NextResponse.json({
          error: "Name must be a non-empty string"
        }, { status: 400 });
      }
      updateData.name = name.trim();
    }

    if (minutes !== undefined) {
      if (typeof minutes !== 'number' || minutes <= 0) {
        return NextResponse.json({
          error: "Minutes must be a positive number"
        }, { status: 400 });
      }
      updateData.minutes = minutes;
    }

    if (bookableOnline !== undefined) {
      updateData.bookable_online = bookableOnline;
    }

    try {
      // Update appointment type in NexHealth
      const nexhealthResponse = await updateNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        localAppointmentType.nexhealthAppointmentTypeId,
        practice.nexhealthLocationId,
        updateData
      );

      // Update appointment type in local database
      const updatedLocalAppointmentType = await prisma.appointmentType.update({
        where: { id: appointmentTypeId },
        data: {
          name: nexhealthResponse.name,
          duration: nexhealthResponse.minutes,
          bookableOnline: nexhealthResponse.bookable_online,
          parentType: nexhealthResponse.parent_type,
          parentId: nexhealthResponse.parent_id.toString(),
          lastSyncError: null // Clear any previous errors
        }
      });

      return NextResponse.json({
        success: true,
        appointmentType: updatedLocalAppointmentType
      });

    } catch (nexhealthError) {
      console.error("Error updating appointment type in NexHealth:", nexhealthError);
      
      // Update local record with error
      await prisma.appointmentType.update({
        where: { id: appointmentTypeId },
        data: {
          lastSyncError: nexhealthError instanceof Error ? nexhealthError.message : 'Unknown NexHealth error'
        }
      });

      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to update appointment type in NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error updating appointment type:", error);
    return NextResponse.json(
      { error: "Failed to update appointment type" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: Promise<RouteParams> }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { appointmentTypeId } = await params;

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to delete appointment types"
      }, { status: 400 });
    }

    // Fetch the local appointment type record to get the NexHealth ID
    const localAppointmentType = await prisma.appointmentType.findFirst({
      where: {
        id: appointmentTypeId,
        practiceId: practice.id
      }
    });

    if (!localAppointmentType) {
      return NextResponse.json({
        error: "Appointment type not found"
      }, { status: 404 });
    }

    try {
      // Delete appointment type from NexHealth
      await deleteNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        localAppointmentType.nexhealthAppointmentTypeId,
        practice.nexhealthLocationId
      );

      // Delete appointment type from local database
      await prisma.appointmentType.delete({
        where: { id: appointmentTypeId }
      });

      return NextResponse.json({
        success: true,
        message: "Appointment type deleted successfully"
      });

    } catch (nexhealthError) {
      console.error("Error deleting appointment type from NexHealth:", nexhealthError);
      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to delete appointment type from NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error deleting appointment type:", error);
    return NextResponse.json(
      { error: "Failed to delete appointment type" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/appointment-types/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { 
  syncPracticeAppointmentTypes, 
  createNexhealthAppointmentType 
} from "@/lib/nexhealth";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: {
          orderBy: { name: 'asc' }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // If practice has NexHealth configuration, sync appointment types
    if (practice.nexhealthSubdomain && practice.nexhealthLocationId) {
      try {
        console.log(`Syncing appointment types for practice ${practice.id}...`);
        await syncPracticeAppointmentTypes(
          practice.id,
          practice.nexhealthSubdomain,
          practice.nexhealthLocationId
        );

        // Refetch appointment types after sync
        const updatedPractice = await prisma.practice.findUnique({
          where: { clerkUserId: userId },
          include: {
            appointmentTypes: {
              orderBy: { name: 'asc' }
            }
          }
        });

        return NextResponse.json({
          success: true,
          appointmentTypes: updatedPractice?.appointmentTypes || []
        });
      } catch (syncError) {
        console.error("Error syncing appointment types:", syncError);
        
        // Return existing appointment types even if sync failed
        return NextResponse.json({
          success: true,
          appointmentTypes: practice.appointmentTypes,
          syncError: syncError instanceof Error ? syncError.message : 'Unknown sync error'
        });
      }
    }

    // Return existing appointment types if no NexHealth config
    return NextResponse.json({
      success: true,
      appointmentTypes: practice.appointmentTypes
    });

  } catch (error) {
    console.error("Error fetching appointment types:", error);
    return NextResponse.json(
      { error: "Failed to fetch appointment types" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({
        error: "NexHealth configuration is required to create appointment types"
      }, { status: 400 });
    }

    const { name, minutes, bookableOnline } = await req.json();

    // Validate required fields
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return NextResponse.json({
        error: "Name is required and must be a non-empty string"
      }, { status: 400 });
    }

    if (!minutes || typeof minutes !== 'number' || minutes <= 0) {
      return NextResponse.json({
        error: "Minutes is required and must be a positive number"
      }, { status: 400 });
    }

    try {
      // Create appointment type in NexHealth
      const nexhealthResponse = await createNexhealthAppointmentType(
        practice.nexhealthSubdomain,
        practice.nexhealthLocationId,
        {
          name: name.trim(),
          minutes,
          bookable_online: bookableOnline ?? true,
          parent_type: "Location",
          parent_id: practice.nexhealthLocationId
        }
      );

      // Create appointment type in local database
      const localAppointmentType = await prisma.appointmentType.create({
        data: {
          practiceId: practice.id,
          nexhealthAppointmentTypeId: nexhealthResponse.id.toString(),
          name: nexhealthResponse.name,
          duration: nexhealthResponse.minutes,
          bookableOnline: nexhealthResponse.bookable_online,
          parentType: nexhealthResponse.parent_type,
          parentId: nexhealthResponse.parent_id.toString()
        }
      });

      return NextResponse.json({
        success: true,
        appointmentType: localAppointmentType
      });

    } catch (nexhealthError) {
      console.error("Error creating appointment type in NexHealth:", nexhealthError);
      return NextResponse.json({
        error: nexhealthError instanceof Error ? nexhealthError.message : 'Failed to create appointment type in NexHealth'
      }, { status: 400 });
    }

  } catch (error) {
    console.error("Error creating appointment type:", error);
    return NextResponse.json(
      { error: "Failed to create appointment type" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/availabilities/[availabilityId]/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { updateNexhealthAvailability, deleteNexhealthAvailability } from "@/lib/nexhealth";

export async function PUT(req: NextRequest, { params }: { params: Promise<{ availabilityId: string }> }) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    const { availabilityId } = await params;

    // Find the existing availability
    const existingAvailability = await prisma.manualAvailability.findFirst({
      where: {
        id: availabilityId,
        practiceId: practice.id
      },
      include: {
        provider: true,
        savedOperatory: true
      }
    });

    if (!existingAvailability) {
      return NextResponse.json({ error: "Availability not found" }, { status: 404 });
    }

    const {
      providerId,
      operatoryId,
      daysOfWeek,
      beginTime,
      endTime,
      appointmentTypeIds,
      isActive
    } = await req.json();

    // Validate input formats if provided
    if (daysOfWeek && (!Array.isArray(daysOfWeek) || daysOfWeek.length === 0)) {
      return NextResponse.json({ error: "daysOfWeek must be a non-empty array" }, { status: 400 });
    }

    if (appointmentTypeIds && (!Array.isArray(appointmentTypeIds) || appointmentTypeIds.length === 0)) {
      return NextResponse.json({ error: "appointmentTypeIds must be a non-empty array" }, { status: 400 });
    }

    // Validate time format if provided
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (beginTime && !timeRegex.test(beginTime)) {
      return NextResponse.json({ error: "Begin time format must be HH:MM" }, { status: 400 });
    }

    if (endTime && !timeRegex.test(endTime)) {
      return NextResponse.json({ error: "End time format must be HH:MM" }, { status: 400 });
    }

    // Validate end time is after begin time if both are provided
    if (beginTime && endTime) {
      const [beginHour, beginMin] = beginTime.split(':').map(Number);
      const [endHour, endMin] = endTime.split(':').map(Number);
      const beginMinutes = beginHour * 60 + beginMin;
      const endMinutes = endHour * 60 + endMin;

      if (endMinutes <= beginMinutes) {
        return NextResponse.json({ error: "End time must be after begin time" }, { status: 400 });
      }
    }

    // Validate provider if provided
    if (providerId) {
      const provider = await prisma.provider.findFirst({
        where: {
          id: providerId,
          practiceId: practice.id
        }
      });

      if (!provider) {
        return NextResponse.json({ error: "Provider not found or doesn't belong to practice" }, { status: 400 });
      }
    }

    // Validate operatory if provided
    let validatedOperatoryId = operatoryId;
    if (operatoryId !== undefined) {
      if (operatoryId) {
        const operatory = await prisma.savedOperatory.findFirst({
          where: {
            id: operatoryId,
            practiceId: practice.id,
            isActive: true
          }
        });

        if (!operatory) {
          return NextResponse.json({ error: "Operatory not found or not active" }, { status: 400 });
        }
      } else {
        validatedOperatoryId = null;
      }
    }

    // Validate appointment types if provided
    if (appointmentTypeIds) {
      const validAppointmentTypes = await prisma.appointmentType.findMany({
        where: {
          practiceId: practice.id,
          nexhealthAppointmentTypeId: { in: appointmentTypeIds }
        }
      });

      if (validAppointmentTypes.length !== appointmentTypeIds.length) {
        return NextResponse.json({ error: "Some appointment types don't belong to practice" }, { status: 400 });
      }
    }

    // Prepare update data (only include fields that were provided)
    const updateData: Record<string, string | string[] | boolean | null> = {};
    if (providerId !== undefined) updateData.providerId = providerId;
    if (validatedOperatoryId !== undefined) updateData.operatoryId = validatedOperatoryId;
    if (daysOfWeek !== undefined) updateData.daysOfWeek = daysOfWeek;
    if (beginTime !== undefined) updateData.beginTime = beginTime;
    if (endTime !== undefined) updateData.endTime = endTime;
    if (appointmentTypeIds !== undefined) updateData.appointmentTypeIds = appointmentTypeIds;
    if (isActive !== undefined) updateData.isActive = isActive;

    // Update the availability
    const updatedAvailability = await prisma.manualAvailability.update({
      where: { id: availabilityId },
      data: updateData,
      include: {
        provider: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            nexhealthProviderId: true
          }
        },
        savedOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        }
      }
    });

    // Update availability in NexHealth
    if (existingAvailability.nexhealthAvailabilityId) {
      try {
        await updateNexhealthAvailability(
          practice.nexhealthSubdomain!,
          existingAvailability.nexhealthAvailabilityId,
          {
            provider_id: Number(updatedAvailability.provider.nexhealthProviderId),
            operatory_id: updatedAvailability.savedOperatory?.nexhealthOperatoryId ? Number(updatedAvailability.savedOperatory.nexhealthOperatoryId) : undefined,
            days: updatedAvailability.daysOfWeek,
            begin_time: updatedAvailability.beginTime,
            end_time: updatedAvailability.endTime,
            appointment_type_ids: updatedAvailability.appointmentTypeIds.map(Number),
            active: updatedAvailability.isActive
          }
        );

        await prisma.manualAvailability.update({
          where: { id: availabilityId },
          data: {
            lastSyncWithNexhealthAt: new Date(),
            syncError: null
          }
        });
      } catch (error) {
        console.error("Failed to update availability in NexHealth:", error);
        await prisma.manualAvailability.update({
          where: { id: availabilityId },
          data: {
            syncError: error instanceof Error ? error.message : "Unknown error"
          }
        });
      }
    }

    return NextResponse.json({ 
      success: true, 
      availability: updatedAvailability 
    });

  } catch (error) {
    console.error("Error updating availability:", error);
    return NextResponse.json(
      { error: "Failed to update availability" },
      { status: 500 }
    );
  }
}

export async function DELETE(req: NextRequest, { params }: { params: Promise<{ availabilityId: string }> }) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    const { availabilityId } = await params;

    // Find the existing availability
    const existingAvailability = await prisma.manualAvailability.findFirst({
      where: {
        id: availabilityId,
        practiceId: practice.id
      }
    });

    if (!existingAvailability) {
      return NextResponse.json({ error: "Availability not found" }, { status: 404 });
    }

    // Delete availability from NexHealth first
    if (existingAvailability.nexhealthAvailabilityId) {
      try {
        await deleteNexhealthAvailability(
          practice.nexhealthSubdomain!,
          existingAvailability.nexhealthAvailabilityId
        );
      } catch (error) {
        console.error("Failed to delete availability from NexHealth:", error);
        // Continue with local deletion even if NexHealth deletion fails
      }
    }

    // Delete from local database
    await prisma.manualAvailability.delete({
      where: { id: availabilityId }
    });

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Error deleting availability:", error);
    return NextResponse.json(
      { error: "Failed to delete availability" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/availabilities/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { createNexhealthAvailability } from "@/lib/nexhealth";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    const availabilities = await prisma.manualAvailability.findMany({
      where: { practiceId: practice.id },
      include: {
        provider: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            nexhealthProviderId: true
          }
        },
        savedOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    // Map appointment type IDs to their names for easier display
    const appointmentTypes = await prisma.appointmentType.findMany({
      where: { practiceId: practice.id },
      select: {
        nexhealthAppointmentTypeId: true,
        name: true
      }
    });

    const appointmentTypeMap = new Map(
      appointmentTypes.map(type => [type.nexhealthAppointmentTypeId, type.name])
    );

    const availabilitiesWithTypeNames = availabilities.map(availability => ({
      ...availability,
      appointmentTypeNames: availability.appointmentTypeIds.map(typeId => 
        appointmentTypeMap.get(typeId) || `Unknown Type (${typeId})`
      )
    }));

    return NextResponse.json({ availabilities: availabilitiesWithTypeNames });

  } catch (error) {
    console.error("Error fetching availabilities:", error);
    return NextResponse.json(
      { error: "Failed to fetch availabilities" },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        savedOperatories: true
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    const {
      providerId,
      operatoryId,
      daysOfWeek,
      beginTime,
      endTime,
      appointmentTypeIds,
      isActive = true
    } = await req.json();

    // Validate required fields
    if (!providerId || !daysOfWeek || !beginTime || !endTime || !appointmentTypeIds) {
      return NextResponse.json({ 
        error: "Missing required fields: providerId, daysOfWeek, beginTime, endTime, appointmentTypeIds" 
      }, { status: 400 });
    }

    // Validate input formats
    if (!Array.isArray(daysOfWeek) || daysOfWeek.length === 0) {
      return NextResponse.json({ error: "daysOfWeek must be a non-empty array" }, { status: 400 });
    }

    if (!Array.isArray(appointmentTypeIds) || appointmentTypeIds.length === 0) {
      return NextResponse.json({ error: "appointmentTypeIds must be a non-empty array" }, { status: 400 });
    }

    // Validate time format (HH:MM)
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timeRegex.test(beginTime) || !timeRegex.test(endTime)) {
      return NextResponse.json({ error: "Time format must be HH:MM" }, { status: 400 });
    }

    // Validate end time is after begin time
    const [beginHour, beginMin] = beginTime.split(':').map(Number);
    const [endHour, endMin] = endTime.split(':').map(Number);
    const beginMinutes = beginHour * 60 + beginMin;
    const endMinutes = endHour * 60 + endMin;

    if (endMinutes <= beginMinutes) {
      return NextResponse.json({ error: "End time must be after begin time" }, { status: 400 });
    }

    // Validate provider exists and belongs to practice
    const provider = await prisma.provider.findFirst({
      where: {
        id: providerId,
        practiceId: practice.id
      }
    });

    if (!provider) {
      return NextResponse.json({ error: "Provider not found or doesn't belong to practice" }, { status: 400 });
    }

    // Validate operatory if provided
    let validatedOperatoryId = null;
    if (operatoryId) {
      const operatory = await prisma.savedOperatory.findFirst({
        where: {
          id: operatoryId,
          practiceId: practice.id,
          isActive: true
        }
      });

      if (!operatory) {
        return NextResponse.json({ error: "Operatory not found or not active" }, { status: 400 });
      }
      validatedOperatoryId = operatoryId;
    }

    // Validate appointment types belong to practice
    const validAppointmentTypes = await prisma.appointmentType.findMany({
      where: {
        practiceId: practice.id,
        nexhealthAppointmentTypeId: { in: appointmentTypeIds }
      }
    });

    if (validAppointmentTypes.length !== appointmentTypeIds.length) {
      return NextResponse.json({ error: "Some appointment types don't belong to practice" }, { status: 400 });
    }

    // Create the manual availability
    const availability = await prisma.manualAvailability.create({
      data: {
        practiceId: practice.id,
        providerId,
        operatoryId: validatedOperatoryId,
        daysOfWeek,
        beginTime,
        endTime,
        appointmentTypeIds,
        isActive
      },
      include: {
        provider: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            nexhealthProviderId: true
          }
        },
        savedOperatory: {
          select: {
            id: true,
            name: true,
            nexhealthOperatoryId: true
          }
        }
      }
    });

    // Create availability in NexHealth
    try {
      const nexhealthAvailability = await createNexhealthAvailability(
        practice.nexhealthSubdomain!,
        practice.nexhealthLocationId!,
        {
          provider_id: Number(provider.nexhealthProviderId),
          operatory_id: availability.savedOperatory?.nexhealthOperatoryId ? Number(availability.savedOperatory.nexhealthOperatoryId) : undefined,
          days: daysOfWeek,
          begin_time: beginTime,
          end_time: endTime,
          appointment_type_ids: appointmentTypeIds.map(Number),
          active: isActive
        }
      );

      // Update with NexHealth ID
      await prisma.manualAvailability.update({
        where: { id: availability.id },
        data: {
          nexhealthAvailabilityId: nexhealthAvailability.id.toString(),
          lastSyncWithNexhealthAt: new Date(),
          syncError: null
        }
      });
    } catch (error) {
      console.error("Failed to create availability in NexHealth:", error);
      await prisma.manualAvailability.update({
        where: { id: availability.id },
        data: {
          syncError: error instanceof Error ? error.message : "Unknown error"
        }
      });
    }

    return NextResponse.json({ 
      success: true, 
      availability 
    });

  } catch (error) {
    console.error("Error creating availability:", error);
    return NextResponse.json(
      { error: "Failed to create availability" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/fetch-operatories/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { getOperatories } from "@/lib/nexhealth";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { subdomain, locationId } = await req.json();

    if (!subdomain || !locationId) {
      return NextResponse.json({ error: "Subdomain and locationId required" }, { status: 400 });
    }

    const operatories = await getOperatories(subdomain, locationId);

    return NextResponse.json({ 
      success: true, 
      operatories 
    });

  } catch (error) {
    console.error("Error fetching operatories:", error);
    return NextResponse.json(
      { error: "Failed to fetch operatories" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/operatories/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { operatories, setAsDefault } = await req.json();

    if (!Array.isArray(operatories)) {
      return NextResponse.json({ error: "operatories must be an array" }, { status: 400 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Clear existing default if setting new default
    if (setAsDefault) {
      await prisma.savedOperatory.updateMany({
        where: { practiceId: practice.id },
        data: { isDefault: false }
      });
    }

    // Save selected operatories
    const savedOperatories = await Promise.all(
      operatories.map(async (operatory: { id: string; name: string }, index: number) => {
        return prisma.savedOperatory.upsert({
          where: {
            practiceId_nexhealthOperatoryId: {
              practiceId: practice.id,
              nexhealthOperatoryId: operatory.id
            }
          },
          update: {
            name: operatory.name,
            isActive: true,
            isDefault: setAsDefault && index === 0
          },
          create: {
            practiceId: practice.id,
            nexhealthOperatoryId: operatory.id,
            name: operatory.name,
            isActive: true,
            isDefault: setAsDefault && index === 0
          }
        });
      })
    );

    return NextResponse.json({ 
      success: true, 
      savedOperatories: savedOperatories.length 
    });

  } catch (error) {
    console.error("Error saving operatories:", error);
    return NextResponse.json(
      { error: "Failed to save operatories" },
      { status: 500 }
    );
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { operatoryIds } = await req.json();

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    await prisma.savedOperatory.deleteMany({
      where: {
        practiceId: practice.id,
        nexhealthOperatoryId: { in: operatoryIds }
      }
    });

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Error removing operatories:", error);
    return NextResponse.json(
      { error: "Failed to remove operatories" },
      { status: 500 }
    );
  }
}

================
File: app/laine/laine-practice-client.tsx
================
"use client";

import { useState, useEffect } from "react";
import { toast } from "sonner";

interface Practice {
  id: string;
  name: string | null;
  assistantConfig: {
    id: string;
    vapiAssistantId: string | null;
    voiceProvider: string;
    voiceId: string;
    systemPrompt: string;
    firstMessage: string;
  } | null;
}

interface ToolResult {
  message_to_patient?: string;
  error_code?: string;
  details?: string;
  success?: boolean;
  data?: Record<string, unknown>;
  [key: string]: unknown;
}

interface ToolLog {
  id: string;
  toolName: string;
  arguments: Record<string, unknown> | null;
  result: ToolResult | null;
  success: boolean;
  error: string | null;
  executionTimeMs: number | null;
  createdAt: string;
  toolCallId: string;
}

interface LainePracticeClientProps {
  practice: Practice;
  hasAssistant: boolean;
  createPracticeAssistant: () => Promise<void>;
}

export function LainePracticeClient({ practice, hasAssistant, createPracticeAssistant }: LainePracticeClientProps) {
  const [voiceProvider, setVoiceProvider] = useState(practice.assistantConfig?.voiceProvider || "vapi");
  const [voiceId, setVoiceId] = useState(practice.assistantConfig?.voiceId || "Elliot");
  const [systemPrompt, setSystemPrompt] = useState(practice.assistantConfig?.systemPrompt || "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.");
  const [firstMessage, setFirstMessage] = useState(practice.assistantConfig?.firstMessage || "Hello! This is Laine from your dental office. How can I help you today?");
  const [isUpdating, setIsUpdating] = useState(false);
  const [toolLogs, setToolLogs] = useState<ToolLog[]>([]);
  const [isLoadingLogs, setIsLoadingLogs] = useState(true);
  const [callId, setCallId] = useState<string | null>(null);

  useEffect(() => {
    const fetchLogs = async () => {
      setIsLoadingLogs(true);
      try {
        const response = await fetch('/api/laine-config/recent-tool-logs');
        if (response.ok) {
          const data = await response.json();
          setToolLogs(data.logs || []);
          setCallId(data.callId || null);
        } else {
          toast.error("Failed to fetch recent tool logs.");
        }
      } catch (error) {
        console.error("Error fetching tool logs:", error);
        toast.error("Error fetching tool logs.");
      } finally {
        setIsLoadingLogs(false);
      }
    };
    fetchLogs();
  }, []);

  const handleUpdateConfig = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsUpdating(true);

    try {
      const response = await fetch('/api/laine-config/update', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          voiceProvider,
          voiceId,
          systemPrompt,
          firstMessage,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update assistant configuration');
      }

      toast.success("Assistant configuration updated successfully!");
    } catch (error) {
      console.error('Error updating assistant configuration:', error);
      toast.error(`Failed to update assistant configuration. ${error instanceof Error ? error.message : 'Please try again.'}`);
    } finally {
      setIsUpdating(false);
    }
  };

  if (!hasAssistant) {
    return (
      <div className="bg-white rounded-lg shadow-md p-6">
        <h2 className="text-xl font-semibold mb-4">Create Your AI Assistant</h2>
        <p className="text-gray-600 mb-6">
          Create a personalized AI assistant for your practice. Laine will help patients with basic inquiries,
          patient lookups, and appointment scheduling.
        </p>
        
        <form action={createPracticeAssistant}>
          <button
            type="submit"
            className="bg-blue-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-blue-700 transition-colors"
          >
            Create Laine Assistant
          </button>
        </form>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-xl font-semibold mb-6">Configure Your AI Assistant</h2>
      
      <form onSubmit={handleUpdateConfig} className="space-y-6">
        <div>
          <label htmlFor="voiceProvider" className="block text-sm font-medium text-gray-700 mb-2">
            Voice Provider
          </label>
          <select
            id="voiceProvider"
            name="voiceProvider"
            value={voiceProvider}
            onChange={(e) => setVoiceProvider(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="vapi">VAPI (Recommended)</option>
            <option value="11labs">ElevenLabs</option>
            <option value="openai">OpenAI</option>
            <option value="playht">PlayHT</option>
          </select>
        </div>

        <div>
          <label htmlFor="voiceId" className="block text-sm font-medium text-gray-700 mb-2">
            Voice ID
          </label>
          <input
            type="text"
            id="voiceId"
            name="voiceId"
            value={voiceId}
            onChange={(e) => setVoiceId(e.target.value)}
            placeholder="e.g., Elliot, Kylie (VAPI), burt (ElevenLabs), alloy (OpenAI)"
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <p className="text-sm text-gray-500 mt-1">
            <strong>VAPI:</strong> Elliot, Kylie &nbsp;|&nbsp; 
            <strong>ElevenLabs:</strong> burt &nbsp;|&nbsp; 
            <strong>OpenAI:</strong> alloy, echo, fable, onyx, nova, shimmer
          </p>
        </div>

        <div>
          <label htmlFor="systemPrompt" className="block text-sm font-medium text-gray-700 mb-2">
            System Prompt
          </label>
          <textarea
            id="systemPrompt"
            name="systemPrompt"
            rows={4}
            value={systemPrompt}
            onChange={(e) => setSystemPrompt(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Instructions that define how the AI should behave..."
          />
          <p className="text-sm text-gray-500 mt-1">
            Define how Laine should behave and what it should know about your practice
          </p>
        </div>

        <div>
          <label htmlFor="firstMessage" className="block text-sm font-medium text-gray-700 mb-2">
            First Message
          </label>
          <input
            type="text"
            id="firstMessage"
            name="firstMessage"
            value={firstMessage}
            onChange={(e) => setFirstMessage(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Hello! This is Laine from your dental office..."
          />
          <p className="text-sm text-gray-500 mt-1">
            The first thing Laine says when answering a call
          </p>
        </div>

        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-500">
            Assistant ID: {practice.assistantConfig?.vapiAssistantId}
          </div>
          <button
            type="submit"
            disabled={isUpdating}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg font-medium hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isUpdating ? 'Updating...' : 'Update Configuration'}
          </button>
        </div>
      </form>

      <div className="mt-8 p-4 bg-gray-50 rounded-lg">
        <h3 className="font-medium text-gray-900 mb-2">Available Tools (8)</h3>
        <ul className="text-sm text-gray-600 space-y-1 list-disc list-inside">
          <li>find_patient_in_ehr - Searches for existing patients.</li>
          <li>create_new_patient - Creates new patient records (now with optional insurance name).</li>
          <li>find_appointment_type - Matches patient requests to appointment types.</li>
          <li>check_available_slots - Finds available appointment times.</li>
          <li>book_appointment - Books the selected appointment.</li>
          <li>check_insurance_participation - Checks if practice accepts patient&apos;s insurance.</li>
          <li>get_service_cost_estimate - Provides estimated service costs.</li>
          <li>get_practice_details - Retrieves practice address and other details.</li>
        </ul>
      </div>

      {/* Recent Tool Call Activity Section */}
      <div className="mt-8 p-4 bg-blue-50 rounded-lg">
        <h3 className="font-medium text-gray-900 mb-4">Recent Tool Call Activity</h3>
        {isLoadingLogs && (
          <p className="text-sm text-gray-600">Loading recent activity...</p>
        )}
        {!isLoadingLogs && toolLogs.length === 0 && (
          <p className="text-sm text-gray-600">No recent tool call activity found.</p>
        )}
        {!isLoadingLogs && toolLogs.length > 0 && (
          <div className="space-y-4">
            {callId && (
              <p className="text-xs text-gray-500 mb-3">
                Call ID: {callId}  {toolLogs.length} tool{toolLogs.length !== 1 ? 's' : ''} executed
              </p>
            )}
            {toolLogs.map((log) => (
              <div key={log.id} className="p-3 bg-white rounded border border-gray-200">
                <div className="flex justify-between items-start mb-2">
                  <h4 className="font-semibold text-sm text-gray-900">{log.toolName}</h4>
                  <div className="flex items-center space-x-2 text-xs text-gray-500">
                    <span className={`px-2 py-1 rounded ${log.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                      {log.success ? 'Success' : 'Failed'}
                    </span>
                    <span>{new Date(log.createdAt).toLocaleTimeString()}</span>
                    {log.executionTimeMs && <span>{log.executionTimeMs}ms</span>}
                  </div>
                </div>
                
                {/* Arguments */}
                {log.arguments && (
                  <div className="mb-2">
                    <p className="text-xs font-medium text-gray-700 mb-1">Arguments:</p>
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(log.arguments, null, 2)}
                    </pre>
                  </div>
                )}

                {/* Result */}
                {log.result && (
                  <div className="mb-2">
                    <p className="text-xs font-medium text-gray-700 mb-1">Result:</p>
                    {log.result?.message_to_patient && (
                      <p className="text-sm italic text-blue-600 mb-1">
                        To Patient: &quot;{log.result.message_to_patient}&quot;
                      </p>
                    )}
                    {log.result?.error_code && (
                      <p className="text-sm text-red-600 mb-1">
                        Error: {log.result.error_code} - {log.result.details || 'No details'}
                      </p>
                    )}
                    <pre className="text-xs bg-gray-100 p-2 rounded overflow-x-auto">
                      {JSON.stringify(log.result, null, 2)}
                    </pre>
                  </div>
                )}

                {/* Error (if failed) */}
                {log.error && (
                  <div className="text-xs text-red-600 bg-red-50 p-2 rounded">
                    <strong>Error:</strong> {log.error}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: docs/webhook-management.md
================
# NexHealth Webhook Management

This document explains how to manage NexHealth webhook endpoints and subscriptions for the Laine AI Voice Assistant SaaS platform.

## Overview

The webhook management system consists of:
- **Global Webhook Endpoint**: A single endpoint on NexHealth that receives events for all practices
- **Practice Subscriptions**: Individual subscriptions linking practices to specific events
- **Management Script**: CLI tool for setting up and managing webhooks programmatically

## Prerequisites

1. **Environment Variables** (in `.env`):
   ```bash
   NEXHEALTH_API_KEY=your_master_api_key_here
   NEXT_PUBLIC_APP_URL=https://your-app-domain.com
   DATABASE_URL=your_postgresql_connection_string
   ```

2. **Master API Key**: You need the NexHealth master API key (not a practice-specific bearer token) to manage webhook endpoints.

## Quick Start

### 1. Setup Global Webhook Endpoint

First, create the global webhook endpoint that will receive events for all practices:

```bash
# Using npm script (recommended)
pnpm webhook:setup

# Or directly
node scripts/manage-nexhealth-webhooks.js setup-global-endpoint
```

This command:
-  Checks if endpoint already exists in database
-  Creates new endpoint on NexHealth if needed
-  Stores endpoint ID and secret key in database
-  Handles URL changes and endpoint updates
-  Is idempotent (safe to run multiple times)

**Output:**
```
 Setting up Global NexHealth Webhook Endpoint...
 Successfully created and stored Global Webhook Endpoint:
   NexHealth Endpoint ID: 12345
   Target URL: https://your-app.vercel.app/api/nexhealth-webhook
   Secret Key: wh_secret_xyz... (stored securely in database)
```

### 2. Subscribe a Practice to Events

After setting up the global endpoint, subscribe individual practices:

```bash
# Using npm script (recommended)
pnpm webhook:subscribe dentistoffice

# Or directly
node scripts/manage-nexhealth-webhooks.js subscribe-practice dentistoffice
```

This command:
-  Looks up practice by subdomain in your database
-  Subscribes to predefined events (patient_created, appointment_insertion.complete, etc.)
-  Stores subscription details in database
-  Skips already-subscribed events
-  Continues on individual event failures

**Output:**
```
 Subscribing practice "dentistoffice" to NexHealth events...
    Successfully subscribed to Patient.patient_created. NexHealth Subscription ID: 67890
    Successfully subscribed to Appointment.appointment_insertion.complete. NexHealth Subscription ID: 67891
    Practice "dentistoffice" already subscribed to Appointment.appointment_insertion.failed (ID: 67892).
 Practice "dentistoffice" event subscriptions processed.
    Successfully subscribed: 2
    Already subscribed: 1
    Failed: 0
```

### 3. List Active Subscriptions

View all webhook subscriptions or filter by practice:

```bash
# List all subscriptions
pnpm webhook:list

# List subscriptions for specific practice
pnpm webhook:list dentistoffice

# Or directly
node scripts/manage-nexhealth-webhooks.js list-subscriptions
node scripts/manage-nexhealth-webhooks.js list-subscriptions dentistoffice
```

**Output:**
```
 Listing NexHealth webhook subscriptions...
 Found 3 subscription(s):

 Practice: dentistoffice
    Active | Patient.patient_created | NexHealth ID: 67890
    Active | Appointment.appointment_insertion.complete | NexHealth ID: 67891
    Active | Appointment.appointment_insertion.failed | NexHealth ID: 67892
```

## Commands Reference

### setup-global-endpoint
Creates and configures the global webhook endpoint for your SaaS platform.

```bash
node scripts/manage-nexhealth-webhooks.js setup-global-endpoint
```

**What it does:**
1. Checks database for existing endpoint configuration
2. Validates target URL matches current `NEXT_PUBLIC_APP_URL`
3. Queries NexHealth for conflicting endpoints
4. Creates new endpoint on NexHealth
5. Stores endpoint ID and secret in `GlobalNexhealthWebhookEndpoint` table

**Idempotency:** Safe to run multiple times. Will skip if already configured correctly.

### subscribe-practice <subdomain>
Subscribes a practice to NexHealth webhook events.

```bash
node scripts/manage-nexhealth-webhooks.js subscribe-practice <subdomain>
```

**Parameters:**
- `<subdomain>`: The NexHealth subdomain for the practice (must exist in your database)

**Subscribed Events:**
- `Patient.patient_created` - New patients added to the practice
- `Patient.patient_updated` - Patient information changes (contact details, demographics, etc.)
- `Appointment.appointment_created` - New appointments detected in EHR (made outside Laine)
- `Appointment.appointment_updated` - Appointment changes (rescheduling, cancellations, modifications)
- `Appointment.appointment_insertion.complete` - New appointments scheduled successfully by Laine
- `Appointment.appointment_insertion.failed` - Failed appointment scheduling attempts by Laine
- `SyncStatus.sync_status_read_change` - EHR read functionality status changes (monitoring)
- `SyncStatus.sync_status_write_change` - EHR write functionality status changes (monitoring)

**What it does:**
1. Validates practice exists in your database
2. Retrieves global endpoint ID from database
3. Creates subscriptions for each event type on NexHealth
4. Stores subscription details in `NexhealthWebhookSubscription` table

### list-subscriptions [subdomain]
Lists all webhook subscriptions, optionally filtered by practice.

```bash
node scripts/manage-nexhealth-webhooks.js list-subscriptions [subdomain]
```

**Parameters:**
- `[subdomain]`: Optional. Filter results to specific practice

## Database Integration

The script integrates with your Prisma database using these models:

### GlobalNexhealthWebhookEndpoint
Stores the global webhook endpoint configuration:
```prisma
model GlobalNexhealthWebhookEndpoint {
  id                  String    @id @default("singleton")
  nexhealthEndpointId String    @unique // NexHealth endpoint ID
  secretKey           String    // Webhook verification secret
  targetUrl           String    // Your webhook handler URL
  isEnabled           Boolean   @default(true)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
}
```

### NexhealthWebhookSubscription
Tracks practice-specific event subscriptions:
```prisma
model NexhealthWebhookSubscription {
  id                          String   @id @default(cuid())
  practiceId                  String
  nexhealthWebhookEndpointId  String   // References global endpoint
  nexhealthSubscriptionId     String   @unique // NexHealth subscription ID
  resourceType                String   // "Patient", "Appointment", etc.
  eventName                   String   // "patient_created", etc.
  isActive                    Boolean  @default(true)
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
}
```

## Webhook Handler Integration

Your webhook handler at `/api/nexhealth-webhook` automatically:
-  Retrieves secret key from database for signature verification
-  Identifies practice by subdomain from webhook payload
-  Processes events according to your business logic
-  Returns appropriate HTTP responses to NexHealth

## Troubleshooting

### "Practice not found" Error
**Problem:** ` Practice with subdomain "xyz" not found in your database.`

**Solution:** Ensure the practice has been configured in your application first through the practice configuration flow.

### "Global webhook endpoint not configured" Error
**Problem:** ` Global webhook endpoint not configured in DB. Run "setup-global-endpoint" first.`

**Solution:** Run the setup command:
```bash
pnpm webhook:setup
```

### "NEXHEALTH_API_KEY not found" Error
**Problem:** ` NEXHEALTH_API_KEY (master key) not found in environment variables.`

**Solution:** Add your NexHealth master API key to `.env`:
```bash
NEXHEALTH_API_KEY=your_master_api_key_here
```

### "Invalid signature" in Webhook Handler
**Problem:** Webhook requests are being rejected with signature verification errors.

**Solution:** 
1. Verify the secret key in database matches what NexHealth has
2. Run `webhook:setup` to refresh the endpoint and secret
3. Check that `NEXT_PUBLIC_APP_URL` is set correctly

## Security Considerations

1. **Master API Key**: Keep your `NEXHEALTH_API_KEY` secure. It has full access to your NexHealth account.

2. **Secret Storage**: Webhook secrets are stored in your database, not environment variables, for better security and rotation capability.

3. **Signature Verification**: All webhook requests are cryptographically verified using HMAC-SHA256.

4. **HTTPS Only**: Webhook endpoints must use HTTPS in production.

## Production Deployment

1. **Set Environment Variables:**
   ```bash
   NEXHEALTH_API_KEY=your_production_master_key
   NEXT_PUBLIC_APP_URL=https://your-production-domain.com
   DATABASE_URL=your_production_postgresql_url
   ```

2. **Setup Global Endpoint:**
   ```bash
   pnpm webhook:setup
   ```

3. **Subscribe Practices:**
   ```bash
   # For each practice
   pnpm webhook:subscribe practice-subdomain-1
   pnpm webhook:subscribe practice-subdomain-2
   # etc.
   ```

4. **Verify Setup:**
   ```bash
   pnpm webhook:list
   ```

## Development vs Production

- **Development**: Use `http://localhost:3000` for `NEXT_PUBLIC_APP_URL`
- **Production**: Use your actual domain (e.g., `https://laine-integrated.vercel.app`)
- **Testing**: Use a separate NexHealth sandbox account if available

The script automatically handles URL changes when you redeploy or change domains.

================
File: lib/prisma.ts
================
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

================
File: middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isProtectedRoute = createRouteMatcher([
  '/practice-config(.*)',
  // Add '/laine(.*)' for future phase
]);

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) {
    await auth.protect();
  }
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: app/api/practice-config/data/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({ 
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: true,
        providers: true,
        savedProviders: {
          include: {
            provider: true
          },
          where: { isActive: true }
        },
        savedOperatories: {
          where: { isActive: true }
        },
        manualAvailabilities: {
          include: {
            provider: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                nexhealthProviderId: true
              }
            },
            savedOperatory: {
              select: {
                id: true,
                name: true,
                nexhealthOperatoryId: true
              }
            }
          },
          orderBy: { createdAt: 'desc' }
        },
        nexhealthWebhookSubscriptions: {
          where: { isActive: true },
          orderBy: [
            { resourceType: 'asc' },
            { eventName: 'asc' }
          ]
        }
      }
    });

    // Check if global webhook endpoint is configured
    const globalWebhookEndpoint = await prisma.globalNexhealthWebhookEndpoint.findUnique({
      where: { id: "singleton" }
    });

    return NextResponse.json({
      practice,
      globalWebhookEndpoint
    });

  } catch (error) {
    console.error("Error fetching practice data:", error);
    return NextResponse.json(
      { error: "Failed to fetch practice data" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/providers/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { providerIds, setAsDefault } = await req.json();

    if (!Array.isArray(providerIds)) {
      return NextResponse.json({ error: "providerIds must be an array" }, { status: 400 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    // Clear existing default if setting new default
    if (setAsDefault) {
      await prisma.savedProvider.updateMany({
        where: { practiceId: practice.id },
        data: { isDefault: false }
      });
    }

    // First, deactivate all existing saved providers for this practice
    await prisma.savedProvider.updateMany({
      where: { practiceId: practice.id },
      data: { isActive: false }
    });

    // Save selected providers
    const savedProviders = await Promise.all(
      providerIds.map(async (providerId: string, index: number) => {
        return prisma.savedProvider.upsert({
          where: {
            practiceId_providerId: {
              practiceId: practice.id,
              providerId
            }
          },
          update: {
            isActive: true,
            isDefault: setAsDefault && index === 0
          },
          create: {
            practiceId: practice.id,
            providerId,
            isActive: true,
            isDefault: setAsDefault && index === 0
          }
        });
      })
    );

    return NextResponse.json({ 
      success: true, 
      savedProviders: savedProviders.length 
    });

  } catch (error) {
    console.error("Error saving providers:", error);
    return NextResponse.json(
      { error: "Failed to save providers" },
      { status: 500 }
    );
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { providerIds } = await req.json();

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    await prisma.savedProvider.deleteMany({
      where: {
        practiceId: practice.id,
        providerId: { in: providerIds }
      }
    });

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Error removing providers:", error);
    return NextResponse.json(
      { error: "Failed to remove providers" },
      { status: 500 }
    );
  }
}

================
File: lib/tools/checkInsuranceParticipation.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const checkInsuranceParticipationSchema = z.object({
  insuranceProviderName: z.string().min(1)
    .describe("The name of the dental insurance provider the patient mentioned (e.g., 'Cigna', 'Healthplex', 'Renaissance'). Extract the primary name of the insurer.")
});

const checkInsuranceParticipationTool: ToolDefinition<typeof checkInsuranceParticipationSchema> = {
  name: "check_insurance_participation",
  description: "Checks if the dental practice is in-network or out-of-network with a patient's stated dental insurance provider. Use this after the patient mentions their insurance company.",
  schema: checkInsuranceParticipationSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    try {
      // Check if practice has accepted insurances configured
      if (!practice.acceptedInsurances || practice.acceptedInsurances.trim() === '') {
        return {
          success: true, // Tool ran, but no configuration data available
          error_code: "INSURANCE_CONFIG_MISSING",
          message_to_patient: `This practice hasn't specified which insurances they accept in my system. It would be best to confirm directly with the office staff regarding your ${args.insuranceProviderName} plan. Would you like to proceed with scheduling for now, and we can clarify the insurance later?`,
          data: { 
            insuranceProviderName: args.insuranceProviderName,
            participation: "unknown_configuration",
            practiceAcceptedList: null
          }
        };
      }

      // Parse the accepted insurances string into an array
      const acceptedProviderNames = practice.acceptedInsurances
        .split(',')
        .map(name => name.trim().toLowerCase())
        .filter(name => name.length > 0);

      // Normalize the insurance provider name from args
      const normalizedInsuranceProviderName = args.insuranceProviderName.trim().toLowerCase();

      // Check for matches using includes for partial matching
      const isInNetwork = acceptedProviderNames.some(acceptedName => 
        acceptedName.includes(normalizedInsuranceProviderName) || 
        normalizedInsuranceProviderName.includes(acceptedName)
      );

      if (isInNetwork) {
        return {
          success: true,
          message_to_patient: `Great news! We are in-network with ${args.insuranceProviderName}. We can proceed with scheduling if you're ready. What type of appointment were you thinking of?`,
          data: {
            insuranceProviderName: args.insuranceProviderName,
            participation: "in-network",
            practiceAcceptedList: practice.acceptedInsurances
          }
        };
      } else {
        return {
          success: true,
          message_to_patient: `Based on the information I have, we might be out-of-network with ${args.insuranceProviderName}. You are still welcome to be seen here, but you would be responsible for the cost of the visit out-of-pocket. Would you like an estimate for the service you're considering, or would you like to discuss scheduling options?`,
          data: {
            insuranceProviderName: args.insuranceProviderName,
            participation: "out-of-network",
            practiceAcceptedList: practice.acceptedInsurances
          }
        };
      }

    } catch (error) {
      console.error(`[checkInsuranceParticipation] Error:`, error);
      
      return {
        success: false,
        error_code: "EXECUTION_ERROR",
        message_to_patient: "I had a little trouble checking the insurance. Please contact the office to verify your insurance coverage.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check that insurance for you...",
    success: "I've checked that insurance information.",
    fail: "I had a little trouble checking the insurance. Please bear with me."
  }
};

export default checkInsuranceParticipationTool;

================
File: lib/tools/getPracticeDetails.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const getPracticeDetailsSchema = z.object({});

const getPracticeDetailsTool: ToolDefinition<typeof getPracticeDetailsSchema> = {
  name: "get_practice_details",
  description: "Retrieves specific logistical details about the dental practice, such as its full address. Use this typically towards the end of a call when providing confirmation and directions, or if a patient asks specifically for the practice's address or location information.",
  schema: getPracticeDetailsSchema,
  
  async run({ context }): Promise<ToolResult> {
    const { practice } = context;
    
    try {
      // Check if practice address exists and is not empty
      if (!practice.address || practice.address.trim() === '') {
        return {
          success: false,
          error_code: "PRACTICE_DETAIL_MISSING",
          message_to_patient: "I don't have the specific address details readily available in my system right now. However, our office team can certainly provide that to you. Were you looking to schedule an appointment?",
          details: "Practice address is not configured."
        };
      }

      return {
        success: true,
        message_to_patient: `Our practice is located at ${practice.address}. Is there anything else about our location you'd like to know?`,
        data: { 
          address: practice.address 
        }
      };

    } catch (error) {
      console.error(`[getPracticeDetails] Error:`, error);
      
      return {
        success: false,
        error_code: "EXECUTION_ERROR",
        message_to_patient: "I couldn't retrieve the practice details at the moment. Please contact the office for location information.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me get those practice details for you...",
    success: "Here are the details about our practice.",
    fail: "I couldn't retrieve the practice details at the moment."
  }
};

export default getPracticeDetailsTool;

================
File: lib/tools/getServiceCostEstimate.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const getServiceCostEstimateSchema = z.object({
  serviceName: z.string().min(1)
    .describe("The name of the dental service the patient is asking about (e.g., 'limited exam and x-rays', 'cleaning', 'new patient special'). Try to match this to common service names or what the patient explicitly states.")
});

const getServiceCostEstimateTool: ToolDefinition<typeof getServiceCostEstimateSchema> = {
  name: "get_service_cost_estimate",
  description: "Provides an estimated cost for specified dental services, particularly for out-of-network or self-pay patients. Use this when a patient asks about the cost of a visit or service (e.g., 'How much would that be?').",
  schema: getServiceCostEstimateSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    try {
      // Check if practice has service cost estimates configured
      if (!practice.serviceCostEstimates || practice.serviceCostEstimates.trim() === '') {
        return {
          success: true, // Tool ran, but no configuration data available
          error_code: "COST_CONFIG_MISSING",
          message_to_patient: "I don't have specific cost information on file in my system. The office staff can provide you with an estimate. Would you like to schedule an appointment, and they can discuss costs with you?",
          data: { 
            serviceName: args.serviceName,
            found: false,
            estimate: null
          }
        };
      }

      // Parse the service cost estimates string (e.g., "Cleaning: $120, Exam and X-rays: $80, New Patient Special: $129")
      const serviceCosts: Array<{ service: string; cost: string }> = [];
      
      const entries = practice.serviceCostEstimates.split(',').map(entry => entry.trim());
      
      for (const entry of entries) {
        if (entry.includes(':')) {
          const [servicePart, costPart] = entry.split(':', 2);
          const service = servicePart?.trim();
          const cost = costPart?.trim();
          
          if (service && cost) {
            serviceCosts.push({ service, cost });
          }
        }
      }

      if (serviceCosts.length === 0) {
        return {
          success: true,
          error_code: "COST_CONFIG_INVALID",
          message_to_patient: "I'm having trouble reading the cost information in my system. The office staff can provide you with accurate pricing.",
          data: { 
            serviceName: args.serviceName,
            found: false,
            estimate: null
          }
        };
      }

      // Normalize the service name from args for matching
      const normalizedServiceName = args.serviceName.trim().toLowerCase();

      // Try to find a matching service
      const matchedService = serviceCosts.find(serviceItem => 
        serviceItem.service.toLowerCase().includes(normalizedServiceName) ||
        normalizedServiceName.includes(serviceItem.service.toLowerCase())
      );

      if (matchedService) {
        return {
          success: true,
          message_to_patient: `For a ${matchedService.service}, the estimated cost is ${matchedService.cost}. Does that sound okay, or would you like to discuss scheduling?`,
          data: {
            serviceName: args.serviceName,
            estimate: matchedService.cost,
            found: true,
            matchedKey: matchedService.service
          }
        };
      }

      // Check for "New Patient Special" or similar as a fallback for general inquiries
      const specialOffer = serviceCosts.find(serviceItem => 
        serviceItem.service.toLowerCase().includes('special') ||
        serviceItem.service.toLowerCase().includes('new patient')
      );

      if (specialOffer && (
        normalizedServiceName.includes('new') || 
        normalizedServiceName.includes('first') || 
        normalizedServiceName.includes('visit') ||
        normalizedServiceName.includes('appointment')
      )) {
        return {
          success: true,
          message_to_patient: `While I don't have a specific estimate for ${args.serviceName}, we do have a ${specialOffer.service} for ${specialOffer.cost} which typically covers an initial exam and necessary x-rays. Would that be something you're interested in, or would you prefer I check for other options?`,
          data: {
            serviceName: args.serviceName,
            estimate: specialOffer.cost,
            found: true,
            type: "special_offer",
            matchedKey: specialOffer.service
          }
        };
      }

      // No match found
      return {
        success: true,
        message_to_patient: `I couldn't find a specific cost estimate for ${args.serviceName} in my system. Our team at the office can provide you with more detailed pricing information. Would you like to proceed with scheduling an appointment, and they can discuss costs with you then?`,
        data: {
          serviceName: args.serviceName,
          found: false,
          estimate: null
        }
      };

    } catch (error) {
      console.error(`[getServiceCostEstimate] Error:`, error);
      
      return {
        success: false,
        error_code: "EXECUTION_ERROR",
        message_to_patient: "I'm unable to retrieve cost estimates right now. Please contact the office for pricing information.",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check on that cost estimate for you...",
    success: "I have some information on the cost.",
    fail: "I'm unable to retrieve cost estimates right now."
  }
};

export default getServiceCostEstimateTool;

================
File: lib/tools/types.ts
================
// lib/tools/types.ts
import { z } from "zod";
import { Practice, AppointmentType, SavedProvider, SavedOperatory } from "@prisma/client";

// Enhanced practice context with scheduling data
export interface PracticeWithSchedulingData extends Practice {
  appointmentTypes: AppointmentType[];
  savedProviders: (SavedProvider & { provider: { id: string; firstName: string | null; lastName: string; nexhealthProviderId: string; } })[];
  savedOperatories: SavedOperatory[];
}

// Tool execution context
export interface ToolExecutionContext {
  practice: PracticeWithSchedulingData;
  vapiCallId: string;
  toolCallId: string;
  assistantId: string;
}

// Standardized tool result format
export interface ToolResult {
  success: boolean;
  message_to_patient: string;
  data?: Record<string, unknown>;
  error_code?: string;
  details?: string;
}

// VAPI tool definition interface
export interface VapiToolFunction {
  name: string;
  description: string;
  parameters: Record<string, unknown>; // JSON schema object
}

export interface VapiToolSchema {
  type: "function";
  async?: boolean;
  function: VapiToolFunction;
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

// Internal tool definition
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface ToolDefinition<T extends z.ZodType<any, any>> {
  name: string;
  description: string;
  schema: T;
  run: (params: { 
    args: z.infer<T>; 
    context: ToolExecutionContext 
  }) => Promise<ToolResult>;
  messages?: {
    start?: string;
    delay?: string;
    success?: string;
    fail?: string;
  };
  async?: boolean;
}

// VAPI webhook payload types
export interface VapiToolCall {
  toolCallId: string;
  name: string;
  arguments: string; // JSON string
}

export interface VapiToolCallsMessage {
  type: "tool-calls";
  timestamp: number;
  call: {
    id: string;
    assistantId: string;
    orgId?: string;
  };
  assistant: {
    id: string;
  };
  toolCallList: VapiToolCall[];
}

export interface VapiServerMessage {
  message: VapiToolCallsMessage;
}

================
File: lib/vapi.ts
================
// VAPI API Client for managing assistants and calls
// Docs: https://docs.vapi.ai

const VAPI_API_BASE_URL = "https://api.vapi.ai";
const VAPI_API_KEY = process.env.VAPI_API_KEY;

if (!VAPI_API_KEY) {
  console.warn("VAPI_API_KEY not configured - VAPI features will not work");
}

// Basic VAPI types based on their API documentation
export interface VapiModel {
  provider: "openai" | "groq" | "anthropic" | "anyscale" | "togetherai";
  model: string; // e.g., "gpt-3.5-turbo", "gpt-4", etc.
  temperature?: number;
  maxTokens?: number;
  messages: Array<{
    role: "system" | "user" | "assistant" | "function";
    content: string;
  }>;
  tools?: VapiTool[];
}

export interface VapiVoice {
  provider: "11labs" | "openai" | "playht" | "lmnt" | "neets" | "rime" | "vapi";
  voiceId: string; // Provider-specific voice ID
  speed?: number;
  stability?: number;
  similarityBoost?: number;
  style?: number;
  useSpeakerBoost?: boolean;
}

export interface VapiTool {
  type: "function";
  async?: boolean;
  function: {
    name: string;
    description: string;
    parameters: Record<string, unknown>; // JSON Schema object
  };
  server: {
    url: string;
    secret?: string;
  };
  messages?: Array<{
    type: "request-start" | "request-response-delayed" | "request-complete" | "request-failed";
    content?: string;
    timingMilliseconds?: number;
  }>;
}

export interface VapiAssistant {
  id: string;
  name: string;
  model: VapiModel;
  voice: VapiVoice;
  firstMessage?: string;
  serverUrl?: string;
  serverMessages?: string[];
  silenceTimeoutSeconds?: number;
  maxDurationSeconds?: number;
  backgroundSound?: "off" | "office";
  backchannelingEnabled?: boolean;
  backgroundDenoisingEnabled?: boolean;
  modelOutputInMessagesEnabled?: boolean;
  transportConfigurations?: Record<string, unknown>[];
  createdAt: string;
  updatedAt: string;
}

export interface CreateAssistantDTO {
  name: string;
  model: VapiModel;
  voice: VapiVoice;
  firstMessage?: string;
  serverUrl?: string;
  serverMessages?: string[];
  silenceTimeoutSeconds?: number;
  maxDurationSeconds?: number;
  backgroundSound?: "off" | "office";
  backchannelingEnabled?: boolean;
  backgroundDenoisingEnabled?: boolean;
  modelOutputInMessagesEnabled?: boolean;
  transportConfigurations?: Record<string, unknown>[];
}

export interface UpdateAssistantDTO extends Partial<CreateAssistantDTO> {
  // All fields from CreateAssistantDTO are optional for updates
  // This interface extends Partial<CreateAssistantDTO> to allow partial updates
  _placeholder?: never; // Placeholder to avoid empty interface error
}

async function vapiRequest(
  endpoint: string,
  method: "GET" | "POST" | "PATCH" | "DELETE" = "GET",
  body?: Record<string, unknown>
): Promise<Record<string, unknown>> {
  if (!VAPI_API_KEY) {
    throw new Error("VAPI_API_KEY is not configured");
  }

  const url = `${VAPI_API_BASE_URL}${endpoint}`;
  
  const options: RequestInit = {
    method,
    headers: {
      "Authorization": `Bearer ${VAPI_API_KEY}`,
      "Content-Type": "application/json",
    },
  };

  if (body && method !== "GET") {
    options.body = JSON.stringify(body);
  }

  console.log(`VAPI API: ${method} ${url}`);
  if (body) {
    console.log("VAPI API body:", JSON.stringify(body, null, 2));
  }

  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`VAPI API error (${response.status}):`, errorText);
      throw new Error(`VAPI API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    console.log(`VAPI API response:`, JSON.stringify(data, null, 2));
    return data as Record<string, unknown>;
  } catch (error) {
    console.error("VAPI API request failed:", error);
    throw error;
  }
}

export async function createVapiAssistant(assistantConfig: CreateAssistantDTO): Promise<VapiAssistant> {
  console.log("Creating VAPI assistant:", assistantConfig.name);
  const result = await vapiRequest("/assistant", "POST", assistantConfig as unknown as Record<string, unknown>);
  return result as unknown as VapiAssistant;
}

export async function updateVapiAssistant(
  assistantId: string, 
  assistantConfig: UpdateAssistantDTO
): Promise<VapiAssistant> {
  console.log(`Updating VAPI assistant ${assistantId}`);
  const result = await vapiRequest(`/assistant/${assistantId}`, "PATCH", assistantConfig as unknown as Record<string, unknown>);
  return result as unknown as VapiAssistant;
}

export async function getVapiAssistant(assistantId: string): Promise<VapiAssistant | null> {
  try {
    console.log(`Getting VAPI assistant ${assistantId}`);
    const result = await vapiRequest(`/assistant/${assistantId}`, "GET");
    return result as unknown as VapiAssistant;
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes("404")) {
      console.log(`VAPI assistant ${assistantId} not found`);
      return null;
    }
    throw error;
  }
}

export async function deleteVapiAssistant(assistantId: string): Promise<void> {
  console.log(`Deleting VAPI assistant ${assistantId}`);
  await vapiRequest(`/assistant/${assistantId}`, "DELETE");
}

// Function to verify VAPI webhook requests (if VAPI provides signing)
export async function verifyVapiRequest(): Promise<{ verified: boolean; error?: string }> {
  // TODO: Implement if VAPI provides request signing
  // For now, return true as a placeholder
  console.log("VAPI request verification - not yet implemented");
  return { verified: true };
}

================
File: lib/utils/error-messages.ts
================
/**
 * Standardized error message templates for patient-facing responses
 * These provide consistent, professional, and helpful messages across all tools
 */

export interface ErrorMessageTemplate {
  code: string;
  message: string;
  category: 'technical' | 'validation' | 'not_found' | 'permission' | 'timeout';
}

export const ERROR_MESSAGES: Record<string, ErrorMessageTemplate> = {
  // Authentication & Permission Errors
  AUTHENTICATION_ERROR: {
    code: 'AUTHENTICATION_ERROR',
    message: "I'm having trouble accessing the system right now. Please contact the office for assistance.",
    category: 'permission'
  },
  
  PERMISSION_ERROR: {
    code: 'PERMISSION_ERROR', 
    message: "I don't have permission to access that information. Please contact the office.",
    category: 'permission'
  },

  // Practice Configuration Errors
  PRACTICE_NOT_FOUND: {
    code: 'PRACTICE_NOT_FOUND',
    message: "I'm having trouble identifying the practice settings. Please contact the office.",
    category: 'technical'
  },

  PRACTICE_NOT_CONFIGURED: {
    code: 'PRACTICE_NOT_CONFIGURED',
    message: "The practice scheduling system isn't fully set up yet. Please contact the office to schedule your appointment.",
    category: 'technical'
  },

  // Patient Lookup Errors
  PATIENT_NOT_FOUND: {
    code: 'PATIENT_NOT_FOUND',
    message: "I couldn't find your information in our system. Could you please verify your name and date of birth, or contact the office directly?",
    category: 'not_found'
  },

  PATIENT_MULTIPLE_MATCHES: {
    code: 'PATIENT_MULTIPLE_MATCHES',
    message: "I found multiple patients with similar information. For your privacy and security, please contact the office directly to schedule your appointment.",
    category: 'validation'
  },

  // Appointment Type Errors
  APPOINTMENT_TYPE_NOT_FOUND: {
    code: 'APPOINTMENT_TYPE_NOT_FOUND',
    message: "I'm not sure what type of appointment you're looking for. Could you describe what you need, or would you like me to list the available services?",
    category: 'not_found'
  },

  APPOINTMENT_TYPE_AMBIGUOUS: {
    code: 'APPOINTMENT_TYPE_AMBIGUOUS', 
    message: "I found several services that might match what you're looking for. Let me help you choose the right one.",
    category: 'validation'
  },

  // Availability & Scheduling Errors
  NO_AVAILABILITY: {
    code: 'NO_AVAILABILITY',
    message: "I don't see any available appointments for that time. Would you like me to check other dates or contact the office for more options?",
    category: 'not_found'
  },

  SCHEDULING_ERROR: {
    code: 'SCHEDULING_ERROR',
    message: "I encountered an issue while checking availability. Please try again or contact the office directly.",
    category: 'technical'
  },

  // Validation Errors - General
  VALIDATION_ERROR: {
    code: 'VALIDATION_ERROR',
    message: "I received some unexpected information. Could you try rephrasing that?",
    category: 'validation'
  },

  // Validation Errors - Specific to New Patient Creation
  MISSING_PHONE: {
    code: 'MISSING_PHONE',
    message: "I need your phone number to create your patient record. What's your phone number?",
    category: 'validation'
  },

  MISSING_EMAIL: {
    code: 'MISSING_EMAIL',
    message: "I need your email address to create your patient record. What's your email address?",
    category: 'validation'
  },

  INVALID_PHONE: {
    code: 'INVALID_PHONE',
    message: "I didn't get a valid phone number. Could you tell me your phone number again? For example, 'my number is three one three, five five five, one two three four'.",
    category: 'validation'
  },

  INVALID_EMAIL: {
    code: 'INVALID_EMAIL',
    message: "I need a valid email address. Could you tell me your email again? For example, 'my email is john at gmail dot com'.",
    category: 'validation'
  },

  INVALID_DATE: {
    code: 'INVALID_DATE',
    message: "I didn't understand that date. Could you try saying it differently, like 'next Tuesday' or 'December 15th'?",
    category: 'validation'
  },

  DATE_TOO_FAR: {
    code: 'DATE_TOO_FAR',
    message: "I can only check availability up to 3 months in advance. Please choose a date within that range.",
    category: 'validation'
  },

  DATE_IN_PAST: {
    code: 'DATE_IN_PAST',
    message: "That date has already passed. Could you choose a future date for your appointment?",
    category: 'validation'
  },

  // Technical Errors
  SYSTEM_ERROR: {
    code: 'SYSTEM_ERROR',
    message: "I'm experiencing a technical issue right now. Please try again in a moment or contact the office directly.",
    category: 'technical'
  },

  TIMEOUT_ERROR: {
    code: 'TIMEOUT_ERROR',
    message: "That request is taking longer than expected. Please try again or contact the office if the issue continues.",
    category: 'timeout'
  },

  // NexHealth API Errors
  NEXHEALTH_API_ERROR: {
    code: 'NEXHEALTH_API_ERROR',
    message: "I'm having trouble connecting to the scheduling system. Please contact the office to make your appointment.",
    category: 'technical'
  },

  NEXHEALTH_RATE_LIMIT: {
    code: 'NEXHEALTH_RATE_LIMIT',
    message: "The system is busy right now. Please wait a moment and try again, or contact the office directly.",
    category: 'timeout'
  },

  // Generic Fallback
  EXECUTION_ERROR: {
    code: 'EXECUTION_ERROR',
    message: "I encountered an issue while processing your request. Please try again or contact the office for assistance.",
    category: 'technical'
  },

  INVALID_DATE_OF_BIRTH: {
    code: 'INVALID_DATE_OF_BIRTH',
    message: "I need your date of birth in a valid format. Could you tell me your date of birth again?",
    category: 'validation'
  },

  MISSING_FIRST_NAME: {
    code: 'MISSING_FIRST_NAME',
    message: "I need your first name to create your patient record. Could you tell me your first name?",
    category: 'validation'
  },

  MISSING_LAST_NAME: {
    code: 'MISSING_LAST_NAME',
    message: "I need your last name to create your patient record. Could you tell me your last name?",
    category: 'validation'
  }
};

/**
 * Get a standardized error message for a given error code
 */
export function getErrorMessage(code: string): ErrorMessageTemplate {
  return ERROR_MESSAGES[code] || ERROR_MESSAGES.EXECUTION_ERROR;
}

/**
 * Get just the patient message for a given error code
 */
export function getPatientMessage(code: string): string {
  return getErrorMessage(code).message;
}

/**
 * Parse Zod validation errors to determine specific error codes
 */
function parseZodValidationError(error: Error, toolName?: string): string {
  try {
    // Check if this is a ZodError with detailed issues
    if (error.name === 'ZodError' && 'issues' in error) {
      const zodError = error as { issues: Array<{ path: string[]; code: string; message?: string; validation?: string }> };
      
      // Special handling for create_new_patient tool
      if (toolName === 'create_new_patient' && zodError.issues) {
        for (const issue of zodError.issues) {
          if (issue.path && issue.path.length > 0) {
            const fieldName = issue.path[0];
            
            // Check for specific field validation errors
            if (fieldName === 'phone') {
              if (issue.code === 'too_small' || issue.code === 'invalid_string') {
                return 'MISSING_PHONE';
              }
            }
            
            if (fieldName === 'email') {
              if (issue.validation === 'email' || issue.code === 'invalid_string') {
                return 'MISSING_EMAIL';
              }
            }
            
            if (fieldName === 'firstName') {
              return 'MISSING_FIRST_NAME';
            }
            
            if (fieldName === 'lastName') {
              return 'MISSING_LAST_NAME';
            }
            
            if (fieldName === 'dateOfBirth') {
              return 'INVALID_DATE_OF_BIRTH';
            }
          }
        }
      }
      
      // Default validation error
      return 'VALIDATION_ERROR';
    }
    
    return 'VALIDATION_ERROR';
  } catch {
    return 'VALIDATION_ERROR';
  }
}

/**
 * Determine error code from an error object
 */
export function getErrorCode(error: unknown, toolName?: string): string {
  if (error instanceof Error) {
    const message = error.message.toLowerCase();
    
    // Handle Zod validation errors with specific parsing
    if (error.name === 'ZodError' || message.includes('validation')) {
      return parseZodValidationError(error, toolName);
    }
    
    // Authentication & Permission
    if (message.includes('401') || message.includes('unauthorized')) {
      return 'AUTHENTICATION_ERROR';
    }
    if (message.includes('403') || message.includes('forbidden')) {
      return 'PERMISSION_ERROR';
    }
    
    // NexHealth specific
    if (message.includes('nexhealth')) {
      if (message.includes('rate limit') || message.includes('429')) {
        return 'NEXHEALTH_RATE_LIMIT';
      }
      return 'NEXHEALTH_API_ERROR';
    }
    
    // Not found
    if (message.includes('404') || message.includes('not found')) {
      return 'PATIENT_NOT_FOUND';
    }
    
    // Timeout
    if (message.includes('timeout') || message.includes('connection')) {
      return 'TIMEOUT_ERROR';
    }
  }
  
  return 'EXECUTION_ERROR';
}

/**
 * Helper to get both error code and patient message from an error
 */
export function processError(error: unknown, toolName?: string): { code: string; message: string } {
  const code = getErrorCode(error, toolName);
  const message = getPatientMessage(code);
  return { code, message };
}

================
File: app/api/practice-config/basic/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { subscribePracticeToWebhooks } from "@/lib/webhook-utils";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const formData = await req.formData();
    const name = formData.get("practiceName") as string | null;
    const subdomain = formData.get("nexhealthSubdomain") as string;
    const locationId = formData.get("nexhealthLocationId") as string;
    const address = formData.get("practiceAddress") as string | null;
    const acceptedInsurances = formData.get("acceptedInsurances") as string | null;
    const serviceCostEstimates = formData.get("serviceCostEstimates") as string | null;

    if (!subdomain || !locationId) {
      return NextResponse.json(
        { error: "Subdomain and Location ID are required" },
        { status: 400 }
      );
    }

    // Save the practice configuration
    const practice = await prisma.practice.upsert({
      where: { clerkUserId: userId },
      update: { 
        name, 
        nexhealthSubdomain: subdomain, 
        nexhealthLocationId: locationId,
        address,
        acceptedInsurances,
        serviceCostEstimates,
        webhookLastSyncAt: new Date() // Update sync timestamp
      },
      create: { 
        clerkUserId: userId, 
        name, 
        nexhealthSubdomain: subdomain, 
        nexhealthLocationId: locationId,
        address,
        acceptedInsurances,
        serviceCostEstimates,
        webhookLastSyncAt: new Date() // Set initial sync timestamp
      },
    });

    // Automatically sync webhooks after saving configuration
    let webhookSyncResult = { 
      success: false, 
      message: "Webhook sync not attempted",
      successCount: 0,
      skipCount: 0,
      failCount: 0
    };
    
    try {
      console.log(`[AutoWebhookSync] Auto-syncing webhooks for practice ${practice.id}...`);
      webhookSyncResult = await subscribePracticeToWebhooks(subdomain);
      
      if (webhookSyncResult.success) {
        console.log(`[AutoWebhookSync]  Successfully synced webhooks for ${subdomain}`);
      } else {
        console.warn(`[AutoWebhookSync]  Webhook sync completed with issues: ${webhookSyncResult.message}`);
      }
    } catch (webhookError) {
      console.error(`[AutoWebhookSync]  Failed to sync webhooks:`, webhookError);
      webhookSyncResult = {
        success: false,
        message: "Configuration saved, but webhook sync failed",
        successCount: 0,
        skipCount: 0,
        failCount: 0
      };
    }

    return NextResponse.json({ 
      success: true,
      webhookSync: webhookSyncResult
    });

  } catch (error) {
    console.error("Error saving practice config:", error);
    return NextResponse.json(
      { error: "Failed to save configuration" },
      { status: 500 }
    );
  }
}

================
File: app/api/practice-config/check-slots/route.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

interface NexhealthSlot {
  time: string;
  end_time: string;
  operatory_id?: number;
  [key: string]: unknown;
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const practice = await prisma.practice.findUnique({
      where: { clerkUserId: userId },
      include: {
        appointmentTypes: true,
        savedProviders: {
          include: {
            provider: true
          },
          where: { isActive: true }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });

    if (!practice) {
      return NextResponse.json({ error: "Practice not found" }, { status: 404 });
    }

    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return NextResponse.json({ 
        error: "NexHealth configuration incomplete. Please configure subdomain and location ID." 
      }, { status: 400 });
    }

    const {
      requestedDate,
      appointmentTypeId,
      providerIds,
      operatoryIds,
      daysToSearch = 1
    } = await req.json();

    // Validate required fields
    if (!requestedDate || !appointmentTypeId || !providerIds || !Array.isArray(providerIds)) {
      return NextResponse.json({ 
        error: "Missing required fields: requestedDate, appointmentTypeId, providerIds (array)" 
      }, { status: 400 });
    }

    // Validate date format (YYYY-MM-DD)
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(requestedDate)) {
      return NextResponse.json({ 
        error: "requestedDate must be in YYYY-MM-DD format" 
      }, { status: 400 });
    }

    // Validate daysToSearch is a positive number
    if (typeof daysToSearch !== 'number' || daysToSearch < 1 || daysToSearch > 30) {
      return NextResponse.json({ 
        error: "daysToSearch must be a number between 1 and 30" 
      }, { status: 400 });
    }

    // Validate appointment type belongs to practice
    const appointmentType = practice.appointmentTypes.find(
      at => at.nexhealthAppointmentTypeId === appointmentTypeId
    );

    if (!appointmentType) {
      return NextResponse.json({ 
        error: "Appointment type not found or doesn't belong to practice" 
      }, { status: 400 });
    }

    // Filter providers based on selection or use all active
    let activeProviders = practice.savedProviders.filter(sp => sp.isActive);
    if (providerIds.length > 0) {
      activeProviders = activeProviders.filter(sp => providerIds.includes(sp.provider.id));
    }

    // Filter operatories based on selection or use all active
    let activeOperatories = practice.savedOperatories.filter(so => so.isActive);
    if (operatoryIds && Array.isArray(operatoryIds) && operatoryIds.length > 0) {
      activeOperatories = activeOperatories.filter(so => operatoryIds.includes(so.id));
    }

    if (activeProviders.length === 0) {
      return NextResponse.json({ 
        error: "No providers are currently configured for scheduling" 
      }, { status: 400 });
    }

    // Get provider arrays
    const providers = activeProviders.map(sp => sp.provider.nexhealthProviderId);

    // Build NexHealth API parameters
    const params: Record<string, string | number | string[]> = {
      start_date: requestedDate,
      days: daysToSearch,
      'lids[]': [practice.nexhealthLocationId],
      'pids[]': providers,
      appointment_type_id: appointmentTypeId
    };

    // Add operatory IDs if provided
    if (operatoryIds && Array.isArray(operatoryIds) && operatoryIds.length > 0) {
      // Convert local operatory IDs to NexHealth operatory IDs
      const nexhealthOperatoryIds = activeOperatories.map(so => so.nexhealthOperatoryId);
      params['operatory_ids[]'] = nexhealthOperatoryIds;
    }

    console.log("Checking appointment slots with params:", params);

    // Call NexHealth API
    const slotsResponse = await fetchNexhealthAPI(
      '/appointment_slots',
      practice.nexhealthSubdomain,
      params
    );

    // Parse response and extract slots
    const availableSlots: Array<NexhealthSlot & { provider_id: number; location_id: number }> = [];
    
    if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
      // Extract all slots from all providers
      for (const providerData of slotsResponse.data) {
        if (providerData.slots && Array.isArray(providerData.slots)) {
          availableSlots.push(...providerData.slots.map((slot: NexhealthSlot) => ({
            ...slot,
            provider_id: providerData.pid,
            location_id: providerData.lid
          })));
        }
      }
    }

    // Create provider lookup map
    const providerLookup = new Map();
    activeProviders.forEach(sp => {
      providerLookup.set(sp.provider.nexhealthProviderId, {
        id: sp.provider.id,
        nexhealthProviderId: sp.provider.nexhealthProviderId,
        name: `${sp.provider.firstName || ''} ${sp.provider.lastName}`.trim()
      });
    });

    // Create operatory lookup map
    const operatoryLookup = new Map();
    activeOperatories.forEach(so => {
      operatoryLookup.set(so.nexhealthOperatoryId, {
        id: so.id,
        nexhealthOperatoryId: so.nexhealthOperatoryId,
        name: so.name
      });
    });

    // Format slots for display with enhanced information
    const formattedSlots = availableSlots.map((slot, index) => {
      // Parse the time string correctly to preserve the timezone
      const startTime = new Date(slot.time);
      const endTime = new Date(slot.end_time);
      
      // Use the timezone from the original date string for formatting
      const timeString = startTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
      });

      const endTimeString = endTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true,
        timeZone: 'America/Chicago'
      });

      // Get provider and operatory details
      const providerInfo = providerLookup.get(slot.provider_id.toString()) || { 
        name: `Provider ${slot.provider_id}`, 
        nexhealthProviderId: slot.provider_id 
      };
      
      const operatoryInfo = slot.operatory_id ? 
        operatoryLookup.get(slot.operatory_id.toString()) || { 
          name: `Operatory ${slot.operatory_id}`, 
          nexhealthOperatoryId: slot.operatory_id 
        } : null;
      
      return {
        slot_id: `slot_${index}`,
        time: slot.time,
        end_time: slot.end_time,
        display_time: timeString,
        display_end_time: endTimeString,
        display_range: `${timeString} - ${endTimeString}`,
        operatory_id: slot.operatory_id,
        provider_id: slot.provider_id,
        location_id: slot.location_id,
        provider_info: providerInfo,
        operatory_info: operatoryInfo
      };
    });

    // Sort slots by time
    formattedSlots.sort((a, b) => new Date(a.time).getTime() - new Date(b.time).getTime());

    return NextResponse.json({
      success: true,
      params: params,
      response: slotsResponse,
      data: {
        requested_date: requestedDate,
        appointment_type: {
          id: appointmentType.nexhealthAppointmentTypeId,
          name: appointmentType.name,
          duration: appointmentType.duration
        },
        available_slots: formattedSlots,
        has_availability: formattedSlots.length > 0,
        total_slots_found: formattedSlots.length,
        debug_info: {
          providers_checked: activeProviders.length,
          operatories_checked: activeOperatories.length,
          providers_used: activeProviders.map(sp => ({
            id: sp.provider.id,
            name: `${sp.provider.firstName || ''} ${sp.provider.lastName}`.trim(),
            nexhealthProviderId: sp.provider.nexhealthProviderId
          })),
          operatories_used: activeOperatories.map(so => ({
            id: so.id,
            name: so.name,
            nexhealthOperatoryId: so.nexhealthOperatoryId
          }))
        }
      }
    });

  } catch (error) {
    console.error("Error checking appointment slots:", error);
    return NextResponse.json(
      { 
        error: "Failed to check appointment slots", 
        details: error instanceof Error ? error.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}

================
File: README.md
================
# Laine AI Voice Assistant

AI-powered voice assistant for healthcare practices, integrating NexHealth EHR with VAPI voice AI technology.

## Features

-  **VAPI Voice Integration**: AI-powered voice calls with customizable assistants
-  **NexHealth EHR Integration**: Patient lookup, appointment management, and data synchronization
-  **Webhook Management**: Automated event handling for appointments and patient updates
-  **Practice Management**: Multi-tenant SaaS platform with practice-specific configurations
-  **Secure Authentication**: Clerk-based user authentication and practice isolation

## Quick Start

1. **Environment Setup**:
   ```bash
   cp .env.example .env
   # Configure your API keys and database URL
   ```

2. **Database Setup**:
   ```bash
   pnpm install
   pnpm db:push
   ```

3. **Development Server**:
   ```bash
   pnpm dev
   ```

4. **Webhook Configuration** (Production):
   ```bash
   # Setup global webhook endpoint
   pnpm webhook:setup
   
   # Subscribe practices to events
   pnpm webhook:subscribe your-practice-subdomain
   ```

## Documentation

-  [Webhook Management Guide](docs/webhook-management.md) - Complete guide to NexHealth webhook setup
-  [API Documentation](docs/api.md) - API endpoints and integration details

## Technology Stack

- **Frontend**: Next.js 15, React 19, Tailwind CSS
- **Backend**: Next.js API Routes, Prisma ORM
- **Database**: PostgreSQL (Supabase)
- **Authentication**: Clerk
- **Voice AI**: VAPI
- **EHR Integration**: NexHealth API
- **Deployment**: Vercel

## Key Components

### VAPI Assistant Integration
- AI voice assistants with customizable voices and prompts
- Tool calling system for EHR operations
- Call logging and transcript management

### NexHealth Integration  
- Patient search and data retrieval
- Appointment scheduling and management
- Real-time webhook event processing

### Practice Management
- Multi-tenant architecture with practice isolation
- Configurable assistant settings per practice
- Automated practice onboarding workflow

# LAINE Project Context

## **Project Overview**
**LAINE** is an AI voice receptionist SaaS platform for dental practices. It enables dental offices to automate patient interactions, appointment scheduling, and EHR integration through AI voice assistants.

## **Core Functionality**
- **AI Voice Reception**: Patients call and speak with an AI assistant (powered by VAPI)
- **Patient Lookup**: Find existing patients in the practice's EHR system
- **Appointment Scheduling**: Check availability and book appointments
- **EHR Integration**: Connect with NexHealth to access patient records and scheduling
- **Multi-Tenant SaaS**: Each dental practice gets isolated data and configuration

## **Technology Stack**

### **Frontend**
- **Next.js 15+** (App Router)
- **React 19** with TypeScript
- **Tailwind CSS** for styling
- **Clerk** for authentication

### **Backend**
- **Next.js API Routes** 
- **Prisma ORM** with PostgreSQL
- **Supabase** for database hosting

### **External Integrations**
- **VAPI**: AI voice calling platform
- **NexHealth**: Dental practice EHR/scheduling system  
- **Clerk**: User authentication and management

### **Key Dependencies**
- `@clerk/nextjs` - Authentication
- `@prisma/client` - Database ORM
- `zod` - Schema validation
- `sonner` - Toast notifications

## **Architecture Patterns**

### **Multi-Tenant SaaS Design**
- Each dental practice is isolated by `practiceId`
- Users authenticate via Clerk (`clerkUserId`)
- All data operations are practice-scoped

### **Tool-Based AI Framework**
- AI assistant uses "tools" to perform actions
- Tools are TypeScript functions with Zod schemas
- Centralized tool execution via webhook handler

### **API Integration Layer**
- NexHealth API for EHR operations
- VAPI API for voice assistant management
- Token-based authentication with caching

## **Database Schema (Key Models)**

### **Core Models**
```prisma
Practice {
  id: String (Primary Key)
  clerkUserId: String (Unique - links to Clerk user)
  name: String? (Optional practice name)
  nexhealthSubdomain: String? (NexHealth subdomain)
  nexhealthLocationId: String? (NexHealth location ID)
}

PracticeAssistantConfig {
  practiceId: String (FK to Practice)
  vapiAssistantId: String? (VAPI assistant ID)
  voiceProvider: String (voice provider)
  systemPrompt: String (AI instructions)
  firstMessage: String (greeting message)
}
```

### **Scheduling Models**
```prisma
AppointmentType {
  practiceId: String (FK to Practice)
  nexhealthAppointmentTypeId: String (NexHealth ID)
  name: String (e.g., "General Cleanup")
  duration: Int (minutes)
}

Provider {
  practiceId: String (FK to Practice) 
  nexhealthProviderId: String (NexHealth ID)
  firstName: String?
  lastName: String
}

SavedProvider {
  practiceId: String (FK to Practice)
  providerId: String (FK to Provider)
  isDefault: Boolean
  isActive: Boolean
}
```

### **Logging Models**
```prisma
CallLog {
  vapiCallId: String (Unique - from VAPI)
  practiceId: String (FK to Practice)
  callStatus: String (e.g., "IN_PROGRESS", "ENDED")
  transcriptText: String?
  nexhealthPatientId: String? (if patient found)
}

ToolLog {
  practiceId: String (FK to Practice)
  vapiCallId: String? (FK to CallLog)
  toolName: String (e.g., "find_patient_in_ehr")
  toolCallId: String (VAPI tool call ID)
  arguments: String (JSON)
  result: String (JSON)
  success: Boolean
}
```

## **Key API Endpoints**

### **VAPI Integration**
- `POST /api/vapi/tool-calls` - Centralized tool execution webhook
- `POST /api/vapi/webhook` - General VAPI webhooks (call status, transcripts)

### **Practice Configuration**
- `POST /api/practice-config/providers` - Save provider preferences
- `POST /api/practice-config/operatories` - Save operatory preferences
- `POST /api/sync-nexhealth` - Sync data from NexHealth API

### **NexHealth Integration**
- `POST /api/nexhealth-webhook` - Receive NexHealth events
- `POST /api/webhook-subscribe` - Subscribe to NexHealth events

## **AI Tools Framework**

### **Tool Structure**
Each tool is defined with:
```typescript
interface ToolDefinition<T extends z.ZodType> {
  name: string                    // Tool identifier
  description: string             // What the tool does
  schema: T                      // Zod validation schema
  run: (params) => Promise<ToolResult>  // Tool execution logic
  messages?: ToolMessages        // VAPI voice prompts
}
```

### **Current Tools**
1. **`find_patient_in_ehr`** - Search for patients by name and DOB
2. **`find_appointment_type`** - Match patient requests to appointment types
3. **`check_available_slots`** - Find available appointment times

### **Tool Execution Flow**
1. VAPI calls `/api/vapi/tool-calls` webhook
2. Practice identified by assistant ID
3. Tool arguments validated with Zod
4. Tool executes with practice context
5. Results logged to database
6. Response sent back to VAPI

## **Typical User Journey**

### **Practice Setup**
1. Practice owner signs up via Clerk
2. Configure NexHealth subdomain and location ID
3. Sync appointment types and providers from NexHealth
4. Select preferred providers and operatories for scheduling
5. Create and configure VAPI voice assistant

### **Patient Interaction**
1. Patient calls dental office phone number
2. VAPI voice assistant answers
3. Assistant asks for patient name and date of birth
4. `find_patient_in_ehr` tool searches NexHealth EHR
5. If patient found, assistant asks about appointment purpose
6. `find_appointment_type` tool matches request to available types
7. `check_available_slots` tool finds available times
8. Assistant presents options to patient

## **Environment Variables**
```bash
# Database
DATABASE_URL=postgresql://...

# Authentication  
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_...
CLERK_SECRET_KEY=sk_...

# VAPI Integration
VAPI_API_KEY=vapi_...
NEXT_PUBLIC_APP_URL=https://your-domain.com

# NexHealth Integration
NEXHEALTH_API_KEY=nexhealth_...
NEXHEALTH_API_BASE_URL=https://nexhealth.info
```

## **Key File Structure**
```
app/
 api/
    vapi/
       tool-calls/route.ts     # Centralized tool handler
       webhook/route.ts        # VAPI general webhooks
    practice-config/            # Practice management APIs
    nexhealth-webhook/route.ts  # NexHealth event handler
 practice-config/                # Practice configuration UI
 laine/                         # Assistant configuration UI

lib/
 tools/
    types.ts                   # Tool framework types
    index.ts                   # Tool registry
    findPatient.ts            # Patient lookup tool
    findAppointmentType.ts    # Appointment type matching
    checkAvailableSlots.ts    # Availability checking
 nexhealth.ts                  # NexHealth API client
 vapi.ts                       # VAPI API client
 prisma.ts                     # Database client

prisma/
 schema.prisma                  # Database schema
```

## **Development Commands**
```bash
# Development
pnpm dev                          # Start development server
pnpm build                        # Build for production
pnpm lint                         # Run ESLint

# Database
pnpm db:push                      # Push schema changes
pnpm db:list                      # List database contents
pnpm db:clean                     # Clean test data

# Webhooks
pnpm webhook:setup                # Setup NexHealth webhook endpoint
pnpm webhook:subscribe <subdomain> # Subscribe practice to events
pnpm webhook:list                 # List webhook subscriptions
```

## **Common Patterns**

### **Practice Context Injection**
All operations include practice context:
```typescript
const practice = await findPracticeByAssistantId(assistantId);
// All subsequent operations are practice-scoped
```

### **Error Handling**
User-friendly error messages for patients:
```typescript
return {
  success: false,
  error_code: "PATIENT_NOT_FOUND",
  message_to_patient: "I couldn't find that patient. Would you like to try different information?"
};
```

### **Tool Result Format**
Standardized response format:
```typescript
interface ToolResult {
  success: boolean
  message_to_patient: string  // What the AI says to the patient
  data?: Record<string, unknown>  // Structured data
  error_code?: string  // Error classification
}
```

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ClerkProvider, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs";
import { auth } from "@clerk/nextjs/server";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Laine AI Voice Assistant",
  description: "Advanced voice assistant for healthcare practices with seamless NexHealth integration",
};

async function Header() {
  const { userId } = await auth();
  
  return (
    <header className="fixed top-0 left-0 right-0 bg-white/10 backdrop-blur-md border-b border-slate-200/30 z-50">
      <div className="flex items-center justify-between max-w-6xl mx-auto px-6 py-4">
        <div className="flex items-center">
          <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center mr-3">
            <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
          <h1 className="text-xl font-bold text-slate-900">Laine AI</h1>
        </div>
        <div className="flex items-center gap-4">
          {userId ? (
            <div className="flex items-center gap-4">
              <a 
                href="/practice-config" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Practice Config
              </a>
              <a 
                href="/laine" 
                className="text-slate-600 hover:text-slate-900 font-medium transition-colors"
              >
                Laine Assistant
              </a>
              <UserButton afterSignOutUrl="/" />
            </div>
          ) : (
            <>
              <SignInButton mode="modal">
                <button className="px-4 py-2 text-sm font-medium text-slate-600 hover:text-slate-900 transition-colors">
                  Sign In
                </button>
              </SignInButton>
              <SignUpButton mode="modal">
                <button className="px-4 py-2 text-sm font-semibold bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                  Sign Up
                </button>
              </SignUpButton>
            </>
          )}
        </div>
      </div>
    </header>
  );
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body
          className={`${geistSans.variable} ${geistMono.variable} antialiased bg-slate-50`}
        >
          <Header />
          <main className="pt-20">
            {children}
          </main>
        </body>
      </html>
    </ClerkProvider>
  );
}

================
File: lib/tools/findAppointmentType.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";

export const findAppointmentTypeSchema = z.object({
  userRequest: z.string()
    .min(1)
    .describe(`Extract appointment type patient is requesting.

Common variations:
- Cleaning: "cleaning", "teeth cleaning", "hygiene", "prophy"
- Checkup: "checkup", "exam", "routine visit"
- Emergency: "tooth pain", "broken tooth", "urgent"
- Filling: "cavity", "filling", "tooth repair"
- Crown: "crown", "cap"
- Root Canal: "root canal", "nerve treatment"
- Extraction: "pull tooth", "remove tooth"

Examples: "I need a cleaning"  "cleaning", "My tooth hurts"  "tooth pain"`)
});

const findAppointmentTypeTool: ToolDefinition<typeof findAppointmentTypeSchema> = {
  name: "find_appointment_type",
  description: "Matches the patient's request for service to available appointment types in the practice. Use this after confirming patient identity to determine what type of appointment they need.",
  schema: findAppointmentTypeSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.appointmentTypes || practice.appointmentTypes.length === 0) {
      return {
        success: false,
        error_code: "NO_APPOINTMENT_TYPES",
        message_to_patient: "I don't have any appointment types configured for this practice. Please contact the office directly to schedule your appointment."
      };
    }

    try {
      const userRequest = args.userRequest.toLowerCase().trim();
      
      // Create searchable appointment type list with common aliases
      const appointmentTypeAliases: Record<string, string[]> = {
        'cleaning': ['clean', 'hygiene', 'prophy', 'prophylaxis', 'dental cleaning', 'teeth cleaning'],
        'checkup': ['check', 'exam', 'examination', 'visit', 'routine'],
        'consultation': ['consult', 'new patient', 'initial'],
        'filling': ['cavity', 'restoration', 'tooth repair'],
        'crown': ['cap', 'tooth cap'],
        'root canal': ['endodontic', 'nerve', 'tooth infection'],
        'extraction': ['pull', 'remove', 'tooth removal'],
        'emergency': ['urgent', 'pain', 'broken', 'asap']
      };

      const availableTypes = practice.appointmentTypes.map(type => ({
        id: type.nexhealthAppointmentTypeId,
        name: type.name,
        duration: type.duration,
        searchTerms: type.name.toLowerCase(),
        aliases: [] as string[]
      }));

      // Add aliases to available types
      availableTypes.forEach(type => {
        Object.entries(appointmentTypeAliases).forEach(([key, aliases]) => {
          if (type.searchTerms.includes(key)) {
            type.aliases = aliases;
          }
        });
      });

      console.log(`[findAppointmentType] Looking for "${userRequest}" in types:`, availableTypes.map(t => t.name));

      // Enhanced matching algorithm
      let bestMatch = null;
      let bestScore = 0;

      for (const type of availableTypes) {
        let score = 0;
        
        // Exact match gets highest score
        if (type.searchTerms === userRequest) {
          score = 100;
        }
        // Check aliases
        else if (type.aliases.some(alias => userRequest.includes(alias))) {
          score = 80;
        }
        // Check if type name is in request
        else if (userRequest.includes(type.searchTerms)) {
          score = 70;
        }
        // Partial word matches
        else {
          const requestWords = userRequest.split(' ');
          const typeWords = type.searchTerms.split(' ');
          
          for (const requestWord of requestWords) {
            for (const typeWord of typeWords) {
              if (typeWord.includes(requestWord) || requestWord.includes(typeWord)) {
                score += 20;
              }
            }
            // Check aliases too
            for (const alias of type.aliases) {
              if (alias.includes(requestWord) || requestWord.includes(alias)) {
                score += 15;
              }
            }
          }
        }

        if (score > bestScore) {
          bestScore = score;
          bestMatch = type;
        }
      }

      if (!bestMatch || bestScore < 10) {
        // No good match found - present options conversationally
        const typeOptions = availableTypes
          .slice(0, 5) // Limit to 5 options for voice
          .map(type => type.name)
          .join(', ');
          
        return {
          success: true,
          message_to_patient: `I want to make sure I schedule the right appointment for you. We offer ${typeOptions}. Which of these best describes what you need?`,
          data: {
            matched: false,
            available_types: availableTypes.map(t => ({
              id: t.id,
              name: t.name,
              duration: t.duration
            })),
            user_request: userRequest
          }
        };
      }

      // Good match found - confirm and move forward
      return {
        success: true,
        message_to_patient: `Perfect! I can schedule you for a ${bestMatch.name} which takes ${bestMatch.duration} minutes. What day would you like to come in?`,
        data: {
          matched: true,
          appointment_type_id: bestMatch.id,
          appointment_type_name: bestMatch.name,
          duration_minutes: bestMatch.duration,
          user_request: userRequest
        }
      };

    } catch (error) {
      console.error(`[findAppointmentType] Error:`, error);
      
      return {
        success: false,
        error_code: "APPOINTMENT_TYPE_SEARCH_ERROR",
        message_to_patient: "I had trouble understanding what type of appointment you need. Could you tell me again what you'd like to come in for?",
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me find the right appointment type for you...",
    success: "Great! I can help you schedule that.",
    fail: "Let me check what appointment types we have available."
  }
};

export default findAppointmentTypeTool;

================
File: app/laine/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { createVapiAssistant } from "@/lib/vapi";
import { buildVapiTools } from "@/lib/tools";
import { LainePracticeClient } from "./laine-practice-client";

async function createPracticeAssistant() {
  "use server";
  
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Not authenticated");
  }

  // Get the practice
  const practice = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practice) {
    throw new Error("Practice not found");
  }

  if (practice.assistantConfig?.vapiAssistantId) {
    throw new Error("Assistant already exists for this practice");
  }

  const appBaseUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
  
  // Build tools for the assistant
  const tools = buildVapiTools(appBaseUrl);
  
  // Create default assistant configuration
  const assistantConfig = {
    name: `${practice.name || 'Practice'} - Laine`,
    model: {
      provider: "openai" as const,
      model: "gpt-4.1-nano",
      temperature: 0.7,
      messages: [
        {
          role: "system" as const,
          content: "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient."
        }
      ],
      tools
    },
    voice: {
      provider: "vapi" as const,
      voiceId: "Elliot"
    },
    firstMessage: "Hello! This is Laine from your dental office. How can I help you today?",
    // General assistant webhooks (status updates, call reports, transcripts)
    serverUrl: `${appBaseUrl}/api/vapi/webhook`,
    serverMessages: ["end-of-call-report", "status-update", "transcript"],
    silenceTimeoutSeconds: 30,
    maxDurationSeconds: 600, // 10 minutes
    backgroundSound: "office" as const,
    backchannelingEnabled: true,
    backgroundDenoisingEnabled: true,
    modelOutputInMessagesEnabled: true
  };

  try {
    console.log("Creating VAPI assistant for practice:", practice.id);
    const vapiAssistant = await createVapiAssistant(assistantConfig);
    
    // Create or update the assistant config in our database
    await prisma.practiceAssistantConfig.upsert({
      where: { practiceId: practice.id },
      create: {
        practiceId: practice.id,
        vapiAssistantId: vapiAssistant.id,
        voiceProvider: "vapi",
        voiceId: "Elliot",
        systemPrompt: "You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.",
        firstMessage: "Hello! This is Laine from your dental office. How can I help you today?"
      },
      update: {
        vapiAssistantId: vapiAssistant.id,
        updatedAt: new Date()
      }
    });

    console.log(`Successfully created VAPI assistant ${vapiAssistant.id} for practice ${practice.id}`);
  } catch (error) {
    console.error("Error creating VAPI assistant:", error);
    throw new Error(`Failed to create assistant: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }

  revalidatePath("/laine");
}

export default async function LainePage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect("/sign-in");
  }

  // Get the practice with assistant configuration
  const practice = await prisma.practice.findUnique({
    where: { clerkUserId: userId },
    include: { assistantConfig: true }
  });

  if (!practice) {
    redirect("/practice-config");
  }

  const hasAssistant = practice.assistantConfig?.vapiAssistantId;

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-2xl mx-auto">
        <h1 className="text-3xl font-bold mb-6">Laine AI Assistant Configuration</h1>
        <LainePracticeClient 
          practice={practice} 
          hasAssistant={!!hasAssistant}
          createPracticeAssistant={createPracticeAssistant}
        />
      </div>
    </div>
  );
}

================
File: lib/tools/findPatient.ts
================
// lib/tools/findPatient.ts
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Helper to get current date context
function getCurrentDateContext(): string {
  const today = new Date();
  return `Today is ${today.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  })}`;
}

export const findPatientSchema = z.object({
  firstName: z.string()
    .min(1)
    .describe(`Extract patient's first name. If spelled letter by letter (B-O-B), convert to proper name (Bob).

Examples: "My name is Bob Ross"  "Bob", "First name B-O-B"  "Bob"`),
  lastName: z.string()
    .min(1)
    .describe(`Extract patient's last name. If spelled letter by letter (R-O-S-S), convert to proper name (Ross).

Examples: "Bob Ross"  "Ross", "last name R-O-S-S"  "Ross"`),
  dateOfBirth: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe(`Convert date of birth to YYYY-MM-DD format.

${getCurrentDateContext()}

Examples: "October 30, 1998"  "1998-10-30", "10/30/98"  "1998-10-30"
For 2-digit years: 50-99  1900s, 00-49  2000s`)
});

const findPatientTool: ToolDefinition<typeof findPatientSchema> = {
  name: "find_patient_in_ehr",
  description: "Searches for an existing patient in the Electronic Health Record using first name, last name, and date of birth. Use this before any appointment scheduling to verify patient identity.",
  schema: findPatientSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I'm sorry, I can't access patient records right now. Please contact the office directly at your convenience."
      };
    }

    try {
      const patientName = `${args.firstName} ${args.lastName}`;
      const searchParams = {
        location_id: practice.nexhealthLocationId,
        name: patientName,
        date_of_birth: args.dateOfBirth,
        inactive: 'false',
        non_patient: 'false',
        page: '1',
        per_page: '300'
      };

      console.log(`[findPatient] Searching for: ${patientName}, DOB: ${args.dateOfBirth}`);
      
      const searchResults = await fetchNexhealthAPI(
        '/patients',
        practice.nexhealthSubdomain,
        searchParams
      );
      
      // Handle different response structures
      let patients = [];
      if (Array.isArray(searchResults)) {
        patients = searchResults;
      } else if (searchResults?.data?.patients) {
        patients = searchResults.data.patients;
      } else if (searchResults?.patients) {
        patients = searchResults.patients;
      } else if (searchResults?.data && Array.isArray(searchResults.data)) {
        patients = searchResults.data;
      }

      console.log(`[findPatient] Found ${patients.length} potential matches`);

      if (patients.length === 0) {
        // Format the date for friendly display
        const dobParts = args.dateOfBirth.split('-');
        const dobDate = new Date(parseInt(dobParts[0]), parseInt(dobParts[1]) - 1, parseInt(dobParts[2]));
        const friendlyDob = dobDate.toLocaleDateString('en-US', { 
          month: 'long', 
          day: 'numeric', 
          year: 'numeric' 
        });
        
        return {
          success: true,
          message_to_patient: `I couldn't find a patient record for ${args.firstName} ${args.lastName} with date of birth ${friendlyDob}. Are you a new patient with us, or would you like to try different information?`,
          data: { 
            found_patients: [], 
            patient_exists: false,
            searched_name: `${args.firstName} ${args.lastName}`,
            searched_dob: args.dateOfBirth
          }
        };
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const patient = patients[0] as any; // Take first match
      
      // Store patient context for subsequent tool calls
      await updateCallLogWithPatient(vapiCallId, practice.id, String(patient.id));
      
      // Format the date of birth for natural speech
      const patientDob = patient.bio?.date_of_birth || patient.date_of_birth || args.dateOfBirth;
      const dobParts = patientDob.split('-');
      const dobDate = new Date(parseInt(dobParts[0]), parseInt(dobParts[1]) - 1, parseInt(dobParts[2]));
      const friendlyDob = dobDate.toLocaleDateString('en-US', { 
        month: 'long', 
        day: 'numeric', 
        year: 'numeric' 
      });
      
      return {
        success: true,
        message_to_patient: `Great! I found ${patient.first_name || args.firstName} ${patient.last_name || args.lastName}, born ${friendlyDob}. What type of appointment would you like to schedule today?`,
        data: {
          found_patients: [{
            id: patient.id,
            firstName: patient.first_name,
            lastName: patient.last_name,
            dob: patientDob
          }],
          patient_exists: true,
          patient_id: patient.id
        }
      };

    } catch (error) {
      console.error(`[findPatient] Error:`, error);
      
      let message = "I'm having trouble accessing patient records right now. Please try again in a moment or contact the office directly.";
      if (error instanceof Error && error.message.includes("401")) {
        message = "There's an authentication issue with the patient system. Please contact the office for assistance.";
      }
      
      return {
        success: false,
        error_code: "NEXHEALTH_API_ERROR",
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me look that up for you...",
    success: "Perfect! I found your information.",
    fail: "I'm having trouble finding that record. Let me help you with that."
  }
};

async function updateCallLogWithPatient(vapiCallId: string, practiceId: string, patientId: string) {
  try {
    const { prisma } = await import("@/lib/prisma");
    await prisma.callLog.upsert({
      where: { vapiCallId },
      create: {
        vapiCallId,
        practiceId,
        callStatus: "TOOL_IN_PROGRESS",
        nexhealthPatientId: patientId,
        callTimestampStart: new Date()
      },
      update: {
        nexhealthPatientId: patientId,
        updatedAt: new Date()
      }
    });
  } catch (error) {
    console.error("[findPatient] Error updating call log:", error);
  }
}

export default findPatientTool;

================
File: lib/tools/bookAppointment.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import { DateTime } from "luxon";

export const bookAppointmentSchema = z.object({
  selectedTime: z.string()
    .min(1)
    .describe(`Extract time patient selected from available options.

Examples: "I'll take 8 AM"  "8:00 AM", "The 2:30 slot"  "2:30 PM", "10 o'clock"  "10:00 AM"

Rules: Include :00/:30 for minutes, include AM/PM, match format presented to patient`),
  patientId: z.string()
    .min(1)
    .describe(`CRITICAL: This MUST be the numeric patient ID (e.g., "381872342") obtained from the successful result of a PREVIOUS 'find_patient_in_ehr' or 'create_new_patient' tool call. 
DO NOT use the patient's name (e.g., "Alex Dan"). 
DO NOT invent an ID. 
If a new patient was just created, use the 'patient_id' provided in the data output of the 'create_new_patient' tool. 
If an existing patient was found, use the 'patient_id' from the 'find_patient_in_ehr' tool.
This ID is essential for linking the appointment to the correct patient record in the EHR.`),
  appointmentTypeId: z.string()
    .min(1)
    .describe("The appointment type ID (e.g., '1014017') from the data.appointment_type_id field of a successful 'find_appointment_type' tool call"),
  requestedDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe("The requested appointment date in YYYY-MM-DD format, typically confirmed after a 'check_available_slots' tool call or directly from user input if a specific date was requested and validated"),
  durationMinutes: z.number()
    .min(1)
    .describe("The duration of the appointment in minutes (e.g., 90) from the data.duration_minutes field of a successful 'find_appointment_type' tool call")
});

const bookAppointmentTool: ToolDefinition<typeof bookAppointmentSchema> = {
  name: "book_appointment",
  description: "Books the actual appointment after the patient has selected a specific time. Use this after showing available slots and getting the patient's time preference.",
  schema: bookAppointmentSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't complete the booking right now. Please contact the office directly to finalize your appointment."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "I need to assign a provider but none are configured. Please contact the office to complete your booking."
      };
    }

    try {
      console.log(`[bookAppointment] Booking appointment for patient ${args.patientId} on ${args.requestedDate} at ${args.selectedTime}`);

      // Validate patient ID before proceeding
      if (!args.patientId || args.patientId === 'null' || args.patientId === 'undefined' || args.patientId === 'new_patient') {
        return {
          success: false,
          error_code: "INVALID_PATIENT_ID",
          message_to_patient: "I need to verify your patient information before booking. Let me help you with that first.",
          details: `Invalid patient ID provided: ${args.patientId}`
        };
      }

      // Validate that patient ID is numeric (NexHealth requirement)
      if (isNaN(parseInt(args.patientId))) {
        return {
          success: false,
          error_code: "INVALID_PATIENT_ID_FORMAT",
          message_to_patient: "There's an issue with your patient record. Please contact the office to complete your booking.",
          details: `Patient ID must be numeric, received: ${args.patientId}`
        };
      }

      // Validate selected time format
      const timePattern = /^(1[0-2]|[1-9]):([0-5][0-9])\s?(AM|PM)$/i;
      if (!timePattern.test(args.selectedTime.trim())) {
      return {
         success: false,
         error_code: "INVALID_TIME_FORMAT",
         message_to_patient: `I didn't quite catch that time. Could you please choose from the available times I mentioned?`
       };
     }

     // Get practice configuration
     const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
     const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

     if (activeProviders.length === 0) {
       return {
         success: false,
         error_code: "NO_ACTIVE_PROVIDERS",
         message_to_patient: "I need to assign a provider but none are available. Please contact the office to complete your booking."
       };
     }

     if (activeOperatories.length === 0) {
       return {
         success: false,
         error_code: "NO_ACTIVE_OPERATORIES",
         message_to_patient: "I need to assign a room but none are available. Please contact the office to complete your booking."
       };
     }

     // Get the first active provider and operatory
     const provider = activeProviders[0];
     const operatory = activeOperatories[0];

     // Convert selected time to proper start_time format
     const { startTime } = parseSelectedTimeToNexHealthFormat(
       args.selectedTime,
       args.requestedDate,
       'America/Chicago' // Default practice timezone
     );

     // Get appointment type name for notes
     const appointmentType = practice.appointmentTypes?.find(
       at => at.nexhealthAppointmentTypeId === args.appointmentTypeId
     );

     // Prepare booking data
     const bookingData = {
       patient_id: parseInt(args.patientId),
       provider_id: parseInt(provider.provider.nexhealthProviderId),
       appointment_type_id: parseInt(args.appointmentTypeId),
       operatory_id: parseInt(operatory.nexhealthOperatoryId),
       start_time: startTime,
       note: appointmentType ? `${appointmentType.name} - Scheduled via LAINE AI Assistant` : "Scheduled via LAINE AI Assistant"
     };

     console.log(`[bookAppointment] Booking data:`, JSON.stringify(bookingData, null, 2));

     // Make the booking API call
     const bookingResponse = await fetchNexhealthAPI(
       '/appointments',
       practice.nexhealthSubdomain,
       {
         location_id: practice.nexhealthLocationId,
         notify_patient: 'false'
       },
       'POST',
       { appt: bookingData }
     );

     console.log(`[bookAppointment] Booking response:`, JSON.stringify(bookingResponse, null, 2));

     // Check if booking was successful
     if (!bookingResponse || bookingResponse.error || !bookingResponse.data) {
       console.error(`[bookAppointment] Booking failed:`, bookingResponse);
       
       // Enhanced error handling for specific booking failures
       let errorMessage = "I wasn't able to complete your booking. Please contact the office directly to schedule your appointment.";
       let errorCode = "BOOKING_FAILED";
       
       if (bookingResponse?.error) {
         const errorString = typeof bookingResponse.error === 'string' ? bookingResponse.error : JSON.stringify(bookingResponse.error);
         
         if (errorString.includes('patient') && errorString.includes('not found')) {
           errorCode = "PATIENT_NOT_FOUND";
           errorMessage = "I couldn't find your patient record in our system. Let me help you create a patient record first.";
         } else if (errorString.includes('appointment_type')) {
           errorCode = "INVALID_APPOINTMENT_TYPE";
           errorMessage = "There's an issue with the appointment type. Let me help you select a different type of appointment.";
         } else if (errorString.includes('provider')) {
           errorCode = "PROVIDER_UNAVAILABLE";
           errorMessage = "The provider is no longer available for this time. Let me show you other available times.";
         } else if (errorString.includes('operatory')) {
           errorCode = "ROOM_UNAVAILABLE";
           errorMessage = "The treatment room is no longer available. Let me check for other available times.";
         }
       }
       
       return {
         success: false,
         error_code: errorCode,
         message_to_patient: errorMessage,
         details: bookingResponse?.error || "Unknown booking error"
       };
     }

     // Update call log with booking information
     await updateCallLogWithBooking(vapiCallId, bookingResponse.data.id, args.requestedDate, startTime);

     // Format confirmation message
     const appointmentTypeName = appointmentType?.name || "appointment";
     const formattedDate = formatDate(args.requestedDate);
     const formattedTime = args.selectedTime;
     const providerName = provider.provider.firstName 
       ? `${provider.provider.firstName} ${provider.provider.lastName}`
       : `Dr. ${provider.provider.lastName}`;

     return {
       success: true,
       message_to_patient: `Excellent! I've successfully booked your ${appointmentTypeName} for ${formattedDate} at ${formattedTime} with ${providerName}. You'll receive a confirmation text shortly. Is there anything else I can help you with today?`,
       data: {
         appointment_id: bookingResponse.data.id,
         confirmation_number: bookingResponse.data.id,
         appointment_date: args.requestedDate,
         appointment_time: args.selectedTime,
         appointment_type: appointmentTypeName,
         provider_name: providerName,
         location_name: practice.name,
         booking_source: "laine_ai"
       }
     };

   } catch (error) {
     console.error(`[bookAppointment] Error:`, error);
     
     let message = "I'm having trouble completing your booking right now. Please contact the office directly to schedule your appointment.";
     if (error instanceof Error) {
       if (error.message.includes("401")) {
         message = "There's an authentication issue with the booking system. Please contact the office for assistance.";
       } else if (error.message.includes("conflict") || error.message.includes("409")) {
         message = "It looks like that time slot just became unavailable. Would you like me to show you other available times?";
       }
     }
     
     return {
       success: false,
       error_code: "BOOKING_ERROR",
       message_to_patient: message,
       details: error instanceof Error ? error.message : "Unknown error"
     };
   }
 },

 messages: {
   start: "Perfect! Let me book that appointment for you...",
   success: "Excellent! Your appointment has been confirmed.",
   fail: "I'm having trouble booking that time. Let me see what else is available."
 }
};

/**
* Convert patient's selected time to NexHealth API format with proper timezone handling
*/
function parseSelectedTimeToNexHealthFormat(
 selectedTime: string,
 requestedDate: string,
 practiceTimezone: string = 'America/Chicago'
): { startTime: string } {
 // Parse the selected time and date in the practice's timezone
 const localDateTime = DateTime.fromFormat(
   `${requestedDate} ${selectedTime}`,
   'yyyy-MM-dd h:mm a',
   { zone: practiceTimezone }
 );

 if (!localDateTime.isValid) {
   throw new Error(`Invalid date/time format: ${requestedDate} ${selectedTime}. Error: ${localDateTime.invalidReason}`);
 }

 // Convert to UTC and format for NexHealth API
 const startTime = localDateTime.toUTC().toISO({ suppressMilliseconds: true });

 if (!startTime) {
   throw new Error(`Failed to convert to UTC: ${requestedDate} ${selectedTime}`);
 }

 console.log(`[timezone] Converting ${selectedTime} on ${requestedDate} in ${practiceTimezone} to UTC: ${startTime}`);

 return { startTime };
}

/**
* Format date for patient-friendly display
*/
function formatDate(dateString: string): string {
 try {
   const date = new Date(dateString + 'T00:00:00');
   return date.toLocaleDateString('en-US', {
     weekday: 'long',
     month: 'long',
     day: 'numeric'
   });
 } catch {
   return dateString;
 }
}

/**
* Update call log with booking information
*/
async function updateCallLogWithBooking(
 vapiCallId: string,
 appointmentId: string,
 appointmentDate: string,
 appointmentTime: string
) {
 try {
   const { prisma } = await import("@/lib/prisma");
   await prisma.callLog.update({
     where: { vapiCallId },
     data: {
       callStatus: "APPOINTMENT_BOOKED",
       bookedAppointmentNexhealthId: appointmentId,
       summary: `Appointment booked for ${appointmentDate} at ${appointmentTime}`,
       updatedAt: new Date()
     }
   });
 } catch (error) {
   console.error("[bookAppointment] Error updating call log:", error);
 }
}

export default bookAppointmentTool;

================
File: lib/tools/index.ts
================
import { ToolDefinition, VapiToolSchema, VapiToolFunction } from "./types";
import { zodToJsonSchema } from "zod-to-json-schema";

// Import all tools
import findPatientTool from "./findPatient";
import findAppointmentTypeTool from "./findAppointmentType";
import checkAvailableSlotsTool from "./checkAvailableSlots";
import bookAppointmentTool from "./bookAppointment";
import createNewPatientTool from "./createNewPatient";
import getPracticeDetailsTool from "./getPracticeDetails";
import checkInsuranceParticipationTool from "./checkInsuranceParticipation";
import getServiceCostEstimateTool from "./getServiceCostEstimate";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const tools: ToolDefinition<any>[] = [
  findPatientTool,
  findAppointmentTypeTool,
  checkAvailableSlotsTool,
  bookAppointmentTool,
  createNewPatientTool,
  getPracticeDetailsTool,
  checkInsuranceParticipationTool,
  getServiceCostEstimateTool
];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function getToolByName(name: string): ToolDefinition<any> | undefined {
  return tools.find(t => t.name === name);
}

// This function builds the array for VAPI's `model.tools[]`
export function buildVapiTools(appBaseUrl: string): VapiToolSchema[] {
  console.log(`Building VAPI tools for ${tools.length} registered tools`);
  
  return tools.map(tool => {
    // Generate JSON schema without $schema property
    const schema = zodToJsonSchema(tool.schema, { 
      target: "jsonSchema7", 
      $refStrategy: "none" 
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $schema, ...parameters } = schema;
    
    const vapiToolFunction: VapiToolFunction = {
      name: tool.name,
      description: tool.description,
      parameters
    };
    
    const vapiTool: VapiToolSchema = {
      type: "function",
      async: tool.async ?? false,
      function: vapiToolFunction,
      server: { 
        url: `${appBaseUrl}/api/vapi/tool-calls`
      }
    };

    // Add tool-specific messages if defined
    if (tool.messages) {
      vapiTool.messages = [
        tool.messages.start ? { type: "request-start", content: tool.messages.start } : null,
        tool.messages.delay ? { type: "request-response-delayed", content: tool.messages.delay, timingMilliseconds: 2000 } : null,
        tool.messages.success ? { type: "request-complete", content: tool.messages.success } : null,
        tool.messages.fail ? { type: "request-failed", content: tool.messages.fail } : null,
      ].filter(Boolean) as VapiToolSchema["messages"];
    }
    
    console.log(`Built VAPI tool: ${tool.name} -> ${vapiTool.server.url}`);
    return vapiTool;
  });
}

// Export individual tool schemas for validation
export { findPatientSchema } from "./findPatient";
export { findAppointmentTypeSchema } from "./findAppointmentType";
export { checkAvailableSlotsSchema } from "./checkAvailableSlots";
export { bookAppointmentSchema } from "./bookAppointment";
export { createNewPatientSchema } from "./createNewPatient";
export { getPracticeDetailsSchema } from "./getPracticeDetails";
export { checkInsuranceParticipationSchema } from "./checkInsuranceParticipation";
export { getServiceCostEstimateSchema } from "./getServiceCostEstimate";

================
File: app/api/vapi/tool-calls/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getToolByName } from "@/lib/tools";
import { prisma } from "@/lib/prisma";
import { ToolExecutionContext, ToolDefinition } from "@/lib/tools/types";
import { getErrorCode, getPatientMessage } from "@/lib/utils/error-messages";

// Type for VAPI payload (flexible to handle various structures)
interface VapiPayload {
  message: {
    type: string;
    call: {
      id: string;
      assistantId?: string;
      assistant?: {
        id?: string;
        [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
      };
      [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    assistant?: {
      id?: string;
      [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    toolCallList?: any[]; // eslint-disable-line @typescript-eslint/no-explicit-any
    [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
  };
}

// Enhanced function to extract assistant ID with strict validation
function extractAssistantId(payload: VapiPayload): string {
  const { message } = payload;
  
  console.log("=== Assistant ID Extraction Debug ===");
  console.log("Call object keys:", Object.keys(message.call || {}));
  console.log("Assistant object keys:", Object.keys(message.assistant || {}));
  
  // Check if VAPI is sending assistant ID in different locations
  const assistantId = message.call?.assistantId || 
                     message.assistant?.id ||
                     message.call?.assistant?.id;
  
  if (!assistantId) {
    // For VAPI tool call payloads, assistant ID is often not included
    // This is normal behavior, not a critical error
    console.log(" No assistant ID found in VAPI tool call payload (this is normal)");
    console.log("Payload structure:", JSON.stringify({
      call: Object.keys(message.call || {}),
      assistant: Object.keys(message.assistant || {}),
      assistantName: message.assistant?.name || message.call?.assistant?.name
    }, null, 2));
    
    // Use assistant name as fallback (standard for VAPI tool calls)
    const assistantName = message.assistant?.name || message.call?.assistant?.name;
    if (assistantName && assistantName.includes(" - Laine")) {
      console.log(" Using assistant name for practice lookup:", assistantName);
      return assistantName; // This will be handled differently in practice lookup
    }
    
    throw new Error("Assistant identification is required for practice lookup");
  }
  
  console.log(" Found assistant ID:", assistantId);
  return assistantId;
}

// Simplified practice lookup with strict validation - now handles assistant name fallback
async function findPracticeByAssistantId(assistantIdOrName: string) {
  console.log("=== Practice Lookup Debug ===");
  console.log("Assistant ID or Name:", assistantIdOrName);
  
  try {
    let practice = null;
    
    // First try to find by assistant ID (preferred method)
    const assistantConfig = await prisma.practiceAssistantConfig.findUnique({
      where: { vapiAssistantId: assistantIdOrName },
      include: { 
        practice: true
      }
    });
    
    if (assistantConfig) {
      practice = assistantConfig.practice;
      console.log(" Found practice by assistant ID:", practice.id);
    }
    
    // If not found and looks like an assistant name, try to find by Royal Oak or subdomain
    if (!practice && (assistantIdOrName.includes("Laine") || assistantIdOrName.includes("Practice"))) {
      console.log(" Attempting practice lookup by assistant name:", assistantIdOrName);
      
      const config = await prisma.practiceAssistantConfig.findFirst({
        where: { 
          practice: {
            OR: [
              { name: { contains: "Royal Oak" } },
              { nexhealthSubdomain: "xyz" } // Fallback to known subdomain
            ]
          }
        },
        include: { practice: true }
      });
      
      if (config) {
        practice = config.practice;
        console.log(` Found practice by pattern matching:`, practice.id);
        console.log(`   Pattern used: Looking for Royal Oak or xyz subdomain`);
      }
      
      // If still not found but this looks like a Laine assistant, try fallback to first practice
      if (!practice && (assistantIdOrName.includes("Laine") || assistantIdOrName.includes("Practice"))) {
        console.log(" No exact match found, trying first available practice as fallback");
        const fallbackConfig = await prisma.practiceAssistantConfig.findFirst({
          include: { practice: true }
        });
        
        if (fallbackConfig) {
          practice = fallbackConfig.practice;
          console.log(` Using fallback practice:`, practice.id);
          console.log(`   Note: This should be temporary - assistant name should be fixed`);
        }
      }
    }
    
    if (!practice) {
      console.log(" No practice found for assistant ID/name:", assistantIdOrName);
      return null;
    }
    
    console.log(" Successfully found practice:", practice.id);
    return await fetchPracticeWithSchedulingData(practice.id);
    
  } catch (error) {
    console.error(" Error in practice lookup:", error);
    return null;
  }
}

// Separate function to fetch practice with scheduling data
async function fetchPracticeWithSchedulingData(practiceId: string) {
  try {
    const practice = await prisma.practice.findUnique({ 
      where: { id: practiceId },
      include: {
        appointmentTypes: true,
        savedProviders: {
          where: { isActive: true },
          include: {
            provider: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                nexhealthProviderId: true
              }
            }
          }
        },
        savedOperatories: {
          where: { isActive: true }
        }
      }
    });
    
    if (!practice) {
      console.error(` Practice not found: ${practiceId}`);
      return null;
    }
    
    console.log(" Loaded practice with scheduling data:", {
      id: practice.id,
      name: practice.name,
      appointmentTypes: practice.appointmentTypes.length,
      savedProviders: practice.savedProviders.length,
      savedOperatories: practice.savedOperatories.length
    });
    
    return practice;
  } catch (error) {
    console.error(" Error fetching practice with scheduling data:", error);
    return null;
  }
}

// Enhanced tool name extraction function
function extractToolName(toolCall: any): string | null { // eslint-disable-line @typescript-eslint/no-explicit-any
  // Log the tool call structure for debugging
  console.log("=== Tool Call Structure Debug ===");
  console.log("Tool call keys:", Object.keys(toolCall));
  console.log("Tool call object:", JSON.stringify(toolCall, null, 2));
  
  // Method 1: Check function.name (most common)
  if (toolCall.function && typeof toolCall.function === 'object' && toolCall.function.name) {
    console.log(" Found tool name in function.name:", toolCall.function.name);
    return toolCall.function.name;
  }
  
  // Method 2: Check direct name property
  if (toolCall.name && typeof toolCall.name === 'string') {
    console.log(" Found tool name in name:", toolCall.name);
    return toolCall.name;
  }
  
  // Method 3: Check if function is a string (edge case)
  if (typeof toolCall.function === 'string') {
    console.log(" Found tool name as string in function:", toolCall.function);
    return toolCall.function;
  }
  
  console.error(" Unable to extract tool name from tool call");
  console.error("Available fields:", {
    hasFunction: !!toolCall.function,
    functionType: typeof toolCall.function,
    functionKeys: toolCall.function ? Object.keys(toolCall.function) : null,
    hasName: !!toolCall.name,
    nameType: typeof toolCall.name
  });
  
  return null;
}

// Enhanced tool call ID extraction function
function extractToolCallId(toolCall: any): string { // eslint-disable-line @typescript-eslint/no-explicit-any
  // Method 1: Check id property
  if (toolCall.id && typeof toolCall.id === 'string') {
    console.log(" Found tool call ID in id:", toolCall.id);
    return toolCall.id;
  }
  
  // Method 2: Check toolCallId property
  if (toolCall.toolCallId && typeof toolCall.toolCallId === 'string') {
    console.log(" Found tool call ID in toolCallId:", toolCall.toolCallId);
    return toolCall.toolCallId;
  }
  
  // Method 3: Generate fallback ID
  const fallbackId = `fallback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  console.warn(" No tool call ID found, using fallback:", fallbackId);
  
  return fallbackId;
}

// Enhanced tool call argument extraction
function extractToolCallArguments(toolCall: any): Record<string, unknown> { // eslint-disable-line @typescript-eslint/no-explicit-any
  console.log("=== Tool Call Arguments Extraction ===");
  console.log("Tool call structure:", Object.keys(toolCall));
  
  // Handle multiple possible argument formats from VAPI
  if (typeof toolCall.arguments === 'string') {
    try {
      const parsed = JSON.parse(toolCall.arguments);
      console.log(" Parsed arguments from string:", parsed);
      return parsed;
    } catch (error) {
      console.error(" Failed to parse tool call arguments as JSON string:", error);
      return {};
    }
  }
  
  if (typeof toolCall.arguments === 'object' && toolCall.arguments !== null) {
    console.log(" Using arguments object directly:", toolCall.arguments);
    return toolCall.arguments;
  }
  
  // Check if arguments are in toolCall.function.arguments
  if (toolCall.function?.arguments) {
    if (typeof toolCall.function.arguments === 'string') {
      try {
        const parsed = JSON.parse(toolCall.function.arguments);
        console.log(" Parsed function arguments from string:", parsed);
        return parsed;
      } catch (error) {
        console.error(" Failed to parse function arguments as JSON string:", error);
        return {};
      }
    }
    
    if (typeof toolCall.function.arguments === 'object') {
      console.log(" Using function arguments object:", toolCall.function.arguments);
      return toolCall.function.arguments;
    }
  }
  
  console.error(" Unable to extract arguments from tool call:", toolCall);
  return {};
}

async function executeToolSafely(
  // Use more flexible typing to avoid constraint issues
  tool: ToolDefinition<any>, // eslint-disable-line @typescript-eslint/no-explicit-any
  toolCall: any, // eslint-disable-line @typescript-eslint/no-explicit-any 
  context: ToolExecutionContext
) {
  try {
    const parsedArgs = extractToolCallArguments(toolCall);
    const startTime = Date.now();
    
    console.log(`Executing tool: ${tool.name} for practice ${context.practice.id} with args:`, parsedArgs);
    
    // Pre-validation for create_new_patient to prevent premature calls
    if (tool.name === 'create_new_patient') {
      const preValidationResult = validateCreateNewPatientArgs(parsedArgs);
      if (!preValidationResult.isValid) {
        console.log(`[${tool.name}] Pre-validation failed:`, preValidationResult.reason);
        
        const preValidationError = {
          success: false,
          error_code: preValidationResult.errorCode,
          message_to_patient: preValidationResult.message,
          details: preValidationResult.reason
        };
        
        // Log the pre-validation failure
        await logToolExecution(
          context,
          tool.name,
          parsedArgs,
          preValidationError,
          false,
          preValidationResult.reason
        );
        
        return preValidationError;
      }
    }
    
    // Validate arguments with tool schema
    const validatedArgs = tool.schema.parse(parsedArgs);
    
    const toolResult = await tool.run({
      args: validatedArgs,
      context
    });
    
    const executionTime = Date.now() - startTime;
    
    // Log successful execution
    await logToolExecution(
      context,
      tool.name,
      validatedArgs,
      toolResult,
      true,
      undefined,
      executionTime
    );
    
    return toolResult;
  } catch (error) {
    console.error(`Error executing tool ${tool.name}:`, error);
    
    const errorResult = {
      success: false,
      error_code: getErrorCode(error, tool.name),
      message_to_patient: getPatientMessage(getErrorCode(error, tool.name)),
      details: error instanceof Error ? error.message : "Unknown error"
    };
    
    // Log failed execution
    await logToolExecution(
      context,
      tool.name,
      toolCall.arguments || toolCall.function?.arguments || {},
      errorResult,
      false,
      error instanceof Error ? error.message : "Unknown error"
    );
    
    return errorResult;
  }
}

/**
 * Pre-validation for create_new_patient to prevent premature tool calls
 */
function validateCreateNewPatientArgs(args: any): { // eslint-disable-line @typescript-eslint/no-explicit-any
  isValid: boolean;
  errorCode?: string;
  message?: string;
  reason?: string;
} {
  // Check if any required field is missing or empty
  const requiredFields = ['firstName', 'lastName', 'dateOfBirth', 'phone', 'email'];
  const missingFields = [];
  
  for (const field of requiredFields) {
    if (!args[field] || typeof args[field] !== 'string' || args[field].trim().length === 0) {
      missingFields.push(field);
    }
  }
  
  // If multiple fields are missing, provide comprehensive guidance
  if (missingFields.length > 1) {
    const missingFieldsStr = missingFields.join(', ');
    let message = "";
    
    if (missingFields.includes('firstName') || missingFields.includes('lastName') || missingFields.includes('dateOfBirth')) {
      message = "I need to collect some information to create your patient record. Could you spell your first and last name letter by letter, then give me your date of birth?";
    } else if (missingFields.includes('phone') && missingFields.includes('email')) {
      message = "I still need your phone number and email address to finish creating your patient record. What's your phone number?";
    } else {
      message = getMissingFieldMessage(missingFields[0]);
    }
    
    return {
      isValid: false,
      errorCode: getMissingFieldErrorCode(missingFields[0]),
      message,
      reason: `Multiple missing fields: ${missingFieldsStr}`
    };
  }
  
  // Single field missing
  if (missingFields.length === 1) {
    const field = missingFields[0];
    return {
      isValid: false,
      errorCode: getMissingFieldErrorCode(field),
      message: getMissingFieldMessage(field),
      reason: `Missing or empty ${field}: "${args[field]}"`
    };
  }
  
  // Additional validation for phone (minimum 10 digits)
  const phoneDigits = args.phone.replace(/\D/g, '');
  if (phoneDigits.length < 10) {
    return {
      isValid: false,
      errorCode: 'MISSING_PHONE',
      message: "I need your phone number to create your patient record. What's your phone number?",
      reason: `Phone number too short: "${args.phone}" (${phoneDigits.length} digits)`
    };
  }
  
  // Additional validation for email (basic @ check)
  if (!args.email.includes('@') || !args.email.includes('.')) {
    return {
      isValid: false,
      errorCode: 'MISSING_EMAIL',
      message: "I need your email address to create your patient record. What's your email address?",
      reason: `Invalid email format: "${args.email}"`
    };
  }
  
  return { isValid: true };
}

/**
 * Get error code for missing field
 */
function getMissingFieldErrorCode(field: string): string {
  switch (field) {
    case 'firstName': return 'MISSING_FIRST_NAME';
    case 'lastName': return 'MISSING_LAST_NAME';
    case 'dateOfBirth': return 'INVALID_DATE_OF_BIRTH';
    case 'phone': return 'MISSING_PHONE';
    case 'email': return 'MISSING_EMAIL';
    default: return 'VALIDATION_ERROR';
  }
}

/**
 * Get error message for missing field
 */
function getMissingFieldMessage(field: string): string {
  switch (field) {
    case 'firstName': 
      return "I need your first name to create your patient record. Could you tell me your first name?";
    case 'lastName': 
      return "I need your last name to create your patient record. Could you tell me your last name?";
    case 'dateOfBirth': 
      return "I need your date of birth to create your patient record. Could you tell me your date of birth?";
    case 'phone': 
      return "I need your phone number to create your patient record. What's your phone number?";
    case 'email': 
      return "I need your email address to create your patient record. What's your email address?";
    default: 
      return "I need some additional information to complete your registration.";
  }
}

async function logToolExecution(
  context: ToolExecutionContext,
  toolName: string,
  arguments_: unknown,
  result: unknown,
  success: boolean,
  error?: string,
  executionTimeMs?: number
) {
  try {
    await prisma.toolLog.create({
      data: {
        practiceId: context.practice.id,
        vapiCallId: context.vapiCallId,
        toolName,
        toolCallId: context.toolCallId,
        arguments: JSON.stringify(arguments_),
        result: JSON.stringify(result),
        success,
        error,
        executionTimeMs: executionTimeMs || 0
      }
    });
  } catch (logError) {
    console.error("Error logging tool execution:", logError);
  }
}

export async function POST(req: NextRequest) {
  console.log("=== VAPI Centralized Tool Handler ===");
  
  try {
    // TODO: Implement request verification when VAPI provides signing
    
    const payload: VapiPayload = await req.json();
    console.log("VAPI payload:", JSON.stringify(payload, null, 2));
    
    // Validate payload structure
    if (!payload.message || payload.message.type !== "tool-calls") {
      console.error("Invalid payload type:", payload.message?.type);
      return NextResponse.json({ error: "Invalid payload type" }, { status: 400 });
    }
    
    const { message } = payload;
    const vapiCallId = message.call.id;
    
    let assistantId: string;
    let practice: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    
    try {
      assistantId = extractAssistantId(payload);
      practice = await findPracticeByAssistantId(assistantId);
      
      if (!practice) {
        throw new Error(`No practice found for assistant ID/name: ${assistantId}`);
      }
    } catch (error) {
      console.error("Assistant ID extraction or practice lookup failed:", error);
      
      // Create detailed error for debugging
      const debugInfo = {
        error: error instanceof Error ? error.message : "Unknown error",
        callId: vapiCallId,
        assistantName: (message.assistant as any)?.name, // eslint-disable-line @typescript-eslint/no-explicit-any
        availableFields: {
          call: Object.keys(message.call || {}),
          assistant: Object.keys(message.assistant || {})
        }
      };
      
      console.error("Debug info:", JSON.stringify(debugInfo, null, 2));
      
      // Return error results for all tool calls
      const toolCalls = message.toolCallList || message.toolCalls || [];
      const errorResults = toolCalls.map((toolCall: any) => ({ // eslint-disable-line @typescript-eslint/no-explicit-any
        toolCallId: extractToolCallId(toolCall),
        result: JSON.stringify({
          success: false,
          error_code: "ASSISTANT_ID_OR_PRACTICE_ERROR", 
          message_to_patient: "I'm having trouble connecting to your practice's system. Please try again or contact the office directly.",
          debug_info: debugInfo
        })
      }));
      
      return NextResponse.json({ results: errorResults });
    }
    
    // Update call log status
    try {
      await prisma.callLog.upsert({
        where: { vapiCallId },
        create: {
          vapiCallId,
          practiceId: practice.id,
          callStatus: "TOOL_IN_PROGRESS",
          callTimestampStart: new Date()
        },
        update: {
          callStatus: "TOOL_IN_PROGRESS",
          updatedAt: new Date()
        }
      });
    } catch (dbError) {
      console.error("Error updating CallLog:", dbError);
    }
    
    // Process all tool calls
    const results = [];
    
    console.log(`Processing ${(message.toolCallList || []).length} tool call(s)`);
    
    for (let i = 0; i < (message.toolCallList || []).length; i++) {
      const toolCall = (message.toolCallList || [])[i];
      
      console.log(`=== Processing Tool Call ${i + 1}/${(message.toolCallList || []).length} ===`);
     
      // Enhanced tool name extraction
      const toolName = extractToolName(toolCall);
      const toolCallId = extractToolCallId(toolCall);
      
      console.log(`Tool: ${toolName}, ID: ${toolCallId}`);
     
      if (!toolName) {
        console.error(` Unable to extract tool name from tool call ${i + 1}`);
        results.push({
          toolCallId,
          result: JSON.stringify({
            success: false,
            error_code: "INVALID_TOOL_CALL",
            message_to_patient: getPatientMessage("VALIDATION_ERROR"),
            debug_info: {
              toolCallIndex: i,
              availableFields: Object.keys(toolCall),
              toolCallStructure: toolCall
            }
          })
        });
        continue;
      }
      
      const tool = getToolByName(toolName);
      
      if (!tool) {
        console.error(` Unknown tool: ${toolName}`);
        results.push({
          toolCallId,
          result: JSON.stringify({
            success: false,
            error_code: "SYSTEM_ERROR",
            message_to_patient: getPatientMessage("SYSTEM_ERROR"),
            debug_info: {
              requestedTool: toolName,
              toolCallIndex: i
            }
          })
        });
        continue;
      }
      
      console.log(` Found tool: ${tool.name}`);
      
      // Create execution context
      const context: ToolExecutionContext = {
        practice,
        vapiCallId,
        toolCallId,
        assistantId: assistantId || "unknown"
      };
      
      const toolResult = await executeToolSafely(tool, toolCall, context);
      
      results.push({
        toolCallId,
        result: JSON.stringify(toolResult)
      });
      
      console.log(` Tool ${toolName} completed. Success: ${toolResult.success}`);
    }
    
    console.log("Sending results to VAPI:", JSON.stringify({ results }));
    return NextResponse.json({ results });
     
  } catch (error) {
    console.error("Error in centralized tool handler:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}

================
File: lib/nexhealth.ts
================
import { prisma } from "@/lib/prisma";
import { addSeconds } from 'date-fns';

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number; // NexHealth uses 'minutes' not 'duration'
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

interface NexHealthOperatory {
  id: number;
  name: string;
  location_id: number;
  active: boolean;
}

const NEXHEALTH_API_BASE_URL = process.env.NEXHEALTH_API_BASE_URL!;
const MASTER_NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY!; // The master key

const TOKEN_CACHE_ID = "singleton"; // Fixed ID for the single token entry
const TOKEN_EXPIRY_BUFFER_SECONDS = 300; // 5 minutes buffer
const DEFAULT_TOKEN_LIFETIME_SECONDS = 55 * 60; // 55 minutes (safe for 1-hour tokens)

async function fetchNewBearerToken(): Promise<{ accessToken: string; expiresAt: Date }> {
  if (!MASTER_NEXHEALTH_API_KEY) {
    throw new Error("NEXHEALTH_API_KEY is not configured in environment variables.");
  }

  const authUrl = `${NEXHEALTH_API_BASE_URL}/authenticates`;
  console.log("Fetching new NexHealth bearer token...");

  try {
    const response = await fetch(authUrl, {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.Nexhealth+json;version=2',
        // NexHealth expects the raw master key for /authenticates endpoint
        'Authorization': MASTER_NEXHEALTH_API_KEY,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("Failed to fetch NexHealth bearer token:", response.status, errorBody);
      throw new Error(`NexHealth Authentication failed: ${response.status} - ${errorBody}`);
    }

    const result = await response.json();
    
    if (!result.data || !result.data.token) {
      console.error("NexHealth /authenticates response missing token:", result);
      throw new Error("Invalid token response from NexHealth /authenticates");
    }

    const accessToken = result.data.token;
    const now = new Date();
    
    // If NexHealth provides expiry in response, use it. Otherwise, use default lifetime.
    // Most JWT tokens have 1-hour validity, we use 55 minutes to be safe
    let expiresAt: Date;
    
    if (result.data.exp) {
      // If exp is provided as UNIX timestamp (seconds)
      expiresAt = new Date(result.data.exp * 1000);
    } else {
      // Default to 55 minutes from now
      expiresAt = addSeconds(now, DEFAULT_TOKEN_LIFETIME_SECONDS);
    }

    console.log(`New NexHealth token expires at: ${expiresAt.toISOString()}`);

    // Cache the token in database
    await prisma.nexhealthTokenCache.upsert({
      where: { id: TOKEN_CACHE_ID },
      update: { accessToken, expiresAt },
      create: { id: TOKEN_CACHE_ID, accessToken, expiresAt },
    });

    return { accessToken, expiresAt };
  } catch (error) {
    console.error('Error fetching NexHealth bearer token:', error);
    throw error;
  }
}

export async function getNexhealthBearerToken(): Promise<string> {
  try {
    // Check for cached token
    const cachedToken = await prisma.nexhealthTokenCache.findUnique({
      where: { id: TOKEN_CACHE_ID },
    });

    if (cachedToken) {
      const now = new Date();
      const tokenStillValidUntil = addSeconds(now, TOKEN_EXPIRY_BUFFER_SECONDS);
      
      if (cachedToken.expiresAt > tokenStillValidUntil) {
        console.log("Using cached NexHealth bearer token.");
        return cachedToken.accessToken;
      }
      console.log("Cached NexHealth token expired or nearing expiry.");
    } else {
      console.log("No cached NexHealth token found.");
    }

    // Fetch new token if none cached or expired
    const { accessToken } = await fetchNewBearerToken();
    return accessToken;
  } catch (error) {
    console.error('Error getting NexHealth bearer token:', error);
    throw error;
  }
}

// Export the generic API function for use in tools and other modules
export async function fetchNexhealthAPI(
  path: string, // e.g., "/appointment_types"
  subdomain: string, // Practice-specific subdomain
  params?: Record<string, string | number | string[]>,
  method: string = 'GET',
  body?: unknown
) {
  // Get valid bearer token
  const bearerToken = await getNexhealthBearerToken();
  
  const url = new URL(`${NEXHEALTH_API_BASE_URL}${path}`);
  
  // Add subdomain for data API calls (not for /authenticates)
  if (path !== '/authenticates' && !params?.subdomain) {
    url.searchParams.append('subdomain', subdomain);
  }
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v.toString()));
      } else {
        url.searchParams.append(key, value.toString());
      }
    });
  }

  const options: RequestInit = {
    method,
    headers: {
      'Accept': 'application/vnd.Nexhealth+json;version=2',
      'Authorization': `Bearer ${bearerToken}`, // Use bearer token for data APIs
      'Content-Type': 'application/json',
    },
  };

  if (body && method !== 'GET') {
    options.body = JSON.stringify(body);
  }

  console.log(`Fetching from NexHealth: ${method} ${url.toString()} for subdomain ${subdomain}`);

  try {
    const response = await fetch(url.toString(), options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`NexHealth API error (${response.status}):`, errorText);
      
      // If we get 401, the token might be invalid - clear cache and retry once
      if (response.status === 401) {
        console.log("Got 401, clearing token cache and retrying...");
        await prisma.nexhealthTokenCache.deleteMany({
          where: { id: TOKEN_CACHE_ID }
        });
        
        // Retry with fresh token (recursive call - but only once due to cache clear)
        return fetchNexhealthAPI(path, subdomain, params, method, body);
      }
      
      throw new Error(`NexHealth API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('NexHealth API error:', error);
    throw error;
  }
}

export async function getAppointmentTypes(subdomain: string, locationId: string): Promise<NexHealthAppointmentType[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    { location_id: locationId }
  );
  
  console.log("Raw NexHealth appointment_types response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let appointmentTypes = null;
  
  if (Array.isArray(data)) {
    appointmentTypes = data;
  } else if (data?.data?.appointment_types && Array.isArray(data.data.appointment_types)) {
    appointmentTypes = data.data.appointment_types;
  } else if (data?.appointment_types && Array.isArray(data.appointment_types)) {
    appointmentTypes = data.appointment_types;
  } else if (data?.data && Array.isArray(data.data)) {
    appointmentTypes = data.data;
  } else {
    console.warn("Unexpected appointment_types response structure:", data);
    appointmentTypes = [];
  }
  
  console.log(`Parsed ${appointmentTypes.length} appointment types`);
  return appointmentTypes;
}

export async function getProviders(subdomain: string, locationId: string): Promise<NexHealthProvider[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/providers',
    subdomain,
    { location_id: locationId, inactive: 'false', page: '1', per_page: '300' }
  );
  
  console.log("Raw NexHealth providers response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let providers = null;
  
  if (Array.isArray(data)) {
    providers = data;
  } else if (data?.data?.providers && Array.isArray(data.data.providers)) {
    providers = data.data.providers;
  } else if (data?.providers && Array.isArray(data.providers)) {
    providers = data.providers;
  } else if (data?.data && Array.isArray(data.data)) {
    providers = data.data;
  } else {
    console.warn("Unexpected providers response structure:", data);
    providers = [];
  }
  
  console.log(`Parsed ${providers.length} providers`);
  return providers;
}

export async function getOperatories(subdomain: string, locationId: string): Promise<NexHealthOperatory[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/operatories',
    subdomain,
    { location_id: locationId, page: '1', per_page: '300' }
  );
  
  console.log("Raw NexHealth operatories response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let operatories = null;
  
  if (Array.isArray(data)) {
    operatories = data;
  } else if (data?.data?.operatories && Array.isArray(data.data.operatories)) {
    operatories = data.data.operatories;
  } else if (data?.operatories && Array.isArray(data.operatories)) {
    operatories = data.operatories;
  } else if (data?.data && Array.isArray(data.data)) {
    operatories = data.data;
  } else {
    console.warn("Unexpected operatories response structure:", data);
    operatories = [];
  }
  
  console.log(`Parsed ${operatories.length} operatories`);
  return operatories.filter((op: NexHealthOperatory) => op.active !== false);
}

// Availability-related interfaces and functions
interface NexHealthAvailability {
  id: number;
  provider_id: number;
  location_id: number;
  operatory_id?: number;
  begin_time: string;
  end_time: string;
  days: string[];
  specific_date?: string;
  custom_recurrence?: {
    num: number;
    unit: string;
    ref: string;
  };
  tz_offset: string;
  active: boolean;
  synced: boolean;
  appointment_types: Array<{
    id: number;
    name: string;
    parent_type: string;
    parent_id: number;
    minutes: number;
    bookable_online: boolean;
  }>;
}

interface CreateAvailabilityData {
  provider_id: number;
  operatory_id?: number;
  days: string[];
  begin_time: string;
  end_time: string;
  appointment_type_ids: number[];
  active?: boolean;
}

interface UpdateAvailabilityData {
  provider_id?: number;
  operatory_id?: number;
  days?: string[];
  begin_time?: string;
  end_time?: string;
  appointment_type_ids?: number[];
  active?: boolean;
}

export async function createNexhealthAvailability(
  subdomain: string, 
  locationId: string, 
  availabilityData: CreateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !locationId) {
    throw new Error("Subdomain and Location ID are required.");
  }

  const data = await fetchNexhealthAPI(
    '/availabilities',
    subdomain,
    { location_id: locationId },
    'POST',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth create availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected create availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth create availability");
  }

  console.log(`Created availability with ID: ${availability.id}`);
  return availability;
}

export async function updateNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string,
  availabilityData: UpdateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !nexhealthAvailabilityId) {
    throw new Error("Subdomain and availability ID are required.");
  }

  const data = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    {},
    'PATCH',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth update availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected update availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth update availability");
  }

  console.log(`Updated availability with ID: ${availability.id}`);
  return availability;
}

export async function deleteNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string
): Promise<void> {
  const response = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    undefined,
    'DELETE'
  );
  
  // For DELETE operations, expect a 204 or successful response with no data
  console.log(`Deleted NexHealth availability ${nexhealthAvailabilityId}:`, response);
}

// Appointment Type CRUD Functions

interface CreateAppointmentTypeData {
  name: string;
  minutes: number;
  bookable_online?: boolean;
  parent_type: "Location" | "Institution";
  parent_id: string | number;
  emr_appt_descriptor_ids?: number[];
}

interface UpdateAppointmentTypeData {
  name?: string;
  minutes?: number;
  bookable_online?: boolean;
  parent_type?: "Location" | "Institution";
  parent_id?: string | number;
  emr_appt_descriptor_ids?: number[];
}

export async function createNexhealthAppointmentType(
  subdomain: string,
  locationId: string,
  apptTypeData: CreateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      name: apptTypeData.name,
      minutes: apptTypeData.minutes,
      bookable_online: apptTypeData.bookable_online ?? true,
      parent_type: apptTypeData.parent_type,
      parent_id: apptTypeData.parent_id,
      ...(apptTypeData.emr_appt_descriptor_ids && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    undefined,
    'POST',
    requestBody
  );

  console.log('Created NexHealth appointment type:', response);
  return response.data;
}

export async function updateNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId: string,
  apptTypeData: UpdateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      ...(apptTypeData.name !== undefined && { name: apptTypeData.name }),
      ...(apptTypeData.minutes !== undefined && { minutes: apptTypeData.minutes }),
      ...(apptTypeData.bookable_online !== undefined && { bookable_online: apptTypeData.bookable_online }),
      ...(apptTypeData.parent_type !== undefined && { parent_type: apptTypeData.parent_type }),
      ...(apptTypeData.parent_id !== undefined && { parent_id: apptTypeData.parent_id }),
      ...(apptTypeData.emr_appt_descriptor_ids !== undefined && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    undefined,
    'PATCH',
    requestBody
  );

  console.log(`Updated NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
  return response.data;
}

export async function deleteNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId?: string
): Promise<void> {
  const params = locationId ? { location_id: locationId } : undefined;

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    params,
    'DELETE'
  );

  console.log(`Deleted NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
}

// Sync function for appointment types
export async function syncPracticeAppointmentTypes(
  practiceId: string,
  subdomain: string,
  locationId: string
): Promise<void> {
  try {
    console.log(`Syncing appointment types for practice ${practiceId}...`);
    
    // Fetch appointment types from NexHealth
    const nexhealthAppointmentTypes = await getAppointmentTypes(subdomain, locationId);
    
    console.log(`Found ${nexhealthAppointmentTypes.length} appointment types from NexHealth`);

    // Sync each appointment type with local database
    for (const nexhealthType of nexhealthAppointmentTypes) {
      try {
        await prisma.appointmentType.upsert({
          where: {
            practiceId_nexhealthAppointmentTypeId: {
              practiceId,
              nexhealthAppointmentTypeId: nexhealthType.id.toString()
            }
          },
          update: {
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString(),
            lastSyncError: null, // Clear any previous errors on successful sync
            updatedAt: new Date()
          },
          create: {
            practiceId,
            nexhealthAppointmentTypeId: nexhealthType.id.toString(),
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString()
          }
        });

        console.log(`Synced appointment type: ${nexhealthType.name} (ID: ${nexhealthType.id})`);
      } catch (error) {
        console.error(`Error syncing appointment type ${nexhealthType.id}:`, error);
        
        // Try to update just the error field if the record exists
        try {
          await prisma.appointmentType.update({
            where: {
              practiceId_nexhealthAppointmentTypeId: {
                practiceId,
                nexhealthAppointmentTypeId: nexhealthType.id.toString()
              }
            },
            data: {
              lastSyncError: error instanceof Error ? error.message : 'Unknown sync error',
              updatedAt: new Date()
            }
          });
        } catch (updateError) {
          console.error(`Failed to update sync error for appointment type ${nexhealthType.id}:`, updateError);
        }
      }
    }

    console.log(`Completed syncing appointment types for practice ${practiceId}`);
  } catch (error) {
    console.error(`Error syncing appointment types for practice ${practiceId}:`, error);
    throw error;
  }
}

================
File: lib/tools/createNewPatient.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Helper for current date context
function getCurrentDateContext(): string {
  const today = new Date();
  return `Today is ${today.toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  })}`;
}

export const createNewPatientSchema = z.object({
  firstName: z.string()
    .min(1)
    .describe(`Extract patient's first name. If spelled letter by letter (B-O-B), convert to proper name (Bob).

Examples: "My name is Sarah"  "Sarah", "V-A-P-I"  "Vapi"`),
  lastName: z.string()
    .min(1)
    .describe(`Extract patient's last name. If spelled letter by letter (T-E-S-T), convert to proper name (Test).

Examples: "Last name is Johnson"  "Johnson", "Smith, S-M-I-T-H"  "Smith"`),
  dateOfBirth: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD")
    .describe(`Convert date of birth to YYYY-MM-DD format.

${getCurrentDateContext()}

Examples: "January 20, 1990"  "1990-01-20", "1/20/90"  "1990-01-20"
For 2-digit years: 50-99  1900s, 00-49  2000s`),
  phone: z.string()
    .min(10)
    .describe(`Extract phone number as digits only.

Examples: "313-555-1200"  "3135551200", "(313) 555-1200"  "3135551200"`),
  email: z.string()
    .email()
    .describe(`Extract email address. Convert spoken format to proper syntax.

Examples: "john at gmail dot com"  "john@gmail.com"`),
  insurance_name: z.string().optional()
    .describe("Patient's dental insurance company name (e.g., Cigna, MetLife). This is optional. If provided, it will be added to the patient's record.")
});

const createNewPatientTool: ToolDefinition<typeof createNewPatientSchema> = {
  name: "create_new_patient",
  description: `Creates new patient record in EHR system. Collects first/last name, DOB, phone, email. Optionally collects insurance company name. CRITICAL: ONLY call when you have ALL required information (first name, last name, date of birth, phone number 10+ digits, valid email address). DO NOT call if ANY field is missing or empty strings. Ask for missing info first. Insurance name is optional.`,
  schema: createNewPatientSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice, vapiCallId } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I'm sorry, I can't create new patient records right now. Please contact the office directly to register as a new patient."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "I need to assign you to a provider but none are configured. Please contact the office to complete your registration."
      };
    }

    try {
      // Validate all required fields are present and valid
      const validationResult = validatePatientData(args);
      if (!validationResult.isValid) {
        return {
          success: false,
          error_code: validationResult.errorCode || "VALIDATION_ERROR",
          message_to_patient: validationResult.message || "There was an issue with the information provided.",
          details: validationResult.details || "Validation failed"
        };
      }

      // Get the first active provider for new patient assignment
      const activeProvider = practice.savedProviders.find(sp => sp.isActive);
      if (!activeProvider) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "I need to assign you to a provider but none are available. Please contact the office to complete your registration."
        };
      }

      // Prepare new patient data in EXACT NexHealth API format (matching your curl example)
      const patientBio: {
        date_of_birth: string;
        phone_number: string;
        gender: string;
        insurance_name?: string;
      } = {
        date_of_birth: args.dateOfBirth,
        phone_number: args.phone,
        gender: "Female" // Default as per API example - this can be enhanced later
      };

      // Add insurance_name if provided
      if (args.insurance_name && args.insurance_name.trim() !== "") {
        patientBio.insurance_name = args.insurance_name.trim();
      }

      const newPatientData = {
        provider: { 
          provider_id: parseInt(activeProvider.provider.nexhealthProviderId) 
        },
        patient: {
          first_name: args.firstName,
          last_name: args.lastName,
          email: args.email,
          bio: patientBio
        }
      };

      console.log(`[createNewPatient] Creating patient: ${args.firstName} ${args.lastName}`);
      console.log(`[createNewPatient] Patient data:`, JSON.stringify(newPatientData, null, 2));

      const createResponse = await fetchNexhealthAPI(
        '/patients',
        practice.nexhealthSubdomain,
        { location_id: practice.nexhealthLocationId },
        'POST',
        newPatientData
      );

      console.log(`[createNewPatient] API Response:`, JSON.stringify(createResponse, null, 2));

      // Extract patient ID from response (following your curl response format)
      let newPatientId = null;
      if (createResponse?.data?.user?.id) {
        newPatientId = createResponse.data.user.id;
      } else if (createResponse?.data?.id) {
        newPatientId = createResponse.data.id;
      }

      if (!newPatientId) {
        console.error(`[createNewPatient] Failed to extract patient ID from response`);
        return {
          success: false,
          error_code: "PATIENT_CREATION_FAILED",
          message_to_patient: "I had trouble creating your patient record. Please contact the office to complete your registration.",
          details: "Could not extract patient ID from response"
        };
      }

      // Update call log with new patient ID
      await updateCallLogWithPatient(vapiCallId, practice.id, String(newPatientId));

      // Format confirmation message
      const formattedPhone = formatPhoneForDisplay(args.phone);

      // Create context-aware success message based on insurance information
      let successMessage: string;
      if (args.insurance_name && args.insurance_name.trim() !== "") {
        successMessage = `Perfect! I've successfully created your patient profile for ${args.firstName} ${args.lastName}. I've also noted your ${args.insurance_name} insurance. To make sure we have all the details, could you provide the subscriber's full name on that policy?`;
      } else {
        successMessage = `Perfect! I've successfully created your patient profile for ${args.firstName} ${args.lastName}. Welcome to ${practice.name || 'Royal Oak Family Dental'}! Now, what type of appointment were you looking to schedule today?`;
      }

      return {
        success: true,
        message_to_patient: successMessage,
        data: {
          patient_id: String(newPatientId), // Ensure string format for consistency with bookAppointment.ts
          patient_name: `${args.firstName} ${args.lastName}`,
          date_of_birth: args.dateOfBirth,
          phone: formattedPhone,
          email: args.email,
          insurance_name: args.insurance_name || null,
          created: true
        }
      };

    } catch (error) {
      console.error(`[createNewPatient] Error:`, error);
      
      let message = "I'm having trouble creating your patient record right now. Please contact the office directly to register.";
      let errorCode = "PATIENT_CREATION_ERROR";
      
      if (error instanceof Error) {
        if (error.message.includes("400") || error.message.includes("validation")) {
          errorCode = "VALIDATION_ERROR";
          message = "There was an issue with the information provided. Let me help you with the registration process.";
        } else if (error.message.includes("409") || error.message.includes("duplicate")) {
          errorCode = "DUPLICATE_PATIENT";
          message = `It looks like you're already in our system, ${args.firstName}! I've found your existing record. Will you be using the same insurance we have on file, or has anything changed?`;
        } else if (error.message.includes("401")) {
          errorCode = "AUTH_ERROR";
          message = "There's an authentication issue with our system. Please contact the office to register.";
        }
      }
      
      return {
        success: false,
        error_code: errorCode,
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me gather the information needed to create your patient record...",
    success: "Perfect! I've created your patient record and you're all set.",
    fail: "I need some additional information to complete your registration."
  }
};

/**
 * Validate patient data with comprehensive checks
 */
function validatePatientData(args: {
  firstName: string;
  lastName: string;
  dateOfBirth: string;
  phone: string;
  email: string;
}): 
  | { isValid: true; errorCode?: undefined; message?: undefined; details?: undefined }
  | { isValid: false; errorCode: string; message: string; details: string } {
  
  // Check first name
  if (!args.firstName || args.firstName.trim().length === 0) {
    return {
      isValid: false,
      errorCode: "MISSING_FIRST_NAME",
      message: "I need your first name to create your patient record. Could you tell me your first name?",
      details: "First name is required"
    };
  }

  // Check last name
  if (!args.lastName || args.lastName.trim().length === 0) {
    return {
      isValid: false,
      errorCode: "MISSING_LAST_NAME",
      message: "I need your last name to create your patient record. Could you tell me your last name?",
      details: "Last name is required"
    };
  }

  // Check date of birth format
  const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!args.dateOfBirth || !dateRegex.test(args.dateOfBirth)) {
    return {
      isValid: false,
      errorCode: "INVALID_DATE_OF_BIRTH",
      message: "I need your date of birth in a valid format. Could you tell me your date of birth again?",
      details: "Date of birth must be in YYYY-MM-DD format"
    };
  }

  // Check phone number
  if (!args.phone || args.phone.length < 10) {
    return {
      isValid: false,
      errorCode: "MISSING_PHONE",
      message: "I need your phone number to create your patient record. What's your phone number?",
      details: "Phone number is required and must be at least 10 digits"
    };
  }

  // Check email
  if (!args.email || !args.email.includes('@')) {
    return {
      isValid: false,
      errorCode: "MISSING_EMAIL",
      message: "I need your email address to create your patient record. What's your email address?",
      details: "Valid email address is required"
    };
  }

  // Additional phone validation - ensure it's digits only
  const phoneDigits = args.phone.replace(/\D/g, '');
  if (phoneDigits.length < 10) {
    return {
      isValid: false,
      errorCode: "INVALID_PHONE",
      message: "I didn't get a valid phone number. Could you tell me your phone number again?",
      details: "Phone number must contain at least 10 digits"
    };
  }

  return { isValid: true };
}

/**
 * Format phone number for display
 */
function formatPhoneForDisplay(phone: string): string {
  const digits = phone.replace(/\D/g, '');
  if (digits.length === 10) {
    return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
  }
  return phone;
}

/**
 * Update call log with new patient ID
 */
async function updateCallLogWithPatient(vapiCallId: string, practiceId: string, patientId: string) {
  try {
    const { prisma } = await import("@/lib/prisma");
    await prisma.callLog.upsert({
      where: { vapiCallId },
      create: {
        vapiCallId,
        practiceId,
        callStatus: "TOOL_IN_PROGRESS",
        nexhealthPatientId: patientId,
        callTimestampStart: new Date()
      },
      update: {
        nexhealthPatientId: patientId,
        updatedAt: new Date()
      }
    });
  } catch (error) {
    console.error("[createNewPatient] Error updating call log:", error);
  }
}

export default createNewPatientTool;

================
File: lib/tools/checkAvailableSlots.ts
================
import { z } from "zod";
import { ToolDefinition, ToolResult } from "./types";
import { fetchNexhealthAPI } from "@/lib/nexhealth";

// Generate current date dynamically for LLM context
function getCurrentDate(): string {
  const today = new Date();
  return today.toISOString().split('T')[0]; // Returns YYYY-MM-DD
}

export const checkAvailableSlotsSchema = z.object({
  requestedDate: z.string()
    .min(1)
    .refine((date) => {
      if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
        return false;
      }
      // Validate it's a real date
      const parsedDate = new Date(date);
      return !isNaN(parsedDate.getTime()) && date === parsedDate.toISOString().split('T')[0];
    }, "Date must be in YYYY-MM-DD format and be a valid date")
    .describe(`Convert patient's date request to YYYY-MM-DD format.

Current date: ${getCurrentDate()}

Examples:
- "December 23rd"  "2025-12-23"
- "next Friday"  calculate next Friday from ${getCurrentDate()}
- "tomorrow"  calculate tomorrow from ${getCurrentDate()}

Rules:
1. Return YYYY-MM-DD format
2. If no year specified, use next occurrence
3. For relative dates, calculate from ${getCurrentDate()}
4. If ambiguous, ask for clarification`),
  appointmentTypeId: z.string().min(1).describe("The appointment type ID from the previous tool call"),
  days: z.number().min(1).max(7).default(1).describe("Number of days to check (default 1)")
});

const checkAvailableSlotsTool: ToolDefinition<typeof checkAvailableSlotsSchema> = {
  name: "check_available_slots",
  description: "Checks available appointment slots for a specific date and appointment type. Use this after confirming patient identity and appointment type to show available times.",
  schema: checkAvailableSlotsSchema,
  
  async run({ args, context }): Promise<ToolResult> {
    const { practice } = context;
    
    if (!practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
      return {
        success: false,
        error_code: "PRACTICE_CONFIG_MISSING",
        message_to_patient: "I can't check availability right now. Please contact the office directly."
      };
    }

    if (!practice.savedProviders || practice.savedProviders.length === 0) {
      return {
        success: false,
        error_code: "NO_SAVED_PROVIDERS",
        message_to_patient: "The practice hasn't configured any providers for online scheduling. Please contact the office directly."
      };
    }

    try {
      // Get provider and operatory IDs from practice preferences
      const activeProviders = practice.savedProviders.filter(sp => sp.isActive);
      const activeOperatories = practice.savedOperatories?.filter(so => so.isActive) || [];

      if (activeProviders.length === 0) {
        return {
          success: false,
          error_code: "NO_ACTIVE_PROVIDERS",
          message_to_patient: "No providers are currently available for online scheduling. Please contact the office."
        };
      }

      console.log(`[checkAvailableSlots] Checking ${args.requestedDate} for appointment type ${args.appointmentTypeId}`);

      // Get provider and operatory arrays
      const providers = activeProviders.map(sp => sp.provider.nexhealthProviderId);
      const operatories = activeOperatories.map(so => so.nexhealthOperatoryId);

      // Build search params object for NexHealth API
      const searchParams: Record<string, string | string[]> = {
        subdomain: practice.nexhealthSubdomain,
        start_date: args.requestedDate,
        days: args.days.toString(),
        appointment_type_id: args.appointmentTypeId,
        'lids[]': [practice.nexhealthLocationId],
        'pids[]': providers
      };

      // Add operatory IDs if configured
      if (operatories.length > 0) {
        searchParams['operatory_ids[]'] = operatories;
      }

      const slotsResponse = await fetchNexhealthAPI(
        '/appointment_slots',
        practice.nexhealthSubdomain,
        searchParams
      );

      console.log(`[checkAvailableSlots] API response:`, JSON.stringify(slotsResponse, null, 2));

      // Parse response
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const availableSlots: any[] = [];
      
      if (slotsResponse?.data && Array.isArray(slotsResponse.data)) {
        // Extract all slots from all providers
        for (const providerData of slotsResponse.data) {
          if (providerData.slots && Array.isArray(providerData.slots)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            availableSlots.push(...providerData.slots.map((slot: any) => ({
              ...slot,
              provider_id: providerData.pid,
              location_id: providerData.lid
            })));
          }
        }
      }

      if (availableSlots.length === 0) {
        // No slots found - let's provide more helpful information
        console.log(`[checkAvailableSlots] No slots found for appointment type ${args.appointmentTypeId} on ${args.requestedDate}`);
        
        // Create a more conversational and proactive message for no slots found
        const appointmentTypeName = practice.appointmentTypes?.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || "that appointment type";
        const friendlyDate = formatDate(args.requestedDate);
        
        let messageToPatient = `I'm sorry, I don't see any available slots for a ${appointmentTypeName} on ${friendlyDate}.`;

        const otherAppointmentTypesExist = (practice.appointmentTypes?.length || 0) > 1;

        if (otherAppointmentTypesExist) {
          messageToPatient += ` Would you like me to check for a different type of appointment on that day, or perhaps look for ${appointmentTypeName} on another date?`;
        } else {
          messageToPatient += ` Would you like me to check for ${appointmentTypeName} on a different date?`;
        }

        return {
          success: true,
          message_to_patient: messageToPatient,
          data: {
            requested_date: args.requestedDate,
            requested_appointment_type_id: args.appointmentTypeId,
            appointment_type_name: appointmentTypeName, // Add for context
            available_slots: [],
            has_availability: false,
            debug_info: {
              providers_checked: providers.length,
              operatories_checked: operatories.length,
              appointment_type_name: appointmentTypeName
            }
          }
        };
      }

      // Format slots for patient-friendly display
      const formattedSlots = availableSlots.slice(0, 8).map((slot, index) => {
        // Parse the time string correctly to preserve the timezone
        const startTime = new Date(slot.time);
        
        // Use the timezone from the original date string for formatting
        const timeString = startTime.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
          timeZone: 'America/Chicago' // Explicitly use Central Time to match NexHealth
        });
        
        return {
          slot_id: `slot_${index}`,
          time: slot.time,
          end_time: slot.end_time,
          display_time: timeString,
          operatory_id: slot.operatory_id,
          provider_id: slot.provider_id,
          location_id: slot.location_id
        };
      });

      // Create more conversational message with appointment type and limited initial options
      const appointmentTypeName = practice.appointmentTypes?.find(at => at.nexhealthAppointmentTypeId === args.appointmentTypeId)?.name || "your appointment";
      const friendlyDate = formatDate(args.requestedDate);

      // Offer a limited number of slots initially for voice, e.g., 3 or 4
      const slotsToOfferCount = Math.min(formattedSlots.length, 3); // Offer up to 3 slots
      const offeredTimeList = formattedSlots.slice(0, slotsToOfferCount).map(slot => slot.display_time);
      
      let timeOptionsMessage = "";
      if (offeredTimeList.length === 1) {
        timeOptionsMessage = offeredTimeList[0];
      } else if (offeredTimeList.length > 1) {
        timeOptionsMessage = offeredTimeList.slice(0, -1).join(', ') + (offeredTimeList.length > 1 ? ', or ' : '') + offeredTimeList[offeredTimeList.length - 1];
      }

      let finalMessageToPatient = `Okay! For a ${appointmentTypeName} on ${friendlyDate}, I have ${timeOptionsMessage} available.`;

      if (formattedSlots.length > slotsToOfferCount) {
        finalMessageToPatient += ` I also have a few other times that day. Do any of those I mentioned work, or would you like to hear more options for ${friendlyDate}?`;
      } else if (formattedSlots.length > 0) {
        finalMessageToPatient += ` Which of those times works best for you?`;
      } else { // Should not happen if availableSlots.length > 0, but as a fallback
        finalMessageToPatient = `I found some availability on ${friendlyDate} for a ${appointmentTypeName}. Which time would you prefer from the options I mentioned?`;
      }

      return {
        success: true,
        message_to_patient: finalMessageToPatient,
        data: {
          requested_date: args.requestedDate,
          appointment_type_name: appointmentTypeName, // Add for context
          available_slots: formattedSlots, // Send all found slots in data
          has_availability: true,
          total_slots_found: availableSlots.length,
          formatted_times: formattedSlots.map(slot => slot.display_time) // All formatted times
        }
      };

    } catch (error) {
      console.error(`[checkAvailableSlots] Error:`, error);
      
      let message = "I'm having trouble checking availability right now. Please try again or call the office.";
      if (error instanceof Error && error.message.includes("401")) {
        message = "There's an authentication issue with the scheduling system. Please contact support.";
      }
      
      return {
        success: false,
        error_code: "AVAILABILITY_CHECK_ERROR",
        message_to_patient: message,
        details: error instanceof Error ? error.message : "Unknown error"
      };
    }
  },

  messages: {
    start: "Let me check our availability for you...",
    success: "Okay, I have the latest availability information for you.",
    fail: "I'm having trouble checking our schedule right now."
  }
};

function formatDate(dateString: string): string {
  try {
    const date = new Date(dateString + 'T00:00:00');
    return date.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  } catch {
    return dateString;
  }
}

export default checkAvailableSlotsTool;

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Practice {
  id                      String @id @default(cuid())
  clerkUserId             String @unique // Links to Clerk User ID
  name                    String?       // Optional practice name entered by user

  // NexHealth specific identifiers for this practice instance
  nexhealthSubdomain      String?       // User-provided NexHealth subdomain
  nexhealthLocationId     String?       // User-provided NexHealth Location ID

  // Webhook synchronization tracking
  webhookLastSyncAt       DateTime?     // Last time webhooks were synchronized

  // New fields for additional practice information
  address                 String?       // Practice physical address
  acceptedInsurances      String?       // Comma-separated list of accepted insurances
  serviceCostEstimates    String?       // Service cost estimates string

  // VAPI Assistant relationship - moved to separate config table for better modularity
  assistantConfig   PracticeAssistantConfig? // One-to-one relation
  nexhealthWebhookSubscriptions NexhealthWebhookSubscription[] // One-to-many

  appointmentTypes AppointmentType[]
  providers        Provider[]
  callLogs         CallLog[] // For VAPI call logging
  toolLogs         ToolLog[] // For tool execution logging

  // Add new relationships for scheduling preferences
  savedProviders      SavedProvider[]
  savedOperatories    SavedOperatory[]
  manualAvailabilities ManualAvailability[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A practice is uniquely identified by its Clerk user for our app's purposes.
  // Subdomain + LocationID identify it for NexHealth API calls.
  // If a user could manage multiple NexHealth locations, this model would need adjustment.
  // For now, one Clerk user maps to one set of NexHealth subdomain/locationId.
}

model SavedProvider {
  id                  String @id @default(cuid())
  practiceId          String
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  providerId          String   // References Provider.id from our synced data
  provider            Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  
  isDefault           Boolean  @default(false) // Mark primary/default provider
  isActive            Boolean  @default(true)  // Allow enabling/disabling
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@unique([practiceId, providerId]) // Prevent duplicate saves
  @@map("saved_providers")
}

model SavedOperatory {
  id                  String @id @default(cuid())
  practiceId          String
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  nexhealthOperatoryId String  // NexHealth operatory ID
  name                String  // Display name for operatory
  isDefault           Boolean @default(false) // Mark primary/default operatory
  isActive            Boolean @default(true)  // Allow enabling/disabling
  
  // Add relationship to manual availabilities
  manualAvailabilities ManualAvailability[]
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@unique([practiceId, nexhealthOperatoryId]) // Prevent duplicate saves
  @@map("saved_operatories")
}

model PracticeAssistantConfig {
  id                  String @id @default(cuid())
  practiceId          String @unique
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  vapiAssistantId     String? @unique // The ID of the assistant on VAPI's platform
  
  // Customizable fields by practice
  voiceProvider       String   @default("11labs") // e.g., "11labs", "openai", "playht"
  voiceId             String   @default("burt")   // e.g., "burt" for 11labs, "alloy" for openai
  // voiceModel is often tied to provider/voiceId, can be added if needed

  systemPrompt        String   @default("You are a helpful AI assistant for a dental practice. Your primary goal is to assist patients. Be polite and efficient.")
  firstMessage        String   @default("Hello! This is Laine from your dental office. How can I help you today?")

  // Potentially store other VAPI settings if customization is expanded
  // serverUrl for tool calls will be derived from NEXT_PUBLIC_APP_URL

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

// For storing details about the global NexHealth webhook endpoint managed by the SaaS
model GlobalNexhealthWebhookEndpoint {
  id                  String    @id @default("singleton") // Ensures only one record
  nexhealthEndpointId String    @unique // The ID from NexHealth API after creating the endpoint
  secretKey           String    // The secret key provided by NexHealth for this endpoint
  targetUrl           String    // The URL registered with NexHealth (e.g., https://laine-integrated.vercel.app/api/nexhealth-webhook)
  isEnabled           Boolean   @default(true)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
}

// For tracking which practices are subscribed to which NexHealth events
model NexhealthWebhookSubscription {
  id                          String   @id @default(cuid())
  practiceId                  String
  practice                    Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  nexhealthWebhookEndpointId  String   // Foreign key to the global endpoint ID from NexHealth
  nexhealthSubscriptionId     String   @unique // The ID of this specific subscription from NexHealth API
  resourceType                String   // e.g., "Appointment", "Patient"
  eventName                   String   // e.g., "appointment_insertion.complete", "patient_created"
  isActive                    Boolean  @default(true)

  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt

  @@unique([practiceId, resourceType, eventName]) // A practice should only have one active sub for a specific event
}

// For VAPI call logging, as per blueprint
model CallLog {
  id                            String    @id @default(cuid()) // Or use vapi_call_id as PK if always present early
  vapiCallId                    String    @unique // From VAPI
  practiceId                    String
  practice                      Practice  @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  callTimestampStart            DateTime?
  callStatus                    String?   // e.g., INITIATED, IN_PROGRESS, FORWARDING, ENDED
  transcriptText                String?   @db.Text
  summary                       String?   @db.Text // End of call report summary
  vapiTranscriptUrl             String?   // URL to audio recording

  // Fields for tracking tool usage and outcomes within a call
  detectedIntent                String?
  nexhealthPatientId            String?   // If patient identified/created
  bookedAppointmentNexhealthId  String?   // If appointment booked

  // Enhanced fields as per refactoring plan
  assistantId                   String?   // VAPI assistant ID
  endedReason                   String?   // From end-of-call-report
  callDurationSeconds           Int?      // Duration in seconds
  cost                          Decimal?  // Call cost if available

  toolLogs                      ToolLog[] // One-to-many relationship

  createdAt                     DateTime  @default(now())
  updatedAt                     DateTime  @updatedAt
}

// New model for tracking individual tool executions
model ToolLog {
  id                String    @id @default(cuid())
  practiceId        String
  practice          Practice  @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  vapiCallId        String?   // Optional - tools might be called outside of calls
  callLog           CallLog?  @relation(fields: [vapiCallId], references: [vapiCallId], onDelete: Cascade)
  
  toolName          String    // Name of the tool executed
  toolCallId        String    // VAPI tool call ID
  arguments         String?   @db.Text // JSON string of (redacted) arguments
  result            String?   @db.Text // JSON string of result
  success           Boolean   // Whether execution succeeded
  error             String?   // Error message if failed
  executionTimeMs   Int?      // Execution time in milliseconds

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([practiceId, toolName])
  @@index([vapiCallId])
}

model AppointmentType {
  id                          String @id @default(cuid())
  practiceId                  String
  practice                    Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthAppointmentTypeId  String // ID from NexHealth
  name                        String
  duration                    Int    // Duration in minutes (maps to NexHealth 'minutes')
  bookableOnline              Boolean? // Added field for online booking status

  // Optional: Enhanced tracking fields
  parentType                  String? // "Institution" or "Location"
  parentId                    String? // ID of the parent
  lastSyncError               String? // Error tracking for sync operations

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthAppointmentTypeId])
}

model Provider {
  id                  String @id @default(cuid())
  practiceId          String
  practice            Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthProviderId String // ID from NexHealth
  firstName           String?
  lastName            String

  // Add new relationship
  savedByPractices    SavedProvider[]
  manualAvailabilities ManualAvailability[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([practiceId, nexhealthProviderId])
}

model NexhealthTokenCache {
  id          String   @id @default("singleton") // Fixed ID for single token entry
  accessToken String   @db.Text // The bearer token can be long
  expiresAt   DateTime // Timestamp when the token expires
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ManualAvailability {
  id                  String    @id @default(cuid())
  practiceId          String
  practice            Practice  @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  nexhealthAvailabilityId String?   @unique // ID from NexHealth once created, optional as it might not be synced yet or sync failed

  providerId          String    // References our local Provider.id
  provider            Provider  @relation(fields: [providerId], references: [id], onDelete: Cascade)

  operatoryId         String?   // References our local SavedOperatory.id (nexhealthOperatoryId is on SavedOperatory)
  savedOperatory      SavedOperatory? @relation(fields: [operatoryId], references: [id], onDelete: SetNull) // Optional, if operatory is deleted, set this to null

  // For recurring weekly availability
  daysOfWeek          String[]  // Array of strings like ["Monday", "Tuesday", "Friday"]
  beginTime           String    // HH:MM format, e.g., "09:00"
  endTime             String    // HH:MM format, e.g., "17:00"

  // For specific date availability (can be an alternative to daysOfWeek)
  // specificDate        DateTime? @db.Date // YYYY-MM-DD, mutually exclusive with daysOfWeek for simplicity in V1

  appointmentTypeIds  String[]  // Array of nexhealthAppointmentTypeId strings from our AppointmentType model

  isActive            Boolean   @default(true)

  lastSyncWithNexhealthAt DateTime? // Timestamp of the last successful sync with NexHealth
  syncError               String?   // Store any error message from the last sync attempt

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([practiceId, providerId])
}




================================================================
End of Codebase
================================================================
