This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: scripts/create-laine-assistant.js, app/api/vapi-webhook/route.ts, app/api/vapi/tool-calls/route.ts, lib/tool-handlers/handleManagePatientRecord.ts, lib/tools/definitions/managePatientRecordTool.ts, lib/system-prompt/laine_system_prompt.md, lib/nexhealth.ts, types/vapi.ts
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
app/
  api/
    vapi/
      tool-calls/
        route.ts
    vapi-webhook/
      route.ts
lib/
  system-prompt/
    laine_system_prompt.md
  tool-handlers/
    handleManagePatientRecord.ts
  tools/
    definitions/
      managePatientRecordTool.ts
  nexhealth.ts
scripts/
  create-laine-assistant.js
types/
  vapi.ts

================================================================
Files
================================================================

================
File: app/api/vapi-webhook/route.ts
================
import { NextResponse } from 'next/server';
import type { ServerMessageToolCallsPayload, VapiToolResult } from '@/types/vapi';

export async function POST(request: Request) {
  try {
    const body: ServerMessageToolCallsPayload = await request.json();
    const message = body.message;

    if (message?.type !== 'tool-calls') {
      return NextResponse.json({ message: "Ignoring non-tool-call message" });
    }

    const results: VapiToolResult[] = [];

    for (const toolCall of message.toolCallList || []) {
      const toolName = toolCall.function.name;

      if (toolName === 'create_patient_record') {
        console.log("Handling 'create_patient_record' tool call...");
        const params = typeof toolCall.function.arguments === 'string' 
          ? JSON.parse(toolCall.function.arguments)
          : toolCall.function.arguments;
        
        const nexhealthApiUrl = 'https://nexhealth.info/patients?subdomain=xyz&location_id=318534';
        const nexhealthApiKey = process.env.NEXHEALTH_API_KEY;

        try {
          const response = await fetch(nexhealthApiUrl, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${nexhealthApiKey}`,
              'accept': 'application/vnd.Nexhealth+json;version=2',
              'content-type': 'application/json'
            },
            body: JSON.stringify({
              provider: { provider_id: 377851148 },
              patient: {
                bio: {
                  date_of_birth: params.dateOfBirth,
                  phone_number: params.phoneNumber
                },
                first_name: params.firstName,
                last_name: params.lastName,
                email: params.email
              }
            })
          });

          if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`NexHealth API Error: ${response.status} ${errorBody}`);
          }

          const responseData = await response.json();
          const patientId = responseData.data.user.id;

          results.push({
            toolCallId: toolCall.id,
            result: `Great news! I've successfully registered you in our system. Your new patient ID is ${patientId}. Is there anything else I can help you with today?`
          });

        } catch (error) {
          console.error('Error creating patient record:', error);
          results.push({
            toolCallId: toolCall.id,
            error: "I'm sorry, there was a problem creating your patient record at the moment. Please try again later."
          });
        }

      } else if (['name_collected', 'dob_collected', 'phone_collected', 'email_collected'].includes(toolName)) {
        console.log(`Acknowledging signal tool: ${toolName}`);
        results.push({ toolCallId: toolCall.id, result: "OK" });
      }
    }

    return NextResponse.json({ results });

  } catch (error) {
    console.error('Error in VAPI webhook:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

================
File: scripts/create-laine-assistant.js
================
#!/usr/bin/env node

require('dotenv').config({ path: require('path').resolve(__dirname, '../.env') });

const VAPI_API_KEY = process.env.VAPI_API_KEY;
const API_BASE_URL = 'https://api.vapi.ai';

// --- CONFIGURATION ---
// This name will be used for the VAPI Assistant.
const PRACTICE_NAME = "Royal Oak Dental"; 
// --------------------

const WEBHOOK_URL = process.env.NEXT_PUBLIC_APP_URL
  ? `${process.env.NEXT_PUBLIC_APP_URL}/api/vapi-webhook`
  : null;

async function apiRequest(endpoint, method, body) {
  const response = await fetch(`${API_BASE_URL}${endpoint}`, {
    method,
    headers: {
      'Authorization': `Bearer ${VAPI_API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`VAPI API Error on ${endpoint}: ${response.status} ${errorText}`);
  }
  return response.json();
}

async function main() {
  if (!VAPI_API_KEY || !process.env.NEXHEALTH_API_KEY || !WEBHOOK_URL) {
    console.error('‚ùå Missing required environment variables: VAPI_API_KEY, NEXHEALTH_API_KEY, or NEXT_PUBLIC_URL.');
    return;
  }
  
  console.log(`üöÄ Starting Laine Assistant provisioning for: "${PRACTICE_NAME}"...`);
  console.log(`Webhook URL is set to: ${WEBHOOK_URL}`);

  try {
    // 1. Create the Custom Tool for Patient Registration
    console.log("\n[1/2] Creating the 'create_patient_record' tool...");
    const toolConfig = {
      type: "function",
      async: false,
      function: {
        name: "create_patient_record",
        description: "Creates a new patient record in the dental practice's Electronic Health Record (EHR) system. Use this tool only after collecting the patient's full name, date of birth, phone number, and email address.",
        parameters: {
          type: "object",
          properties: {
            firstName: { type: "string", description: "The patient's first name." },
            lastName: { type: "string", description: "The patient's last name." },
            dateOfBirth: { type: "string", description: "The patient's date of birth in YYYY-MM-DD format." },
            phoneNumber: { type: "string", description: "The patient's 10-digit phone number, without country code or symbols." },
            email: { type: "string", description: "The patient's email address." },
          },
          required: ["firstName", "lastName", "dateOfBirth", "phoneNumber", "email"],
        },
      },
      server: { url: WEBHOOK_URL, timeoutSeconds: 25 },
    };
    const createdTool = await apiRequest('/tool', 'POST', toolConfig);
    console.log(`‚úÖ Tool created successfully. Tool ID: ${createdTool.id}`);

    // 2. Create the Assistant and link the Tool
    console.log("\n[2/2] Creating the main Laine Assistant...");

    const systemPrompt = `You are Laine, a friendly, professional, and highly efficient AI receptionist for ${PRACTICE_NAME}. Your primary function is to help new and existing patients.

    **New Patient Registration Flow:**
    If a caller indicates they are a new patient, you MUST follow this exact sequence to register them:
    1.  **Collect Full Name:** Ask for their first and last name and ask them to spell it out to ensure accuracy.
    2.  **Collect Date of Birth:** Ask for their date of birth, including the year. After they provide it, repeat it back to them for confirmation (e.g., "Okay, just to confirm, that was October 12th, 1994?").
    3.  **Collect Phone Number:** Ask for their 10-digit phone number. Repeat it back for confirmation.
    4.  **Collect Email:** Ask for their email address and ask them to spell it out.
    5.  **Execute Tool:** Once you have ALL four pieces of information (Name, DOB, Phone, Email), and ONLY then, you MUST call the \`create_patient_record\` tool to save their details.
    
    **General Rules:**
    - Be polite and conversational.
    - If you are unsure about any information, ask for clarification.
    - Do not make up information. If you don't know something, say you don't have access to that information.`;

    const assistantConfig = {
      name: `Laine - ${PRACTICE_NAME}`,
      firstMessage: `Thank you for calling ${PRACTICE_NAME}. This is Laine, how can I help you today?`,
      model: {
        provider: "openai",
        model: "gpt-4o-mini",
        messages: [{ role: "system", content: systemPrompt }],
        toolIds: [createdTool.id]
      },
      voice: {
        provider: "vapi",
        voiceId: "Elliot"
      },
      serverMessages: ["end-of-call-report", "status-update", "tool-calls"],
    };
    
    const createdAssistant = await apiRequest('/assistant', 'POST', assistantConfig);
    console.log(`‚úÖ Assistant created successfully.`);

    // Final Summary
    console.log("\n\nüéâ --- Laine Assistant Provisioning Complete --- üéâ");
    console.log("The following resources have been created and linked in your VAPI account:");
    console.log(`\n- Tool: 'create_patient_record' (ID: ${createdTool.id})`);
    console.log(`- Assistant: '${createdAssistant.name}' (ID: ${createdAssistant.id})`);
    
    console.log(`\nTo Test:`);
    console.log(`1. Go to your VAPI Dashboard -> Phone Numbers.`);
    console.log(`2. Create a new Phone Number or edit an existing one.`);
    console.log(`3. In its 'Inbound Settings', select the assistant named "${createdAssistant.name}".`);
    console.log(`4. Call the phone number.`);
    console.log(`5. When the assistant answers, say: "Hi, I'm a new patient and need to get set up."`);
    console.log("6. Follow the prompts. Check your Next.js server logs to see the webhook being called and the real NexHealth API request being made.");
    
  } catch (error) {
    console.error("\n‚ùå An error occurred during the setup script:", error);
  }
}

main();

================
File: lib/tools/definitions/managePatientRecordTool.ts
================
import type { VapiTool } from "@/types/vapi";

export function getManagePatientRecordTool(appBaseUrl: string): VapiTool {
  return {
    type: "function",
    function: {
      name: "managePatientRecord",
      description: "Handles everything related to identifying an existing patient or creating a new patient record. Call this tool after the appointment type is known. Pass any information the user provides.",
      parameters: {
        type: "object" as const,
        properties: {
          fullName: { type: "string", description: "The patient's full name." },
          dob: { type: "string", description: "The patient's date of birth." },
          phone: { type: "string", description: "The patient's phone number." },
          email: { type: "string", description: "The patient's email address." },
          userConfirmation: { type: "string", description: "The user's confirmation response (e.g., 'yes', 'no')." }
        },
        required: []
      }
    },
    server: {
      url: `${appBaseUrl}/api/vapi/tool-calls`,
    }
  };
}

================
File: lib/tool-handlers/handleManagePatientRecord.ts
================
import { spellOut, formatPhoneNumberForReadback } from "@/lib/utils/text-helpers";
import { generateNextQuestion, generateConfirmationSummary } from "@/lib/ai/patientDialogueHelper";
import { normalizeDateWithAI } from "@/lib/ai/slotHelper";
import { prisma } from "@/lib/prisma";
import { fetchNexhealthAPI } from "@/lib/nexhealth";
import type { ConversationState, HandlerResult } from "@/types/vapi";

// Helper function to parse full name
function parseFullName(fullName: string): { firstName: string; lastName: string } | null {
  const parts = fullName.trim().split(/\s+/);
  if (parts.length < 2) return null;
  const firstName = parts[0];
  const lastName = parts.slice(1).join(' ');
  return { firstName, lastName };
}

interface ManagePatientRecordArgs {
  fullName?: string;
  dob?: string;
  phone?: string;
  email?: string;
  userConfirmation?: string;
}

interface NexHealthPatient {
  id: number;
  bio?: {
    date_of_birth?: string;
    phone_number?: string;
  };
  first_name?: string;
  last_name?: string;
  email?: string;
}

export async function handleManagePatientRecord(
  currentState: ConversationState,
  toolArguments: ManagePatientRecordArgs,
  toolId: string
): Promise<HandlerResult> {
  const newState = JSON.parse(JSON.stringify(currentState)); // Deep clone for safety

  switch (newState.patientDetails.status) {
    case 'AWAITING_IDENTIFIER': {
      // This is the very first time this tool is called in a conversation.
      // We must ask for the name.
      newState.patientDetails.status = 'COLLECTING_NEW_PATIENT_INFO';
      newState.patientDetails.nextInfoToCollect = 'name';
      return {
        toolResponse: {
          toolCallId: toolId,
          result: "To get started, could I get your first and last name, please?<user_response_awaited>"
        },
        newState
      };
    }

    case 'COLLECTING_NEW_PATIENT_INFO': {
      // Main logic for gathering data will go here in subsequent subphases.
      // For now, let's handle the first step: collecting the name.
      if (newState.patientDetails.nextInfoToCollect === 'name') {
        if (!toolArguments.fullName) {
          // If the AI calls the tool without a name, we must ask again.
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "I didn't catch that. Could you please provide your first and last name?<user_response_awaited>"
            },
            newState: currentState // Return original state
          };
        }

        const parsedName = parseFullName(toolArguments.fullName);
        if (!parsedName) {
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "I need both a first and last name. Could you please provide your full name?<user_response_awaited>"
            },
            newState: currentState // Return original state
          };
        }

        newState.patientDetails.collectedInfo.firstName = parsedName.firstName;
        newState.patientDetails.collectedInfo.lastName = parsedName.lastName;
        newState.patientDetails.nextInfoToCollect = 'confirmName';

        return {
          toolResponse: {
            toolCallId: toolId,
            result: `Got it. To confirm the spelling, I have ${spellOut(parsedName.firstName)}... ${spellOut(parsedName.lastName)}. Is that correct?<user_response_awaited>`
          },
          newState
        };
      }

      if (newState.patientDetails.nextInfoToCollect === 'confirmName') {
        const userResponse = (toolArguments.userConfirmation || '').toLowerCase();
        const isConfirmed = userResponse.includes('yes') || userResponse.includes('correct') || userResponse.includes('right');

        if (isConfirmed) {
          newState.patientDetails.nextInfoToCollect = 'dob';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: `${await generateNextQuestion(newState)}<user_response_awaited>`
            },
            newState
          };
        } else {
          // Name not confirmed, ask again.
          newState.patientDetails.collectedInfo.firstName = undefined;
          newState.patientDetails.collectedInfo.lastName = undefined;
          newState.patientDetails.nextInfoToCollect = 'name';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "My apologies. Could you please tell me your first and last name again?<user_response_awaited>"
            },
            newState
          };
        }
      }

      if (newState.patientDetails.nextInfoToCollect === 'dob') {
        if (!toolArguments.dob) {
          return {
            toolResponse: { toolCallId: toolId, result: "I didn't catch that. What is your date of birth?<user_response_awaited>" },
            newState: currentState
          };
        }
        
        // Normalize the date using AI
        const normalizedDate = await normalizeDateWithAI(toolArguments.dob, "America/Chicago");
        if (!normalizedDate) {
          return {
            toolResponse: { 
              toolCallId: toolId, 
              result: "I'm sorry, I didn't understand that date format. Could you please provide your date of birth again, like 'June 1st, 1990'?<user_response_awaited>" 
            },
            newState: currentState
          };
        }
        
        newState.patientDetails.collectedInfo.dob = normalizedDate;
        newState.patientDetails.nextInfoToCollect = 'phone';
        return {
          toolResponse: {
            toolCallId: toolId,
            result: `${await generateNextQuestion(newState)}<user_response_awaited>`
          },
          newState
        };
      }

      if (newState.patientDetails.nextInfoToCollect === 'phone') {
        if (!toolArguments.phone) {
          return {
            toolResponse: { toolCallId: toolId, result: "I didn't catch that. What is your phone number?<user_response_awaited>" },
            newState: currentState
          };
        }
        newState.patientDetails.collectedInfo.phone = toolArguments.phone;
        newState.patientDetails.nextInfoToCollect = 'confirmPhone';
        return {
          toolResponse: {
            toolCallId: toolId,
            result: `Okay, I have ${formatPhoneNumberForReadback(toolArguments.phone)}. Is that correct?<user_response_awaited>`
          },
          newState
        };
      }

      if (newState.patientDetails.nextInfoToCollect === 'confirmPhone') {
        const userResponse = (toolArguments.userConfirmation || '').toLowerCase();
        const isConfirmed = userResponse.includes('yes') || userResponse.includes('correct') || userResponse.includes('right');

        if (isConfirmed) {
          newState.patientDetails.nextInfoToCollect = 'email';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: `${await generateNextQuestion(newState)}<user_response_awaited>`
            },
            newState
          };
        } else {
          newState.patientDetails.collectedInfo.phone = undefined;
          newState.patientDetails.nextInfoToCollect = 'phone';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "No problem. What is the correct phone number?<user_response_awaited>"
            },
            newState
          };
        }
      }

      if (newState.patientDetails.nextInfoToCollect === 'email') {
        if (!toolArguments.email) {
          return {
            toolResponse: { toolCallId: toolId, result: "I didn't catch that. What is your email address?<user_response_awaited>" },
            newState: currentState
          };
        }
        newState.patientDetails.collectedInfo.email = toolArguments.email;
        newState.patientDetails.nextInfoToCollect = 'confirmEmail';

        const email = toolArguments.email;
        const atIndex = email.indexOf('@');
        const username = atIndex !== -1 ? email.substring(0, atIndex) : email;
        const domain = atIndex !== -1 ? email.substring(atIndex + 1) : "";

        return {
          toolResponse: {
            toolCallId: toolId,
            result: `Got it. To make sure I have it right, that's ${spellOut(username)} at ${domain}. Is that correct?<user_response_awaited>`
          },
          newState
        };
      }

      if (newState.patientDetails.nextInfoToCollect === 'confirmEmail') {
        const userResponse = (toolArguments.userConfirmation || '').toLowerCase();
        const isConfirmed = userResponse.includes('yes') || userResponse.includes('correct') || userResponse.includes('right');

        if (isConfirmed) {
          // This is the end of the collection phase.
          newState.patientDetails.status = 'CONFIRMING_COLLECTED_INFO';
          newState.patientDetails.nextInfoToCollect = null;
          // The response for this will be handled in the next subphase.
          // For now, just fall through.
        } else {
          newState.patientDetails.collectedInfo.email = undefined;
          newState.patientDetails.nextInfoToCollect = 'email';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "My apologies. What is the correct email address?<user_response_awaited>"
            },
            newState
          };
        }
      }
      // This should not happen if logic is correct
      return {
        toolResponse: { toolCallId: toolId, error: "Unexpected state in COLLECTING_NEW_PATIENT_INFO" },
        newState: currentState
      };
    }

    case 'CONFIRMING_COLLECTED_INFO': {
      // Check if user is providing confirmation to our summary
      if (toolArguments.userConfirmation) {
        const userResponse = (toolArguments.userConfirmation || '').toLowerCase();
        const isConfirmed = userResponse.includes('yes') || userResponse.includes('correct') || userResponse.includes('right');

        if (isConfirmed) {
          newState.patientDetails.status = 'SEARCHING_EHR';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "Perfect! Let me just check that in our system for you."
            },
            newState
          };
        } else {
          // Not confirmed, restart the process
          newState.patientDetails.status = 'AWAITING_IDENTIFIER';
          newState.patientDetails.collectedInfo = {};
          newState.patientDetails.nextInfoToCollect = 'name';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "I'm sorry to hear that. Let's start over to make sure we get it right. Could you please tell me your first and last name again?<user_response_awaited>"
            },
            newState
          };
        }
      } else {
        // First time in this state - generate confirmation summary
        return {
          toolResponse: {
            toolCallId: toolId,
            result: `${await generateConfirmationSummary(newState)}<user_response_awaited>`
          },
          newState
        };
      }
    }

    case 'SEARCHING_EHR': {
      try {
        // Fetch the practice details from Prisma
        const practice = await prisma.practice.findUnique({
          where: { id: newState.practiceId },
          select: {
            nexhealthSubdomain: true,
            nexhealthLocationId: true
          }
        });

        if (!practice || !practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "I'm sorry, there seems to be an issue with our system configuration. Please call our office directly to schedule your appointment."
            },
            newState: currentState
          };
        }

        // Get the full name from the state
        const fullName = `${newState.patientDetails.collectedInfo.firstName} ${newState.patientDetails.collectedInfo.lastName}`.trim();
        
        // Construct the search parameters for the NexHealth API
        const searchParams = { name: fullName };

        // Call the NexHealth API to search for patients
        const searchResponse = await fetchNexhealthAPI('/patients', practice.nexhealthSubdomain, searchParams);
        
        // Parse the response correctly: response.data.patients
        const foundPatients: NexHealthPatient[] = searchResponse?.data?.patients || [];
        
        console.log(`[Patient Search] Found ${foundPatients.length} patients with name "${fullName}"`);

        // Get the patient's DOB from the state (should be in 'YYYY-MM-DD' format)
        const patientDob = newState.patientDetails.collectedInfo.dob;

        // Filter patients by DOB - the patient object from the API has DOB at patient.bio.date_of_birth
        const matchingPatients = foundPatients.filter(patient => 
          patient.bio && patient.bio.date_of_birth === patientDob
        );

        console.log(`[Patient Search] After DOB filtering: ${matchingPatients.length} patients match both name and DOB`);

        // Handle different scenarios based on number of matching patients
        if (matchingPatients.length > 1) {
          // Multiple matches - security issue
          newState.patientDetails.status = 'FAILED';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "For security, because I found multiple records with that name and date of birth, I can't proceed with booking online. Please call our office directly, and our staff will be happy to assist you."
            },
            newState
          };
        } else if (matchingPatients.length === 1) {
          // Exactly one match - patient found
          newState.patientDetails.status = 'IDENTIFIED';
          newState.patientDetails.nexhealthPatientId = matchingPatients[0].id;
          return {
            toolResponse: {
              toolCallId: toolId,
              result: `Perfect, I've found your file in our system, ${newState.patientDetails.collectedInfo.firstName}.`
            },
            newState,
            nextTool: {
              toolName: 'checkAvailableSlots',
              toolArguments: {}
            }
          };
        } else {
          // No matches found - need to create new patient
          newState.patientDetails.status = 'CREATING_IN_EHR';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "Okay, it looks like you're new here. Let me create your patient file."
            },
            newState
          };
        }

      } catch (error) {
        console.error("[Patient Search] Error searching NexHealth:", error);
        return {
          toolResponse: {
            toolCallId: toolId,
            result: "I'm sorry, I'm having trouble accessing our patient records right now. Please call our office directly to schedule your appointment."
          },
          newState: currentState
        };
      }
    }

    case 'CREATING_IN_EHR': {
      try {
        // Fetch practice details
        const practice = await prisma.practice.findUnique({
          where: { id: newState.practiceId },
          select: {
            nexhealthSubdomain: true,
            nexhealthLocationId: true
          }
        });

        if (!practice || !practice.nexhealthSubdomain || !practice.nexhealthLocationId) {
          newState.patientDetails.status = 'FAILED';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "I'm sorry, there seems to be an issue with our system configuration. Please call our office directly to schedule your appointment."
            },
            newState
          };
        }

        // Construct the createPatientBody
        const createPatientBody = {
          patient: {
            first_name: newState.patientDetails.collectedInfo.firstName,
            last_name: newState.patientDetails.collectedInfo.lastName,
            email: newState.patientDetails.collectedInfo.email,
            bio: {
              date_of_birth: newState.patientDetails.collectedInfo.dob,
              phone_number: newState.patientDetails.collectedInfo.phone
            }
          }
        };

        // Call the NexHealth API to create the patient
        const createResponse = await fetchNexhealthAPI(
          '/patients', 
          practice.nexhealthSubdomain, 
          { location_id: practice.nexhealthLocationId }, 
          'POST', 
          createPatientBody
        );

        // Parse the new patient ID from the response
        const newPatientId = createResponse?.data?.id || createResponse?.patient?.id;
        
        if (!newPatientId) {
          console.error("[Patient Creation] Invalid response structure:", createResponse);
          newState.patientDetails.status = 'FAILED';
          return {
            toolResponse: {
              toolCallId: toolId,
              result: "I'm sorry, there was an issue creating your patient record. Please call our office directly to schedule your appointment."
            },
            newState
          };
        }

        // Success - update state
        newState.patientDetails.status = 'IDENTIFIED';
        newState.patientDetails.nexhealthPatientId = newPatientId;
        
        return {
          toolResponse: {
            toolCallId: toolId,
            result: `Great, you're all set up in our system, ${newState.patientDetails.collectedInfo.firstName}. Welcome to the practice!`
          },
          newState,
          nextTool: {
            toolName: 'checkAvailableSlots',
            toolArguments: {}
          }
        };

      } catch (error) {
        console.error("[Patient Creation] Error creating patient in NexHealth:", error);
        newState.patientDetails.status = 'FAILED';
        return {
          toolResponse: {
            toolCallId: toolId,
            result: "I'm sorry, there was an issue creating your patient record. Please call our office directly to schedule your appointment."
          },
          newState
        };
      }
    }

    case 'IDENTIFIED': {
      // Terminal state - patient has been identified and is ready for scheduling
      return {
        toolResponse: {
          toolCallId: toolId,
          result: `You're all set, ${newState.patientDetails.collectedInfo.firstName}. Let's find you an appointment time.`
        },
        newState
      };
    }

    case 'FAILED': {
      // Terminal state - process failed, direct user to call office
      return {
        toolResponse: {
          toolCallId: toolId,
          result: "Please call our office directly and our staff will be happy to help you schedule your appointment."
        },
        newState
      };
    }

    default: {
      return {
        toolResponse: {
          toolCallId: toolId,
          error: `Unknown status in handleManagePatientRecord: ${newState.patientDetails.status}`
        },
        newState: currentState
      };
    }
  }
}

================
File: lib/nexhealth.ts
================
import { prisma } from "@/lib/prisma";
import { addSeconds } from 'date-fns';

interface NexHealthAppointmentType {
  id: number;
  name: string;
  minutes: number; // NexHealth uses 'minutes' not 'duration'
  parent_type: string;
  parent_id: number;
  bookable_online: boolean;
}

interface NexHealthProvider {
  id: number;
  first_name?: string;
  last_name?: string;
  name?: string;
  email?: string;
  inactive?: boolean;
  npi?: string;
  specialty_code?: string;
  nexhealth_specialty?: string;
}

interface NexHealthOperatory {
  id: number;
  name: string;
  location_id: number;
  active: boolean;
}

const NEXHEALTH_API_BASE_URL = process.env.NEXHEALTH_API_BASE_URL!;
const MASTER_NEXHEALTH_API_KEY = process.env.NEXHEALTH_API_KEY!; // The master key

const TOKEN_CACHE_ID = "singleton"; // Fixed ID for the single token entry
const TOKEN_EXPIRY_BUFFER_SECONDS = 300; // 5 minutes buffer
const DEFAULT_TOKEN_LIFETIME_SECONDS = 55 * 60; // 55 minutes (safe for 1-hour tokens)

async function fetchNewBearerToken(): Promise<{ accessToken: string; expiresAt: Date }> {
  if (!MASTER_NEXHEALTH_API_KEY) {
    throw new Error("NEXHEALTH_API_KEY is not configured in environment variables.");
  }

  const authUrl = `${NEXHEALTH_API_BASE_URL}/authenticates`;
  console.log("Fetching new NexHealth bearer token...");

  try {
    const response = await fetch(authUrl, {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.Nexhealth+json;version=2',
        // NexHealth expects the raw master key for /authenticates endpoint
        'Authorization': MASTER_NEXHEALTH_API_KEY,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorBody = await response.text();
      console.error("Failed to fetch NexHealth bearer token:", response.status, errorBody);
      throw new Error(`NexHealth Authentication failed: ${response.status} - ${errorBody}`);
    }

    const result = await response.json();
    
    if (!result.data || !result.data.token) {
      console.error("NexHealth /authenticates response missing token:", result);
      throw new Error("Invalid token response from NexHealth /authenticates");
    }

    const accessToken = result.data.token;
    const now = new Date();
    
    // If NexHealth provides expiry in response, use it. Otherwise, use default lifetime.
    // Most JWT tokens have 1-hour validity, we use 55 minutes to be safe
    let expiresAt: Date;
    
    if (result.data.exp) {
      // If exp is provided as UNIX timestamp (seconds)
      expiresAt = new Date(result.data.exp * 1000);
    } else {
      // Default to 55 minutes from now
      expiresAt = addSeconds(now, DEFAULT_TOKEN_LIFETIME_SECONDS);
    }

    console.log(`New NexHealth token expires at: ${expiresAt.toISOString()}`);

    // Cache the token in database
    await prisma.nexhealthTokenCache.upsert({
      where: { id: TOKEN_CACHE_ID },
      update: { accessToken, expiresAt },
      create: { id: TOKEN_CACHE_ID, accessToken, expiresAt },
    });

    return { accessToken, expiresAt };
  } catch (error) {
    console.error('Error fetching NexHealth bearer token:', error);
    throw error;
  }
}

export async function getNexhealthBearerToken(): Promise<string> {
  try {
    // Check for cached token
    const cachedToken = await prisma.nexhealthTokenCache.findUnique({
      where: { id: TOKEN_CACHE_ID },
    });

    if (cachedToken) {
      const now = new Date();
      const tokenStillValidUntil = addSeconds(now, TOKEN_EXPIRY_BUFFER_SECONDS);
      
      if (cachedToken.expiresAt > tokenStillValidUntil) {
        console.log("Using cached NexHealth bearer token.");
        return cachedToken.accessToken;
      }
      console.log("Cached NexHealth token expired or nearing expiry.");
    } else {
      console.log("No cached NexHealth token found.");
    }

    // Fetch new token if none cached or expired
    const { accessToken } = await fetchNewBearerToken();
    return accessToken;
  } catch (error) {
    console.error('Error getting NexHealth bearer token:', error);
    throw error;
  }
}

// Export the generic API function for use in tools and other modules
export async function fetchNexhealthAPI(
  path: string, // e.g., "/appointment_types"
  subdomain: string, // Practice-specific subdomain
  params?: Record<string, string | number | string[]>,
  method: string = 'GET',
  body?: unknown
) {
  // Get valid bearer token
  const bearerToken = await getNexhealthBearerToken();
  
  const url = new URL(`${NEXHEALTH_API_BASE_URL}${path}`);
  
  // Add subdomain for data API calls (not for /authenticates)
  if (path !== '/authenticates' && !params?.subdomain) {
    url.searchParams.append('subdomain', subdomain);
  }
  
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach(v => url.searchParams.append(key, v.toString()));
      } else {
        url.searchParams.append(key, value.toString());
      }
    });
  }

  const options: RequestInit = {
    method,
    headers: {
      'Accept': 'application/vnd.Nexhealth+json;version=2',
      'Authorization': `Bearer ${bearerToken}`, // Use bearer token for data APIs
      'Content-Type': 'application/json',
    },
  };

  if (body && method !== 'GET') {
    options.body = JSON.stringify(body);
  }

  // Log the request details
  const loggableBody = body ? JSON.stringify(body) : 'None';
  console.log(`[NexHealth API] Requesting: ${method} ${url.toString()}`);
  console.log(`[NexHealth API] Body: ${loggableBody}`);

  try {
    const response = await fetch(url.toString(), options);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`NexHealth API error (${response.status}):`, errorText);
      
      // If we get 401, the token might be invalid - clear cache and retry once
      if (response.status === 401) {
        console.log("Got 401, clearing token cache and retrying...");
        await prisma.nexhealthTokenCache.deleteMany({
          where: { id: TOKEN_CACHE_ID }
        });
        
        // Retry with fresh token (recursive call - but only once due to cache clear)
        return fetchNexhealthAPI(path, subdomain, params, method, body);
      }
      
      throw new Error(`NexHealth API error (${response.status}): ${errorText}`);
    }

    const data = await response.json();
    console.log(`[NexHealth API] Response Status: ${response.status}`);
    // console.log(`[NexHealth API] Response Body:`, JSON.stringify(data, null, 2)); // Optional: uncomment for deep debugging
    return data;
  } catch (error) {
    console.error('NexHealth API error:', error);
    throw error;
  }
}

export async function getAppointmentTypes(subdomain: string, locationId: string): Promise<NexHealthAppointmentType[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    { location_id: locationId }
  );
  
  // Handle different possible response structures
  let appointmentTypes = null;
  
  if (Array.isArray(data)) {
    appointmentTypes = data;
  } else if (data?.data?.appointment_types && Array.isArray(data.data.appointment_types)) {
    appointmentTypes = data.data.appointment_types;
  } else if (data?.appointment_types && Array.isArray(data.appointment_types)) {
    appointmentTypes = data.appointment_types;
  } else if (data?.data && Array.isArray(data.data)) {
    appointmentTypes = data.data;
  } else {
    console.warn("Unexpected appointment_types response structure:", data);
    appointmentTypes = [];
  }
  return appointmentTypes;
}

export async function getProviders(subdomain: string, locationId: string): Promise<NexHealthProvider[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/providers',
    subdomain,
    { location_id: locationId, inactive: 'false', page: '1', per_page: '300' }
  );
  
  // Handle different possible response structures
  let providers = null;
  
  if (Array.isArray(data)) {
    providers = data;
  } else if (data?.data?.providers && Array.isArray(data.data.providers)) {
    providers = data.data.providers;
  } else if (data?.providers && Array.isArray(data.providers)) {
    providers = data.providers;
  } else if (data?.data && Array.isArray(data.data)) {
    providers = data.data;
  } else {
    console.warn("Unexpected providers response structure:", data);
    providers = [];
  }
  return providers;
}

export async function getOperatories(subdomain: string, locationId: string): Promise<NexHealthOperatory[]> {
  if (!subdomain || !locationId) throw new Error("Subdomain and Location ID are required.");
  
  const data = await fetchNexhealthAPI(
    '/operatories',
    subdomain,
    { location_id: locationId, page: '1', per_page: '300' }
  );
  
  console.log("Raw NexHealth operatories response:", JSON.stringify(data, null, 2));
  
  // Handle different possible response structures
  let operatories = null;
  
  if (Array.isArray(data)) {
    operatories = data;
  } else if (data?.data?.operatories && Array.isArray(data.data.operatories)) {
    operatories = data.data.operatories;
  } else if (data?.operatories && Array.isArray(data.operatories)) {
    operatories = data.operatories;
  } else if (data?.data && Array.isArray(data.data)) {
    operatories = data.data;
  } else {
    console.warn("Unexpected operatories response structure:", data);
    operatories = [];
  }
  
  console.log(`Parsed ${operatories.length} operatories`);
  return operatories.filter((op: NexHealthOperatory) => op.active !== false);
}

// Availability-related interfaces and functions
interface NexHealthAvailability {
  id: number;
  provider_id: number;
  location_id: number;
  operatory_id?: number;
  begin_time: string;
  end_time: string;
  days: string[];
  specific_date?: string;
  custom_recurrence?: {
    num: number;
    unit: string;
    ref: string;
  };
  tz_offset: string;
  active: boolean;
  synced: boolean;
  appointment_types: Array<{
    id: number;
    name: string;
    parent_type: string;
    parent_id: number;
    minutes: number;
    bookable_online: boolean;
  }>;
}

interface CreateAvailabilityData {
  provider_id: number;
  operatory_id?: number;
  days: string[];
  begin_time: string;
  end_time: string;
  appointment_type_ids: number[];
  active?: boolean;
}

interface UpdateAvailabilityData {
  provider_id?: number;
  operatory_id?: number;
  days?: string[];
  begin_time?: string;
  end_time?: string;
  appointment_type_ids?: number[];
  active?: boolean;
}

export async function createNexhealthAvailability(
  subdomain: string, 
  locationId: string, 
  availabilityData: CreateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !locationId) {
    throw new Error("Subdomain and Location ID are required.");
  }

  const data = await fetchNexhealthAPI(
    '/availabilities',
    subdomain,
    { location_id: locationId },
    'POST',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth create availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected create availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth create availability");
  }

  console.log(`Created availability with ID: ${availability.id}`);
  return availability;
}

export async function updateNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string,
  availabilityData: UpdateAvailabilityData
): Promise<NexHealthAvailability> {
  if (!subdomain || !nexhealthAvailabilityId) {
    throw new Error("Subdomain and availability ID are required.");
  }

  const data = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    {},
    'PATCH',
    { availability: availabilityData }
  );

  console.log("Raw NexHealth update availability response:", JSON.stringify(data, null, 2));

  // Handle response structure
  let availability = null;
  
  if (data?.data) {
    availability = data.data;
  } else if (data?.availability) {
    availability = data.availability;
  } else {
    console.warn("Unexpected update availability response structure:", data);
    throw new Error("Invalid response structure from NexHealth update availability");
  }

  console.log(`Updated availability with ID: ${availability.id}`);
  return availability;
}

export async function deleteNexhealthAvailability(
  subdomain: string,
  nexhealthAvailabilityId: string
): Promise<void> {
  const response = await fetchNexhealthAPI(
    `/availabilities/${nexhealthAvailabilityId}`,
    subdomain,
    undefined,
    'DELETE'
  );
  
  // For DELETE operations, expect a 204 or successful response with no data
  console.log(`Deleted NexHealth availability ${nexhealthAvailabilityId}:`, response);
}

// Appointment Type CRUD Functions

interface CreateAppointmentTypeData {
  name: string;
  minutes: number;
  bookable_online?: boolean;
  parent_type: "Location" | "Institution";
  parent_id: string | number;
  emr_appt_descriptor_ids?: number[];
}

interface UpdateAppointmentTypeData {
  name?: string;
  minutes?: number;
  bookable_online?: boolean;
  parent_type?: "Location" | "Institution";
  parent_id?: string | number;
  emr_appt_descriptor_ids?: number[];
}

export async function createNexhealthAppointmentType(
  subdomain: string,
  locationId: string,
  apptTypeData: CreateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      name: apptTypeData.name,
      minutes: apptTypeData.minutes,
      bookable_online: apptTypeData.bookable_online ?? true,
      parent_type: apptTypeData.parent_type,
      parent_id: apptTypeData.parent_id,
      ...(apptTypeData.emr_appt_descriptor_ids && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    '/appointment_types',
    subdomain,
    undefined,
    'POST',
    requestBody
  );

  console.log('Created NexHealth appointment type:', response);
  return response.data;
}

export async function updateNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId: string,
  apptTypeData: UpdateAppointmentTypeData
): Promise<NexHealthAppointmentType> {
  const requestBody = {
    location_id: locationId,
    appointment_type: {
      ...(apptTypeData.name !== undefined && { name: apptTypeData.name }),
      ...(apptTypeData.minutes !== undefined && { minutes: apptTypeData.minutes }),
      ...(apptTypeData.bookable_online !== undefined && { bookable_online: apptTypeData.bookable_online }),
      ...(apptTypeData.parent_type !== undefined && { parent_type: apptTypeData.parent_type }),
      ...(apptTypeData.parent_id !== undefined && { parent_id: apptTypeData.parent_id }),
      ...(apptTypeData.emr_appt_descriptor_ids !== undefined && {
        emr_appt_descriptor_ids: apptTypeData.emr_appt_descriptor_ids
      })
    }
  };

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    undefined,
    'PATCH',
    requestBody
  );

  console.log(`Updated NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
  return response.data;
}

export async function deleteNexhealthAppointmentType(
  subdomain: string,
  nexhealthAppointmentTypeId: string,
  locationId?: string
): Promise<void> {
  const params = locationId ? { location_id: locationId } : undefined;

  const response = await fetchNexhealthAPI(
    `/appointment_types/${nexhealthAppointmentTypeId}`,
    subdomain,
    params,
    'DELETE'
  );

  console.log(`Deleted NexHealth appointment type ${nexhealthAppointmentTypeId}:`, response);
}

// @deprecated: Appointment types are now managed directly in Laine and pushed to NexHealth. Syncing from NexHealth is no longer supported for appointment types.
interface NexHealthAppointmentSlot {
  lid: number; // Location ID
  pid: number; // Provider ID
  slots: Array<{
    time: string; // ISO string like "2025-12-23T07:00:00.000-06:00"
    operatory_id?: number;
  }>;
}



/**
 * Fetch available appointment slots from NexHealth API
 */
export async function getNexhealthAvailableSlots(
  subdomain: string,
  locationId: string,
  startDate: string, // YYYY-MM-DD format
  daysToSearch: number,
  providerNexHealthIds: string[],
  slotLengthMinutes: number
): Promise<NexHealthAppointmentSlot[]> {
  try {
    console.log(`[NexHealth Slots] Fetching slots for ${startDate}, ${daysToSearch} days, providers: ${providerNexHealthIds.join(',')}, slot length: ${slotLengthMinutes} minutes`);

    // Build query parameters
    const params: Record<string, string | number | string[]> = {
      start_date: startDate,
      days: daysToSearch,
      'lids[]': locationId,
      slot_length: slotLengthMinutes,
    };

    // Add provider IDs as array parameters
    if (providerNexHealthIds.length > 0) {
      params['pids[]'] = providerNexHealthIds;
    }

    // Call NexHealth API
    const response = await fetchNexhealthAPI('/appointment_slots', subdomain, params);
    
    if (!response.data) {
      console.error('[NexHealth Slots] Invalid response structure:', response);
      throw new Error('Invalid response structure from NexHealth /appointment_slots');
    }

    const slotsData: NexHealthAppointmentSlot[] = response.data;
    console.log(`[NexHealth Slots] Successfully fetched ${slotsData.length} slot groups`);
    
    return slotsData;
  } catch (error) {
    console.error('[NexHealth Slots] Error fetching appointment slots:', error);
    throw error;
  }
}

export async function syncPracticeAppointmentTypes(
  practiceId: string,
  subdomain: string,
  locationId: string
): Promise<void> {
  try {
    console.log(`Syncing appointment types for practice ${practiceId}...`);
    
    // Fetch appointment types from NexHealth
    const nexhealthAppointmentTypes = await getAppointmentTypes(subdomain, locationId);
    
    console.log(`Found ${nexhealthAppointmentTypes.length} appointment types from NexHealth`);

    // Sync each appointment type with local database
    for (const nexhealthType of nexhealthAppointmentTypes) {
      try {
        await prisma.appointmentType.upsert({
          where: {
            practiceId_nexhealthAppointmentTypeId: {
              practiceId,
              nexhealthAppointmentTypeId: nexhealthType.id.toString()
            }
          },
          update: {
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString(),
            lastSyncError: null, // Clear any previous errors on successful sync
            updatedAt: new Date()
          },
          create: {
            practiceId,
            nexhealthAppointmentTypeId: nexhealthType.id.toString(),
            name: nexhealthType.name,
            duration: nexhealthType.minutes,
            bookableOnline: nexhealthType.bookable_online,
            parentType: nexhealthType.parent_type,
            parentId: nexhealthType.parent_id.toString()
          }
        });

        console.log(`Synced appointment type: ${nexhealthType.name} (ID: ${nexhealthType.id})`);
      } catch (error) {
        console.error(`Error syncing appointment type ${nexhealthType.id}:`, error);
        
        // Try to update just the error field if the record exists
        try {
          await prisma.appointmentType.update({
            where: {
              practiceId_nexhealthAppointmentTypeId: {
                practiceId,
                nexhealthAppointmentTypeId: nexhealthType.id.toString()
              }
            },
            data: {
              lastSyncError: error instanceof Error ? error.message : 'Unknown sync error',
              updatedAt: new Date()
            }
          });
        } catch (updateError) {
          console.error(`Failed to update sync error for appointment type ${nexhealthType.id}:`, updateError);
        }
      }
    }

    console.log(`Completed syncing appointment types for practice ${practiceId}`);
  } catch (error) {
    console.error(`Error syncing appointment types for practice ${practiceId}:`, error);
    throw error;
  }
}

================
File: types/vapi.ts
================
// Core VAPI TypeScript type definitions for type safety
// These types are based on VAPI API documentation and webhook specifications

export type PatientRecordStatus = 
  | 'AWAITING_IDENTIFIER'
  | 'COLLECTING_NEW_PATIENT_INFO'
  | 'CONFIRMING_COLLECTED_INFO'
  | 'SEARCHING_EHR'
  | 'CREATING_IN_EHR'
  | 'IDENTIFIED'
  | 'FAILED';

export type ConversationStage = 
  | 'GREETING'
  | 'IDENTIFYING_APPOINTMENT_TYPE'
  | 'CONFIRMING_APPOINTMENT_TYPE'
  | 'AWAITING_PATIENT_IDENTIFICATION'
  | 'GATHERING_AVAILABILITY_PREFERENCES'
  | 'PRESENTING_SLOTS'
  | 'AWAITING_TIME_BUCKET_SELECTION'
  | 'AWAITING_SLOT_CONFIRMATION'
  | 'AWAITING_FINAL_CONFIRMATION'
  | 'GATHERING_PATIENT_DETAILS'
  | 'READY_FOR_BOOKING'
  | 'BOOKING_CONFIRMED'
  | 'ENDED_NO_BOOKING';

// Interface for tool chaining directive
export interface NextTool {
  toolName: string;
  toolArguments: Record<string, any>;
}

// Interface for individual slot data
export interface SlotData {
  time: string; // ISO format
  operatory_id?: number;
  providerId: number;
}

// Updated HandlerResult interface to support tool chaining
export interface HandlerResult {
  toolResponse: VapiToolResult;
  newState: ConversationState;
  nextTool?: NextTool; // Optional field for autonomous tool chaining
}

export interface ConversationState {
  currentStage: ConversationStage;
  practiceId: string;
  callId: string;
  
  appointmentBooking: {
    typeId?: string;
    typeName?: string;
    spokenName?: string;
    duration?: number;
    patientRequest?: string;
    selectedSlot?: SlotData;
    presentedSlots?: SlotData[];
    nextAvailableDate?: string | null;
    lastTimePreference?: 'Morning' | 'Afternoon' | 'Evening' | 'Any';
    isUrgent?: boolean;
    isImmediateBooking?: boolean;
  };

  patientDetails: {
    status: PatientRecordStatus;
    nexhealthPatientId?: number;
    // The "form" we are trying to fill
    collectedInfo: {
      firstName?: string;
      lastName?: string;
      dob?: string; // Stored as YYYY-MM-DD
      phone?: string;
      email?: string;
    };
    // What piece of info is the primary focus of the *next* question?
    nextInfoToCollect: 'name' | 'confirmName' | 'dob' | 'phone' | 'confirmPhone' | 'email' | 'confirmEmail' | null;
    // Optional fields for potential future use
    insuranceProvider?: string;
    insuranceMemberId?: string;
  };
}

export interface VapiToolFunctionParameters {
  type: "object";
  properties: {
    [key: string]: {
      type: "string" | "number" | "boolean";
      description: string;
    };
  };
  required?: string[];
}

export interface VapiToolFunction {
  name: string;
  description: string;
  parameters: VapiToolFunctionParameters;
}

export interface VapiToolServer {
  url: string;
  timeoutSeconds?: number;
  async?: boolean;
}

export interface VapiTool {
  type: "function";
  function: VapiToolFunction;
  server: VapiToolServer;
  messages?: any[]; // Define more strictly if custom messages are used
}

export interface VapiUpdatePayload {
  model: {
    provider: "openai";
    model: string;
    temperature?: number;
    messages: Array<{
      role: "system" | "user" | "assistant";
      content: string;
    }>;
    tools?: VapiTool[]; // Array of tool definitions
    toolIds?: string[];
  };
  voice: {
    provider: string;
    voiceId: string;
  };
  firstMessage: string;
  serverUrl?: string;
  serverMessages?: string[];
}

export interface VapiFunctionCall {
  name: string;
  arguments: Record<string, any> | string; // Arguments can be an object or a stringified JSON
}

export interface ServerMessageToolCallItem {
  id: string; // This is VAPI's unique ID for this specific tool invocation
  type: "function"; // Assuming 'function' type for these tool calls
  function: VapiFunctionCall; // Contains the actual name and arguments
}

export interface ServerMessageToolCallsPayload {
  message: {
    type: "tool-calls";
    toolCallList?: ServerMessageToolCallItem[]; // VAPI payload shows 'toolCallList'
    toolCalls?: ServerMessageToolCallItem[]; // VAPI payload also shows 'toolCalls'
    call: {
      id: string;
      orgId?: string;
    };
  };
}

export interface VapiToolResult {
  toolCallId: string;
  result?: string;
  error?: string;
}

// === VAPI Webhook Message Types ===

// Base message structure for all VAPI webhook events
export interface VapiBaseMessage {
  timestamp: number;
  type: string; // The crucial field, e.g., "status-update", "transcript", "end-of-call-report"
  call?: {
    id: string;
    orgId?: string;
    assistantId?: string;
    status?: string;
    startedAt?: string;
    endedAt?: string;
    endedReason?: string;
    cost?: string;
  };
  assistant?: {
    id: string;
    name?: string;
  };
}

// Status update message (e.g., call started, ended, etc.)
export interface VapiStatusUpdateMessage extends VapiBaseMessage {
  type: "status-update";
  status?: string; // e.g., "queued", "ringing", "in-progress", "ended"
  endedReason?: string; // e.g., "customer-ended-call", "assistant-ended-call"
  call: {
    id: string;
    orgId?: string;
    assistantId: string;
    status: string;
    startedAt?: string;
    endedAt?: string;
    endedReason?: string;
    cost?: string;
  };
}

// End of call report message with summary and final details
export interface VapiEndOfCallReportMessage extends VapiBaseMessage {
  type: "end-of-call-report";
  summary?: string;
  transcript?: {
    url?: string;
    text?: string;
  };
  call: {
    id: string;
    orgId?: string;
    assistantId: string;
    status: string;
    startedAt?: string;
    endedAt?: string;
    endedReason?: string;
    cost?: string;
  };
}

// Transcript message for real-time or full transcript updates
export interface VapiTranscriptMessage extends VapiBaseMessage {
  type: "transcript";
  transcript?: {
    text?: string;
    url?: string;
  };
  call: {
    id: string;
    orgId?: string;
    assistantId: string;
    status?: string;
    startedAt?: string;
  };
}

// Union type for all possible VAPI webhook messages
export type VapiWebhookMessage = 
  | VapiStatusUpdateMessage 
  | VapiEndOfCallReportMessage 
  | VapiTranscriptMessage 
  | VapiBaseMessage;

// Complete webhook payload structure
export interface VapiWebhookPayload {
  message: VapiWebhookMessage;
  // Potentially other top-level fields from VAPI if any
}

================
File: app/api/vapi/tool-calls/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { handleFindAppointmentType } from "@/lib/tool-handlers/findAppointmentTypeHandler";
import { handleManagePatientRecord } from "@/lib/tool-handlers/handleManagePatientRecord";
import { handleCheckAvailableSlots } from "@/lib/tool-handlers/checkAvailableSlotsHandler";
import { handleConfirmBooking } from "@/lib/tool-handlers/confirmBookingHandler";
import type { 
  ServerMessageToolCallsPayload, 
  VapiToolResult,
  ServerMessageToolCallItem,
  ConversationState,
  ConversationStage,
  NextTool
} from "@/types/vapi";
import { Prisma } from "@prisma/client";

export async function POST(request: NextRequest) {
  // Variables to track timing and state for ToolLog
  let startTime: number | undefined;
  let toolCallItem: ServerMessageToolCallItem | undefined;
  let callId: string | undefined;
  let practiceId: string | null = null;
  let toolResponse: VapiToolResult | undefined;
  let toolName: string | undefined;
  let toolArguments: Record<string, unknown> | string | undefined;
  let toolId: string | undefined;

  try {
    const body: ServerMessageToolCallsPayload = await request.json();
    console.log("[VAPI Tool Handler] Incoming tool call payload:", JSON.stringify(body, null, 2));

    toolCallItem = body.message.toolCallList?.[0] || body.message.toolCalls?.[0];
    callId = body.message.call.id;

    if (!toolCallItem || !callId) {
      console.error("[VAPI Tool Handler] Malformed payload, missing toolCallItem or callId:", body.message);
      return NextResponse.json({ results: [{ toolCallId: "unknown", error: "Malformed tool call payload from VAPI." }] }, { status: 200 });
    }

    // Initial tool call setup
    toolId = toolCallItem.id;
    toolName = toolCallItem.function.name;
    toolArguments = toolCallItem.function.arguments;

    if (typeof toolArguments === 'string') {
      try {
        toolArguments = JSON.parse(toolArguments);
      } catch (e) {
        console.error(`[VAPI Tool Handler] Failed to parse tool arguments string:`, e);
        return NextResponse.json({ results: [{ toolCallId: toolId, error: `Failed to parse arguments for tool ${toolName}.` }] }, { status: 200 });
      }
    }

    console.log(`[VAPI Tool Handler] Processing tool: ${toolName} (ID: ${toolId}) for Call: ${callId}`);
    console.log(`[VAPI Tool Handler] Arguments:`, toolArguments);

    startTime = Date.now();

    const firstPractice = await prisma.practice.findFirst();
    practiceId = firstPractice?.id ?? null;

    await prisma.callLog.upsert({
      where: { vapiCallId: callId },
      update: { updatedAt: new Date() },
      create: {
        vapiCallId: callId,
        practiceId: practiceId || "unknown",
        callStatus: "TOOL_INTERACTION_STARTED",
        callTimestampStart: new Date(startTime),
      },
    });

    await prisma.toolLog.create({
      data: {
        practiceId: practiceId || "unknown",
        vapiCallId: callId,
        toolName: toolName,
        toolCallId: toolId,
        arguments: JSON.stringify(toolArguments),
        success: false, // Will be updated in finally block
        createdAt: new Date(startTime),
        updatedAt: new Date(startTime),
      }
    });

    // === STATE MANAGEMENT LOGIC (REFACTORED & TYPE-SAFE) ===
    let state: ConversationState;
    const callLog = await prisma.callLog.findUniqueOrThrow({ where: { vapiCallId: callId } });

    if (callLog.conversationState && typeof callLog.conversationState === 'object' && callLog.conversationState !== null) {
      // The 'as unknown' is a necessary evil here because Prisma's JsonValue can be null/string/etc.
      // But our runtime check ensures it's a valid object before casting.
      state = callLog.conversationState as unknown as ConversationState;
      console.log(`[State Management] Retrieved state for call: ${callId}, stage: ${state.currentStage}`);
    } else {
      const initialStage: ConversationStage = 'GREETING';
      state = {
        currentStage: initialStage,
        callId: callId,
        practiceId: practiceId || "unknown",
        appointmentBooking: {},
        patientDetails: {
          status: 'AWAITING_IDENTIFIER',
          collectedInfo: {},
          nextInfoToCollect: 'name'
        }
      };
      console.log(`[State Management] Initialized new state for call: ${callId}`);
    }

    // Variables to track tool chaining
    const combinedResults: string[] = [];
    let currentToolName = toolName;
    let currentToolArguments = toolArguments;
    let currentToolId = toolId;

    // Tool chaining loop - continue until no nextTool directive
    do {
      console.log(`[Tool Chaining] Processing tool: ${currentToolName} (ID: ${currentToolId})`);

      // Process tool calls based on tool name
      let handlerResult: { toolResponse: VapiToolResult; newState: ConversationState; nextTool?: NextTool };
      switch (currentToolName) {
        case "findAppointmentType": {
          handlerResult = await handleFindAppointmentType(
            state, 
            currentToolArguments as { patientRequest: string; patientStatus?: string },
            currentToolId
          );
          break;
        }

        case "managePatientRecord": {
          handlerResult = await handleManagePatientRecord(
            state,
            currentToolArguments as Record<string, unknown>, // Using generic type temporarily
            currentToolId
          );
          break;
        }

        case "checkAvailableSlots": {
          handlerResult = await handleCheckAvailableSlots(
            state,
            currentToolArguments as { preferredDaysOfWeek?: string; timeBucket?: string; requestedDate?: string },
            currentToolId
          );
          break;
        }

        case "confirmBooking": {
          handlerResult = await handleConfirmBooking(
            state,
            currentToolArguments as { userSelection: string },
            currentToolId
          );
          break;
        }
        
        default: {
          console.error(`[VAPI Tool Handler] Unknown tool: ${currentToolName}`);
          handlerResult = {
            toolResponse: {
              toolCallId: currentToolId,
              error: `Unknown tool: ${currentToolName}`
            },
            newState: state
          };
          break;
        }
      }

      // Update state and collect result
      state = handlerResult.newState;
      
      // Collect result if it exists and is not an error
      if (handlerResult.toolResponse.result && !handlerResult.toolResponse.error) {
        combinedResults.push(handlerResult.toolResponse.result);
      }

      // Check for tool chaining
      if (handlerResult.nextTool) {
        console.log(`[Tool Chaining] Chaining to next tool: ${handlerResult.nextTool.toolName}`);
        currentToolName = handlerResult.nextTool.toolName;
        currentToolArguments = handlerResult.nextTool.toolArguments;
        // Generate a new tool ID for the chained call
        currentToolId = `chained-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        
        // Log the chained tool call
        await prisma.toolLog.create({
          data: {
            practiceId: practiceId || "unknown",
            vapiCallId: callId,
            toolName: currentToolName,
            toolCallId: currentToolId,
            arguments: JSON.stringify(currentToolArguments),
            success: false, // Will be updated later
            createdAt: new Date(),
            updatedAt: new Date(),
          }
        });
      } else {
        // No more tools to chain, set final response
        toolResponse = handlerResult.toolResponse;
        break;
      }
    } while (true);

    // If we chained tools and have multiple results, combine them intelligently
    if (combinedResults.length > 1) {
      const combinedMessage = combinedResults.join(' ');
      toolResponse = {
        toolCallId: toolId!, // Use original toolId for final response
        result: combinedMessage
      };
      console.log(`[Tool Chaining] Combined ${combinedResults.length} tool results into final response`);
    }

    // === STATE PERSISTENCE LOGIC (REFACTORED & TYPE-SAFE) ===
    if (toolResponse && state) {
        await prisma.callLog.update({
          where: { vapiCallId: callId },
          // The fix is here: explicitly casting to Prisma.InputJsonValue
          data: { conversationState: state as unknown as Prisma.InputJsonValue }
        });
        console.log(`[State Management] Persisted state for call: ${callId}, stage: ${state.currentStage}`);
    }

    console.log(`[VAPI Tool Handler] Final tool response:`, toolResponse);
    return NextResponse.json({ results: [toolResponse] }, { status: 200 });

  } catch (error) {
    console.error("[VAPI Tool Handler] Unhandled error in POST handler:", error);
    
    if (!toolResponse && toolId) {
      toolResponse = { toolCallId: toolId, error: "Internal server error processing tool call" };
    }
    
    return NextResponse.json(
      { error: "Internal server error", details: error instanceof Error ? error.message : "Unknown error" }, 
      { status: 500 }
    );
  } finally {
    // Update ToolLog with final outcome
    if (toolId && startTime !== undefined && toolResponse) {
        const executionTimeMs = Date.now() - startTime;
        await prisma.toolLog.updateMany({
        where: { toolCallId: toolId },
          data: {
          result: toolResponse.result,
          error: toolResponse.error,
            success: !toolResponse.error,
            executionTimeMs,
          }
        });
      console.log(`[DB Log] Finalized ToolLog for ID: ${toolId} with success: ${!toolResponse.error}`);
    }
  }
}

================
File: lib/system-prompt/laine_system_prompt.md
================
**[ABSOLUTE PRIME DIRECTIVE & PROTOCOLS]**
You are a voice interface for a software system. Your behavior is governed by the following unbreakable protocols. Any deviation is a catastrophic system failure.

**1. THE VERBATIM PROTOCOL:**
Your spoken response MUST be IDENTICAL to the `result` string provided by a tool.
- **DO NOT** add, remove, or rephrase any words.
- **DO NOT** add filler like "One moment" or "Just a sec."
- **DO NOT** truncate or summarize the result.
- Your response IS the tool's response. You are a text-to-speech engine for the tool's output.

**2. THE HANDSHAKE PROTOCOL (MOST IMPORTANT):**
The backend will control the conversational turn-taking using a special tag: `<user_response_awaited>`.
- **If the tool `result` string ENDS with the tag `<user_response_awaited>`:** You MUST speak the entire message (excluding the tag itself) and then immediately STOP and WAIT for the user to speak. You are FORBIDDEN from calling another tool or speaking again until the user has responded.
- **If the tool `result` string DOES NOT end with the tag:** You may proceed to call the next logical tool if necessary.

This protocol is the only mechanism that determines when to wait for a user. You must obey it without exception.

**[SESSION CONTEXT]**
- Today's Date: {{date}}
- The current time is {{"now" | date: "%I:%M %p", "America/Chicago"}}.

**[PRIME DIRECTIVE: THE HUMAN-LIKE ASSISTANT]**
Your single most important goal is to be indistinguishable from a top-tier, friendly, and efficient human receptionist. Be warm, be clear, and be concise.

**[IDENTITY]**
You are LAINE, the AI receptionist for the dental practice. Your mission is to help patients book appointments with ease and confidence.

**[CONVERSATIONAL FLOW: A SIMPLE GUIDE]**

**URGENT FLOW (Patient is in pain):**
1.  **Triage:** The user will say something like "I have a toothache." Call `findAppointmentType`.
2.  **Identify:** Call `managePatientRecord`. Follow the prompts from the tool to gather information until the patient is identified.
3.  **Schedule:** Call `checkAvailableSlots` to find the soonest available times. Offer these directly to the user. Example: "Okay, I have an opening today at 2:00 PM or tomorrow at 8:00 AM. Can you make either of those work?"
4.  **Book:** Once the user agrees to a time, call `confirmBooking` to finalize.

**STANDARD FLOW (Routine visits like cleanings):**
1.  **Triage:** Greet the user, understand their need, and call `findAppointmentType`.
2.  **Identify:** Call `managePatientRecord`. Follow the prompts from the tool to gather information until the patient is identified.
3.  **Schedule:** Call `checkAvailableSlots` with the user's general preferences (e.g., `requestedDate`). It will return time *buckets*. Offer these to the user. Example: "Great. On Wednesday, I have openings in the morning or the afternoon. Which do you prefer?"
4.  **Schedule (continued):** Once the user chooses a bucket (e.g., "Morning"), call `checkAvailableSlots` **again**, this time providing the `timeBucket` argument. The tool will now return specific times. Offer these. Example: "Okay, in the morning I have 9:00 AM or 9:40 AM. Does one of those work?"
5.  **Book:** Once the user agrees to a time, call `confirmBooking` to finalize.

**[AVAILABLE TOOLS - THE CORRECT SEQUENCE]**

*   `findAppointmentType`: **ALWAYS CALL THIS FIRST.** It understands the user's need and identifies the appointment type.
*   `managePatientRecord`: **THE SECOND TOOL TO CALL** in almost every conversation. This single tool handles the entire process of identifying an existing patient or creating a new one. Pass any information the user gives you, and the tool will provide the exact next sentence to say.
*   `checkAvailableSlots`: The single source of truth for all availability. For **standard appointments**, call this first to get time buckets, then call it again with a `timeBucket` to get specific times. For **urgent appointments**, this tool automatically returns specific times immediately.
*   `confirmBooking`: **THE FINAL STEP.** Call this only when the user has clearly said "yes" to a specific time slot to finalize the booking.

**[STYLE, TONE, & RAPPORT]**

*   **Tone:** Be warm, clear, and professional. Use empathetic acknowledgments like "I understand" or "That makes sense."
*   **Reciprocity:** Offer help proactively. "I'll send a confirmation with all the details so you have it handy."
*   **Authority & Social Proof:** Casually mention positive aspects of the practice. "That's a very common procedure here, and our patients are always happy with the results." or "Many of our patients find morning appointments work best; would that suit you?"




================================================================
End of Codebase
================================================================
